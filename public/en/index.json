


[{"content":"","date":"2024 September 15","externalUrl":null,"permalink":"/categories/codeforces/","section":"Categories","summary":"","title":"Codeforces","type":"categories"},{"content":"","date":"2024 September 15","externalUrl":null,"permalink":"/series/codeforces-round-972-div.-2/","section":"Series","summary":"","title":"Codeforces Round 972 (Div. 2)","type":"series"},{"content":"\r1. 题目 #\rEnglish\rNarek is too lazy to create the third problem of this contest. His friend Artur suggests that he should use ChatGPT. ChatGPT creates \\(n\\) problems, each consisting of \\(m\\) letters, so Narek has \\(n\\) strings. To make the problem harder, he combines the problems by selecting some of the \\(n\\) strings possibly none and concatenating them without altering their order. His chance of solving the problem is defined as \\(score_n - score_c\\), where \\(score_n\\) is Narek\u0026rsquo;s score and \\(score_c\\) is ChatGPT\u0026rsquo;s score.\nNarek calculates \\(score_n\\) by examining the selected string (he moves from left to right). He initially searches for the letter \\(\\texttt{\u0026ldquo;n\u0026rdquo;}\\), followed by \\(\\texttt{\u0026ldquo;a\u0026rdquo;}\\), \\(\\texttt{\u0026ldquo;r\u0026rdquo;}\\), \\(\\texttt{\u0026ldquo;e\u0026rdquo;}\\), and \\(\\texttt{\u0026ldquo;k\u0026rdquo;}\\). Upon finding all occurrences of these letters, he increments \\(score_n\\) by \\(5\\) and resumes searching for \\(\\texttt{\u0026ldquo;n\u0026rdquo;}\\) again (he doesn\u0026rsquo;t go back, and he just continues from where he left off).\nAfter Narek finishes, ChatGPT scans through the array and increments \\(score_c\\) by \\(1\\) for each letter \\(\\texttt{\u0026ldquo;n\u0026rdquo;}\\), \\(\\texttt{\u0026ldquo;a\u0026rdquo;}\\), \\(\\texttt{\u0026ldquo;r\u0026rdquo;}\\), \\(\\texttt{\u0026ldquo;e\u0026rdquo;}\\), or \\(\\texttt{\u0026ldquo;k\u0026rdquo;}\\) that Narek fails to utilize (note that if Narek fails to complete the last occurrence by finding all of the \\(5\\) letters, then all of the letters he used are counted in ChatGPT\u0026rsquo;s score \\(score_c\\), and Narek doesn\u0026rsquo;t get any points if he doesn\u0026rsquo;t finish finding all the 5 letters).\nNarek aims to maximize the value of \\(score_n - score_c\\) by selecting the most optimal subset of the initial strings.\nInput\nIn the first line of the input, you\u0026rsquo;re given a single integer \\(t\\) (\\(1 \\le t \\le 10^5\\)), the number of test cases. Then the description of each test case follows.\nIn the first line of each test case, you\u0026rsquo;re given two integers \\(n, m\\) (\\(1 \\le n, m \\le 10^3\\)), the number of strings and the length of each string.\nIn the next \\(n\\) lines, you\u0026rsquo;re given \\(n\\) strings, each having a length of \\(m\\). The strings only contain lowercase letters of the English alphabet.\nThe sum of values of \\(n \\cdot m\\) over all test cases does not exceed \\(10^6\\).\nOutput\nFor each test case, output a single integer: the maximal possible value of \\(score_n - score_c\\).\n简体中文（大意）\r有 \\(n\\) 个长度为 \\(m\\) 的字符串，选择其中一些字符串并按顺序相连组成新的字符串。新字符串中每出现 \\(\\texttt{narek}\\) 的完整子序列就会加 \\(5\\) 分（不完整不加分），其他出现在 \\(\\texttt{narek}\\) 中但没有出现在子序列中的字母会减 \\(1\\) 分。求任意选择字符串拼接所能得到的最大的分数。\r2. 思路 #\r对于任意两字符串拼接，它产生的得分取决与上一个字符串结尾需要什么字母，例如：\n\\(\\texttt{\\color{red}nare}\\texttt{zz}\\) \\(\\texttt{\\color{blue}n}\\texttt{\\color{red}k}\\texttt{\\color{blue}arek}\\) 由于第一个字符串结尾的时候需要 \\(\\texttt{k}\\)，所以拼接的时候第二个字符串产生的贡献由第一个 \\(\\texttt{k}\\) 提供，其他几个在 \\(\\texttt{narek}\\) 中的字母要提供负贡献。由此可以看出满足动态规划的最优子结构和无后效性，基本可以判断为动态规划的问题。\n由于当前字符串的结果取决于上一个字符串结尾需要什么字母，所以我们将每个字符串结尾所需要的字母建立动态规划数组，动态地更新每一轮假如从之前的某一个字符串结尾所需要字母开始所能产生的最优贡献。\n当处理完最后一个字符串的时候，我们得到所有 \\(5\\) 个字母结尾的动态规划数组，然而由于不完整的字符串不能提供贡献，所以最后一个字符串所需要的字符不为 \\(\\texttt{n}\\) 则应该减去已经产生的贡献。\n3. 代码 #\rC\u0026#43;\u0026#43;\rvoid solve() { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::string s[n]; for (int i = 0; i \u0026lt; n; i++) { std::cin \u0026gt;\u0026gt; s[i]; } std::array\u0026lt;int, 5\u0026gt; dp; dp.fill(-inf); dp[0] = 0; const std::string t = \u0026#34;narek\u0026#34;; for (int i = 0; i \u0026lt; n; i++) { auto ndp = dp; for (int x = 0; x \u0026lt; 5; x++) { int y = x; int res = dp[x]; for (auto c : s[i]) { if (c == t[y]) { y++; if (y == 5) { y = 0; res += 5; } } else if (t.find(c) != -1) { res--; } } ndp[y] = std::max(ndp[y], res); } dp = ndp; } int ans = 0; for (int i = 0; i \u0026lt; 5; i++) { ans = std::max(ans, dp[i] - i); } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 4. 总结 #\r这是一道动态规划的问题，问题的关键是怎么建立动态规划的数组来转移状态。\n我们分析得到每一个字符串所能产生的贡献只有上一个字符串结尾的字母决定，所以应当根据上一个字符串结尾的字母建立动态规划数组，然后每次单独计算这个字符串的所能产生的贡献对动态规划数组进行更新，时间复杂度为 \\(O(n\\cdot m\\cdot 5)\\)。\n","date":"2024 September 15","externalUrl":null,"permalink":"/posts/contest/codeforces/codeforcesround972_div2/c/","section":"Posts","summary":"1.","title":"Codeforces Round 972 (Div. 2) - C","type":"posts"},{"content":"","date":"2024 September 15","externalUrl":null,"permalink":"/categories/div2/","section":"Categories","summary":"","title":"Div2","type":"categories"},{"content":"","date":"2024 September 15","externalUrl":null,"permalink":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"","date":"2024 September 15","externalUrl":null,"permalink":"/categories/%E6%AF%94%E8%B5%9B/","section":"Categories","summary":"","title":"比赛","type":"categories"},{"content":"\r1. 题目 #\rEnglish\rNarek and Tsovak were busy preparing this round, so they have not managed to do their homework and decided to steal David\u0026rsquo;s homework. Their strict teacher noticed that David has no homework and now wants to punish him. She hires other teachers to help her catch David. And now \\(m\\) teachers together are chasing him. Luckily, the classroom is big, so David has many places to hide.\nThe classroom can be represented as a one-dimensional line with cells from \\(1\\) to \\(n\\), inclusive.\nAt the start, all \\(m\\) teachers and David are in distinct cells. Then they make moves. During each move\nDavid goes to an adjacent cell or stays at the current one. Then, each of the \\(m\\) teachers simultaneously goes to an adjacent cell or stays at the current one. This continues until David is caught. David is caught if any of the teachers (possibly more than one) is located in the same cell as David. Everyone sees others\u0026rsquo; moves, so they all act optimally.\nYour task is to find how many moves it will take for the teachers to catch David if they all act optimally.\nActing optimally means the student makes his moves in a way that maximizes the number of moves the teachers need to catch him; and the teachers coordinate with each other to make their moves in a way that minimizes the number of moves they need to catch the student.\nAlso, as Narek and Tsovak think this task is easy, they decided to give you \\(q\\) queries on David\u0026rsquo;s position.\nInput\nIn the first line of the input, you are given a single integer \\(t\\) (\\(1 \\le t \\le 10^5\\)) — the number of test cases. The description of each test case follows.\nIn the first line of each test case, you are given three integers \\(n\\), \\(m\\), and \\(q\\) (\\(3 \\le n \\le 10^9\\), \\(1 \\le m, q \\le 10^5\\)) — the number of cells on the line, the number of teachers, and the number of queries.\nIn the second line of each test case, you are given \\(m\\) distinct integers \\(b_1, b_2, \\ldots, b_m\\) (\\(1 \\le b_i \\le n\\)) — the cell numbers of the teachers.\nIn the third line of each test case, you are given \\(q\\) integers \\(a_1, a_2, \\ldots, a_q\\) (\\(1 \\le a_i \\le n\\)) — David\u0026rsquo;s cell number for every query.\nIt is guaranteed that for any \\(i\\), \\(j\\) such that \\(1 \\le i \\le m\\) and \\(1 \\le j \\le q\\), \\(b_i \\neq a_j\\).\nIt is guaranteed that the sum of values of \\(m\\) over all test cases does not exceed \\(2 \\cdot 10^5\\).\nIt is guaranteed that the sum of values of \\(q\\) over all test cases does not exceed \\(2 \\cdot 10^5\\).\nOutput\nFor each test case, output \\(q\\) lines, the \\(i\\)-th of them containing the answer of the \\(i\\)-th query.\n简体中文（大意）\r已知 \\(m\\) 个老师在数轴上的位置坐标，假如每次能移动一格，求每次询问给出学生的位置坐标，该位置的学生最晚什么时候被抓住。\r2. 思路 #\r学生的位置只能在三个位置：所有老师最左边、所有老师最右边、某两个老师中间。\n由于学生和老师的速度相同，所以在所有老师的一侧的时候，只能逃离到最边缘才会被抓住。而在两个老师中间的区域时，学生最优的情况就是先走到两个老师的中间，然后保持不动直到被抓住。\n3. 代码 #\rC\u0026#43;\u0026#43;\rvoid solve() { int n, m, q; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; std::vector\u0026lt;int\u0026gt; b(m); for (int i = 0; i \u0026lt; m; i++) { std::cin \u0026gt;\u0026gt; b[i]; } std::sort(b.begin(), b.end()); for (int i = 0; i \u0026lt; q; i++) { int a; std::cin \u0026gt;\u0026gt; a; if (a \u0026lt; b[0]) { std::cout \u0026lt;\u0026lt; b[0] - 1 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else if (a \u0026gt; b[m - 1]) { std::cout \u0026lt;\u0026lt; n - b[m - 1] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else { int lb = b[std::upper_bound(b.begin(), b.end(), a) - b.begin() - 1]; int ub = b[std::upper_bound(b.begin(), b.end(), a) - b.begin()]; std::cout \u0026lt;\u0026lt; (ub - lb) / 2 \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } } ","date":"2024 September 15","externalUrl":null,"permalink":"/posts/contest/codeforces/codeforcesround972_div2/b/","section":"Posts","summary":"1.","title":"Codeforces Round 972 (Div. 2) - B","type":"posts"},{"content":"","date":"2024 September 15","externalUrl":null,"permalink":"/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/","section":"Tags","summary":"","title":"思维题","type":"tags"},{"content":"\r1. 题目 #\rEnglish\rNarek has to spend 2 hours with some 2-year-old kids at the kindergarten. He wants to teach them competitive programming, and their first lesson is about palindromes.\nNarek found out that the kids only know the vowels of the English alphabet (the letters \\(\\mathtt{a}\\), \\(\\mathtt{e}\\), \\(\\mathtt{i}\\), \\(\\mathtt{o}\\), and \\(\\mathtt{u}\\)), so Narek needs to make a string that consists of vowels only. After making the string, he\u0026rsquo;ll ask the kids to count the number of subsequences that are palindromes. Narek wants to keep it simple, so he\u0026rsquo;s looking for a string such that the amount of palindrome subsequences is minimal.\nHelp Narek find a string of length \\(n\\), consisting of lowercase English vowels only (letters \\(\\mathtt{a}\\), \\(\\mathtt{e}\\), \\(\\mathtt{i}\\), \\(\\mathtt{o}\\), and \\(\\mathtt{u}\\)), which minimizes the amount of palindrome\\(^{\\dagger}\\) subsequences\\(^{\\ddagger}\\) in it.\n\\(^{\\dagger}\\) A string is called a palindrome if it reads the same from left to right and from right to left.\n\\(^{\\ddagger}\\) String \\(t\\) is a subsequence of string \\(s\\) if \\(t\\) can be obtained from \\(s\\) by removing several (possibly, zero or all) characters from \\(s\\) and concatenating the remaining ones, without changing their order. For example, \\(\\mathtt{odocs}\\) is a subsequence of \\(\\texttt{c}{\\color{red}{\\texttt{od}}}\\texttt{ef}{\\color{red}{\\texttt{o}}}\\texttt{r}{\\color{red}{\\texttt{c}}}\\texttt{e}{\\color{red}{\\texttt{s}}}\\).\nInput\nThe first line of the input contains a single integer \\(t\\) (\\(1 \\le t \\le 100\\)) — the number of test cases.\nSubsequently, the description of each test case follows. The only line of each test case contains a single integer \\(n\\) (\\(1 \\le n \\le 100\\)) — the size of the string.\nOutput\nFor each test case, output any string of length nn that satisfies the above conditions.\n简体中文（大意）\r利用 \\(\\mathtt{a}\\), \\(\\mathtt{e}\\), \\(\\mathtt{i}\\), \\(\\mathtt{o}\\), \\(\\mathtt{u}\\) 构造长度为 \\(n\\) 的字符串，使得回文子串个数最少。\r2. 思路 #\r观察可以发现：\n当 \\(n \\leq 5\\) 时，所有的字符串的回文子串个数均最少。 当 \\(n \u0026gt; 5\\) 时，必定会出现重复的元音字母，而重复的元音字母均会与其中间的字母构成一个三字母的回文串，例如 \\({\\color{red}\\mathtt{a}}\\mathtt{b}{\\color{blue}\\mathtt{c}}\\mathtt{d}{\\color{red}\\mathtt{a}}\\)，其中 \\({\\color{red}\\mathtt{a}}{\\color{blue}\\mathtt{c}}{\\color{red}\\mathtt{a}}\\) 构成一个回文串。 因此只要将相同字母放在一起，减少第二种情况中相同字母之间字母的个数，就能减少回文子串的个数。\n3. 代码 #\rC\u0026#43;\u0026#43;\rvoid solve() { int n; std::cin \u0026gt;\u0026gt; n; char c[] = {\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;}; std::map\u0026lt;char, int\u0026gt; l; for (int i = 0; i \u0026lt; n; i++) { l[c[i % 5]] ++; } for (auto \u0026amp;[x, y] : l) { while (y--) { std::cout \u0026lt;\u0026lt; x; } } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","date":"2024 September 15","externalUrl":null,"permalink":"/posts/contest/codeforces/codeforcesround972_div2/a/","section":"Posts","summary":"1.","title":"Codeforces Round 972 (Div. 2) - A","type":"posts"},{"content":"","date":"2024 September 10","externalUrl":null,"permalink":"/categories/%E6%95%B0%E5%AD%A6/","section":"Categories","summary":"","title":"数学","type":"categories"},{"content":"","date":"2024 September 10","externalUrl":null,"permalink":"/categories/%E6%95%B0%E8%AE%BA/","section":"Categories","summary":"","title":"数论","type":"categories"},{"content":"\r裴蜀定理是一个关于最大公约数的定理。\n定义了有关两个数的线性组合和最大公约数之间的关系，其内容为：\n\\(\\forall x,y\\)，满足 \\(\\gcd(x,y)\\mid ax+by\\)，且 \\(\\exists a,b\\)，满足 \\(ax+by = \\gcd(x,y)\\)\n同时裴蜀定理可以推广到 \\(n\\) 个数，即有：\n\\(\\forall x_1,x_2,\\dots,x_n\\)，满足 \\(\\gcd(x_1,x_2,\\dots,x_n)\\mid a_1x_1+a_2x_2+\\cdots+a_nx_n\\)，且 \\(\\exists a_1,a_2,\\dots,a_n\\)，满足 \\(a_1x_1+a_2x_2+\\cdots+a_nx_n = \\gcd(x_1,x_2,\\dots,x_n)\\)\n","date":"2024 September 10","externalUrl":null,"permalink":"/posts/math/numbertheory/bezout/","section":"Posts","summary":"裴蜀定理是一个关于最大公约数的定理。","title":"裴蜀定理","type":"posts"},{"content":"\r1. 题目 #\rEnglish\rSudoku is a logic-based, combinatorial number-placement puzzle. In classic Sudoku, the objective is to fill a \\(9 \\times 9\\) grid with digits so that each column, each row, and each of the nine \\(3 \\times 3\\) subgrids that compose the grid contains all of the digits from \\(1\\) to \\(9\\). The puzzle setter provides a partially completed grid, which for a well-posed puzzle has a single solution.\nMinesweeper is a logic puzzle video game. The game features a grid of clickable tiles, with hidden mines scattered throughout the board. The objective is to clear the board without detonating any mines, with help from clues about the number of neighboring mines in each field.\nYou are given a solved classic Sudoku. You are asked to replace some numbers with mines so that the remaining numbers equal the number of neighboring mines. You can\u0026rsquo;t replace all the numbers with mines.\nInput\nThe input contains \\(9\\) lines. Each line contains \\(9\\) characters. Each character is a number between \\(1\\) and \\(9\\).\nThe input describes the solved classic Sudoku.\nOutput\nOutput \\(9\\) lines, denoting the answer. Each line contains \\(9\\) characters. Each character is either a number between \\(1\\) and \\(9\\) or*(which represents a mine).\n简体中文（大意）\r将矩阵中一些数换为*，使得剩下的数分别等于周围*个数。\r2. 思路 #\r由于数独每一行每一列的数字都在 \\(0\\) 到 \\(9\\)，只要在中间找到一个 \\(8\\)，其他数字全部变为*就满足条件。\n3. 代码 #\rC\u0026#43;\u0026#43;\rvoid solve() { int n = 9; std::string s[n]; for (int i = 0; i \u0026lt; n; i++) { std::cin \u0026gt;\u0026gt; s[i]; } int x, y; for (int i = 1; i \u0026lt; n - 1; i++) { for (int j = 1; j \u0026lt; n - 1; j++) { if (s[i][j] == \u0026#39;8\u0026#39;) { x = i, y = j; } } } for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (i == x \u0026amp;\u0026amp; j == y) { std::cout \u0026lt;\u0026lt; \u0026#39;8\u0026#39;; } else { std::cout \u0026lt;\u0026lt; \u0026#39;*\u0026#39;; } } std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } 4. 总结 #\r签到题\n","date":"2024 September 9","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/3/l/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营3】L","type":"posts"},{"content":"","date":"2024 September 9","externalUrl":null,"permalink":"/categories/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5/","section":"Categories","summary":"","title":"2024牛客暑期多校训练营","type":"categories"},{"content":"","date":"2024 September 9","externalUrl":null,"permalink":"/categories/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A53/","section":"Categories","summary":"","title":"2024牛客暑期多校训练营3","type":"categories"},{"content":"","date":"2024 September 9","externalUrl":null,"permalink":"/series/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A53/","section":"Series","summary":"","title":"2024牛客暑期多校训练营3","type":"series"},{"content":"","date":"2024 September 9","externalUrl":null,"permalink":"/tags/%E7%AD%BE%E5%88%B0%E9%A2%98/","section":"Tags","summary":"","title":"签到题","type":"tags"},{"content":"\r1. 题目 #\rEnglish\rAfter five years, the most high-profile event in motor racing, Formula \\(1\\), returns to China. The Chinese Grand Prix was recently held at the Shanghai International Circuit. Formula \\(1\\) cars can reach speeds of up to \\(350\\) km/h. To ensure the safety of the drivers, the cars must pass rigorous crash tests.\nWe consider the following simplified version of a crash test. Initially, a car is positioned with its front facing a wall, at a distance of \\(D\\) meters from the wall. This crash test provides nnn types of boosters, where the \\(i\\)-th type of booster has a thrust performance of \\(h_i\\)​, and there are ample quantities of each type of booster. Suppose the current distance between the car\u0026rsquo;s front and the wall is \\(d\\), and we use a booster with a thrust performance of \\(h\\). When \\(d \\ge h\\), the car will move forward \\(h\\) meters and then stop. Otherwise, the car will move forward \\(d\\) meters, crash into the wall, and rebound \\(h-d\\) meters, after which it stops, still facing the wall.\nNow, you want to know, through any number of operations (including no operation), what the minimum distance between the car\u0026rsquo;s front and the wall can be?\nInput\nThe first line of input contains two positive integers \\(n\\) and \\(D\\) (\\(1 \\le n \\le 100, 1 \\le D \\le 10^{18}\\)), denoting the number of boosters and the distance between the Formula \\(1\\) car and the wall, respectively.\nThe second line of inputcontains \\(n\\) positive integers \\(h_1, h_2, \\ldots, h_n\\) (\\(1 \\le h_i \\le 10^{18}\\)), denoting the thrust performance of each booster.\nOutput\nOutput an integer in a line, denoting the minimum possible distance between the car\u0026rsquo;s front and the wall.\n简体中文（大意）\r一辆车距离墙壁 \\(D\\) ，有 \\(n\\) 种助推器，每种助推器让车前进 \\(h_i\\)，若剩余距离不足 \\(h_i\\)，则反弹 \\(h_i - D\\) 。求与墙壁之间的最小距离。\r2. 思路 #\r我们发现其实最终到墙壁的距离可以表示为 \\(|a_1h_1+a_2h_2+\\cdots+a_nh_n - D|\\)，对于 \\(a_1h_1+a_2h_2+\\cdots+a_nh_n\\) 可以联想到著名的裴蜀定理。\n裴蜀定理\r2024 September 10\u0026middot;23 字\u0026middot;1 分钟\r数学\r数论\r裴蜀定理是一个关于最大公约数的定理。\r由裴蜀定理我们就很容易知道所有推进器最终可以看作推进 \\(\\gcd(h_1,h_2,\\dots,h_n)\\) 的距离，最终的答案只能在 \\(D \\mod \\gcd(h_1,h_2,\\dots,h_n)\\) 和 \\(\\gcd(h_1,h_2,\\dots,h_n) - D \\mod \\gcd(h_1,h_2,\\dots,h_n)\\) 中选择。\n3. 代码 #\rC\u0026#43;\u0026#43;\rvoid solve() { int n; i64 D; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; D; i64 ans = 0; for (int i = 0; i \u0026lt; n; i++) { i64 h; std::cin \u0026gt;\u0026gt; h; ans = std::__gcd(ans, h); } i64 res = D % ans; std::cout \u0026lt;\u0026lt; std::min(res, ans - res); } 4. 总结 #\r这个题主要考查了裴蜀定理的应用。不过在代码中有一个小的知识点：\n\\(\\gcd(x,0)=x\\)，因为 \\(0\\) 可以被任何数整除。 负数没有最大公因数，但是代码中有 gcd(x, -y) = gcd(x, y) ","date":"2024 September 9","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/3/b/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营3】B","type":"posts"},{"content":"","date":"2024 September 9","externalUrl":null,"permalink":"/tags/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/","section":"Tags","summary":"","title":"裴蜀定理","type":"tags"},{"content":"\r1. 题目 #\rEnglish\rA group of nnn walkers arrives at a riverbank at night. They want to cross the river using a boat, which is initially on their side. The boat can hold at most RRR walkers at a time and requires at least \\(L\\) \\((1 \\leq L \u0026lt; R)\\) walkers to operate.\nRowing the boat is a tiring task. Each time the boat is used to transport a group of walkers to the other side of the river, all walkers on the boat must have stamina greater than \\(0\\), and each walker\u0026rsquo;s stamina decreases by \\(1\\) after the trip. Initially, the \\(i\\)-th walker \\((1 \\leq i \\leq n)\\) has a stamina value of \\(h_i\\)​.\nYou need to determine if it is possible to transport all the walkers to the other side of the river using the boat.\nInput\nThe first line of input contains three integers \\(n, L, R\\) \\((1 \\le L \u0026lt; R \\le n \\le 5 \\times 10^5)\\), denoting the number of walkers, the minimum and the maximum number of walkers to use the boat at a time, respectively.\nThe second line of input contains nnn integers \\(h_1,h_2,\\dots,h_n\\) \\((1\\leq h_i\\leq 5\\times 10^5)\\), where \\(h_i\\) \\((1 \\leq i \\leq n)\\) denotes the stamina value of the \\(i\\)-th walker.\nOutput\nIf it is possible to transport all the walkers to the other side of the river using the boat, output \u0026ldquo;Yes\u0026rdquo; in the first line (without quotes). Otherwise, output \u0026ldquo;No\u0026rdquo; in the first line (without quotes). You can output each letter in any case (lowercase or uppercase). For example, the strings \u0026ldquo;yEs\u0026rdquo;, \u0026ldquo;yes\u0026rdquo;, \u0026ldquo;Yes\u0026rdquo;, and \u0026ldquo;YES\u0026rdquo; will all be considered as positive replies.\n简体中文（大意）\r\\(n\\) 个人过河，有一个能装 \\(R\\) 个人的船，需要 \\(L\\) 个人体力不为空才能出发，且每划一次船划船者的体力减一，确定是否所有人都能走到对岸。\r2. 思路 #\r观察每次去的时候尽量为 \\(R\\) 个人，回来的时候为 \\(L\\) 个人的运输方式最优，即每次运输过去 \\(R-L\\) 个人。由于最后一次是 \\(L\\) 个人过去，故总共需要的来回趟数为 \\(\\lceil\\frac{n-R}{R-D}\\rceil\\)。\n对于第 \\(i\\) 个人来说，假如作为划船的人，总共能执行的来回趟数为 \\(\\lfloor\\frac{h_i - 1}{2}\\rfloor\\)。我们可以贪心地认为，如果这个人能划船的来回趟数大于等于总共需要的来回趟数，那么这个人就可以一直作为划船的人。反之如果这个人能划船的来回趟数小于总共需要的来回趟数，那么就只利用他能做到的一部分就可以了。\n由于需要 \\(L\\) 个人才能发船，最后计算能全程划船的人数和加起来能全程划船的人数。\n3. 代码 #\rC\u0026#43;\u0026#43;\rvoid solve() { int n, L, R; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R; int num = std::ceil(double(n - R) / (R - L)); int sum = 0, p = 0; for (int i = 0; i \u0026lt; n; i++) { int h; std::cin \u0026gt;\u0026gt; h; h = (h - 1) / 2; if (h \u0026gt;= num) { sum ++; } else { p += h; while (p \u0026gt;= num) { p -= num; sum ++; } } } if (sum \u0026gt;= L) { std::cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34;; } } 4. 总结 #\r这个题考察思维，主要是要贪心地利用每一个人的划船机会。\n","date":"2024 September 9","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/3/a/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营3】A","type":"posts"},{"content":"","date":"2024 September 9","externalUrl":null,"permalink":"/tags/%E8%B4%AA%E5%BF%83/","section":"Tags","summary":"","title":"贪心","type":"tags"},{"content":"\r三元环计数是图论中一个比较重要的问题，用于求解无向图中三元环的个数。\n三元环指的是简单图 \\(G\\) 中的一个无序三元组 \\((u,v,w)\\)，满足存在三条边连接 \\(u,v,w\\) 三个点。\n三元环可以看作某种意义上的等价关系，即满足自反性、对称性和传递性，如果考虑传递性，则每个三元环的三条边均看作有向重边，在代码实现上如果三种传递性都要验证，时间复杂度会很高。\n因此我们可以考虑将三元环的无向图转换为有向图，这样只需要验证一种关系的传递性即可。我们假设：\n有向边从度数小的边指向度数大的边 度数相同，有向边从下标小的边指向下标大的边 很容易证明证明没有环的存在，因为如果存在环，必定会出现度数大的指向度数小的边的情况（环的首尾）。此时的图为一张有向无环图（DAG）。\n因此将无向图转换为有单向边的有向无环图，每次遍历 \\(u\\) 的相邻点 \\(v\\)，然后验证与 \\(v\\) 的相邻点 \\(w\\) 是否存在一条有向边即可。此时 \\(w\\) 也作为 \\(u\\) 的相邻点存在，遍历 \\(u\\) 的相邻点时判断一下就可以了。\n1. 代码 #\rC\u0026#43;\u0026#43;\rvoid solve() { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::vector\u0026lt;int\u0026gt; degree(n + 1), g[n + 1]; std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; op(m + 1); for (int i = 1; i \u0026lt;= m; i++) { int u, v; std::cin\u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; if (u \u0026gt; v) { std::swap(u, v); } op[i] = {u, v}; degree[u]++, degree[v]++; } for (int i = 1; i \u0026lt;= m; i++) { auto \u0026amp;[u, v] = op[i]; if (degree[u] \u0026gt; degree[v]) { std::swap(u, v); } g[u].push_back(v); } int num = 0; std::vector\u0026lt;int\u0026gt; vis(n + 1); for (int i = 1; i \u0026lt;= n; i++) { for (auto \u0026amp;j : g[i]) { vis[j] = 1; } for (auto \u0026amp;j : g[i]) { for (auto \u0026amp;k : g[j]) { if (vis[k]) { num++; } } } for (auto \u0026amp;j : g[i]) { vis[j] = 0; } } std::cout \u0026lt;\u0026lt; num; } 2. 时间复杂度 #\r由于将每条无向边都转换为了有向边，导致每个点的度数为不超过 \\(\\sqrt{m}\\)，因此遍历总的时间复杂度为 \\(O(m\\log m)\\)。\n","date":"2024 August 30","externalUrl":null,"permalink":"/posts/algorithm/graphtheory/triangle/","section":"Posts","summary":"三元环计数是图论中一个比较重要的问题，用于求解无向图中三元环的个数。","title":"三元环计数","type":"posts"},{"content":"","date":"2024 August 30","externalUrl":null,"permalink":"/categories/%E5%9B%BE%E8%AE%BA/","section":"Categories","summary":"","title":"图论","type":"categories"},{"content":"","date":"2024 August 30","externalUrl":null,"permalink":"/categories/%E7%AE%97%E6%B3%95/","section":"Categories","summary":"","title":"算法","type":"categories"},{"content":"\r并查集（DSU）是一种负责合并、查询的集合，用于判断元素之间的所属关系。\n并查集的核心思想就是对每个元素都建立一个标记，来表示所属集合的一个代表元素。\n假如我们用f[i]来表示第 \\(i\\) 个元素的代表元素（或者是 Father ）。初始化可以将所有元素的代表元素设为自己，即：f[i] = i。\n1. 查询 #\r1. 1 一般查询 #\r查询某个元素属于哪一个集合，即查询这个元素的代表元素是哪一个。\nint find(int x) { return f[x] == x ? x : find(f[x]); } 由于代表元素的代表元素即为它本身，故很容易得到上述的代码。\n1. 2 路径压缩查询 #\r并查集的本质是一种树，通过这种方法得到的树的深度会很大，所以我们可以对树进行路径压缩，使得集合中每个元素的代表元素都是整个集合的代表元素。\nint find(int x) { return f[x] == x ? x : f[x] = find(f[x]); } 2. 合并 #\r2. 1 一般合并 #\r将两个集合合并，其实就是将两个集合的代表元素更新一下，使得其中一个集合的代表元素是另一个集合代表元素的代表元素。\nvoid merge(int x, int y) { f[find(x)] = find(y); } 2. 2 启发式合并（按秩合并） #\r一般合并的问题在于可能会影响未来操作的复杂度，比如深度加深等等问题。所以最好的合并方式就是将深度较小（或元素少）的集合合并到另一个集合去。\n因此我们需要一个size[i]数组来记录每个元素所在集合的元素个数。\nvoid merge(int x, int y) { int fx = find(x), fy = find(y); if (size[fx] \u0026gt; size[fy]) { std::swap(fx, fy); } f[fx] = fy; size[fy] += size[fx]; } 3. 结构体 #\r将上面的函数可以统一为一个结构体的形式便于并查集的生成与操作。\nstruct DSU { std::vector\u0026lt;int\u0026gt; f, sz; DSU(int n) : f(n), sz(n, 1) { std::iota(f.begin(), f.end(), 0); } int find(int x) { return f[x] == x ? x : f[x] = find(f[x]); } bool merge(int x, int y) { int fx = find(x), fy = find(y); if (fx == fy) { return false; } if (sz[fx] \u0026gt; sz[fy]) { std::swap(fx, fy); } f[fx] = fy; sz[fy] += sz[fx]; return true; } bool same(int x, int y) { return find(x) == find(y); } }; 4. 时间复杂度 #\r并查集的时间复杂度取决于实现方式：\n无优化：\\(O(n)\\)\n仅路径压缩/按秩合并：\\(O(log(n))\\)\n路径压缩 + 按秩合并：\\(O(\\alpha(n))\\)，其中 \\(\\alpha(n)\\) 为 Ackermann 函数的反函数\nAckermann 函数\rAckermann 函数 \\(A(n,m)\\)定义为：\n\\(A(n,m)=\\begin{cases}m+1\u0026amp;\\texttt{if}\\ n=m\\\\A(n-1, 1)\u0026amp;\\texttt{if}\\ n\u0026gt;0\\ \\texttt{and}\\ m=0\\\\A(n-1,A(n,m-1))\u0026amp;\\texttt{otherwise}\\end{cases}\\)\n","date":"2024 August 26","externalUrl":null,"permalink":"/posts/data_structure/dsu/","section":"Posts","summary":"并查集（DSU）是一种负责合并、查询的集合，用于判断元素之间的所属关系。","title":"并查集","type":"posts"},{"content":"","date":"2024 August 26","externalUrl":null,"permalink":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"数据结构","type":"categories"},{"content":"\r最小生成树（MST）是连通加权无向图中权重最小的生成树。\n求最小生成树的算法主要有两个：Kruskal 和 Prim\n1. Kruskal #\rKruskal 主要用于稀疏图的最小生成树的求解。\n算法的核心是选边：每次贪心地选择当前边集中选择权重最小的、且不构成回路的边。\n算法的实现是并查集，通过维护一个最小权重的边的并查集来实现最小生成树。\n并查集可以参考：\n并查集\r2024 August 26\u0026middot;213 字\u0026middot;1 分钟\r数据结构\r并查集（DSU）是一种负责合并、查询的集合，用于判断元素之间的所属关系。\rKruskal 动图解释。来源：OI-Wiki\r1. 1 代码 #\rC\u0026#43;\u0026#43;\rstruct DSU { std::vector\u0026lt;int\u0026gt; f, sz; DSU(int n) : f(n), sz(n, 1) { std::iota(f.begin(), f.end(), 0); } int find(int x) { return f[x] == x ? f[x] : f[x] = find(f[x]); } bool merge(int x, int y) { int fx = find(x), fy = find(y); if (fx == fy) { return false; } if (sz[fx] \u0026gt; sz[fy]) { std::swap(fx, fy); } f[fx] = fy; sz[fy] += sz[fx]; return true; } bool same(int x, int y) { return find(x) == find(y); } }; void solve() { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::vector\u0026lt;std::array\u0026lt;int, 3\u0026gt;\u0026gt; l; DSU node(n + 1); for (int i = 0; i \u0026lt; m; i++) { int u, v, w; std::cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; l.push_back({w, u, v}); } std::sort(l.begin(), l.end()); int sum = 0, num = 1; for (auto [w, u, v] : l) { if (node.merge(u, v)) { sum += w; num ++; } if (num == n) { break; } } if (num == n) { std::cout \u0026lt;\u0026lt; sum; } else { std::cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34;; } } 可以看出，我们按照边权的大小对边进行排序，然后遍历边。判断一条边是否能加入到最小生成树中（即不成回路）的依据是边的两个顶点是否在同一个并查集里面。\n1. 2 时间复杂度 #\rKruskal 的时间复杂度为 \\(O(mlog(m))\\)，即遍历边以及维护并查集的时间复杂度。\n2. Prim #\rPrim 主要用于稠密图的最小生成树的求解。\n算法的核心是选点：随机选择一个点作为起点，每次贪心地选择当前点相邻边集中选择权重最小的、且不构成回路的边。\n算法的实现是DFS，即逐步选择每一个点。\nPrim 动图解释。来源：OI-Wiki\r1. 1 代码 #\rC\u0026#43;\u0026#43;\rstruct cmp { bool operator()(const std::pair\u0026lt;int, int\u0026gt; x, const std::pair\u0026lt;int, int\u0026gt; y) { return x.second \u0026gt; y.second; } }; void solve() { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; g[n + 1]; for (int i = 0; i \u0026lt; m; i++) { int x, y, z; std::cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; g[x].push_back({y, z}); g[y].push_back({x, z}); } std::priority_queue\u0026lt;std::pair\u0026lt;int, int\u0026gt;, std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt;, cmp\u0026gt; l; std::vector\u0026lt;int\u0026gt; dis(n + 1, 0x3f3f3f3f); std::vector\u0026lt;bool\u0026gt; vis(n + 1, false); dis[1] = 0, l.push({1, 0}); int sum = 0, num = 0; while (!l.empty()) { if (num == n) { break; } auto [u, d] = l.top(); l.pop(); if (!vis[u]) { vis[u] = true; num ++; sum += d; for (auto [v, w] : g[u]) { if (!vis[v] \u0026amp;\u0026amp; w \u0026lt; dis[v]) { dis[v] = w, l.push({v, w}); } } } } if (num == n) { std::cout \u0026lt;\u0026lt; sum; } else { std::cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34;; } } 我们使用堆优化的方式实现 Prim ，其实现方式类似于 Dijkstra 逐步更新周边点的距离从而找到路径最近的点。\n每次都将周围点到当前点的距离都更新一次，然后压入堆中进行选择。由于每次都会只选择堆顶元素加入到 MST 中，后续更新当前点的周围点距离的时候，可能某些点在之前已经更新过了，那么再次加入堆中更有可能出现到堆顶附近，而之前的那次更新自然不会出现到这次更新之上了。\n1. 2 时间复杂度 #\rPrim 的时间复杂度为 \\(O((n+m)log(n))\\)，即遍历边维护检查堆以及顶点检查的时间复杂度之和。\n​\n","date":"2024 August 23","externalUrl":null,"permalink":"/posts/algorithm/graphtheory/mst/","section":"Posts","summary":"最小生成树（MST）是连通加权无向图中权重最小的生成树。","title":"最小生成树","type":"posts"},{"content":"\r1. 题目 #\rEnglish\rThere are \\(2\\cdot n\\) cards arranged in a row, with each card numbered from \\(1\\) to \\(n\\) having exactly \\(2\\) copies.\nEach time, Red can choose a subarray of consecutive cards (at least \\(2\\) cards) to remove from the deck. The chosen subarray must satisfy that the first and last cards have the same number. The score for this operation is: the number of cards multiplied by the number on the first card.\nNow Red wants to know what is the maximum value of the final score?\nInput\nThe first line contains a positive integer \\(n(1\\leq n \\leq 3\\times 10^3)\\) — the number of card types.\nThe second line contains \\(2\\cdot n\\) positive integers \\(a_i(1\\leq a_i \\leq n)\\) — the number on each card from left to right.\nOutput\nA single positive integer — representing the maximum final score.\n简体中文（大意）\r一个序列包含 \\(1\\) ~ \\(n\\)，每个数出现两次。每次选择删掉首尾两个数相同的区间，得到的值为 区间元素个数 \\(\\times\\) 首/尾的数，并将所得到的值求和。求和的最大值。\r2. 思路 #\r这很显然是一个区间 DP 问题。很容易想到，区间和区间之间可能会出现包含关系，所以一个大的区间可以由所包含的小的区间转移得到。\n虽然区间之间可能会有包含关系，但是最后也有可能出现单个没有配对的数。因此我们在原题的基础上添加一个条件：在首尾添加两个 \\(0\\)。问题就变成了将所有数都删掉所能得到的最大值是多少，因为最后假如还剩下了无法配对的数，虽然不会产生贡献，但是可以归纳到 \\(0\\) 的区间里面。这样所有的数都能通过计算除去。\n假如一个大的区间包含了很多完整的小的区间，那么状态转移就可以变为：每个小的区间的最大值 + 单独出现的值产生的贡献。\n因此对于这个区间的状态转移方程为： $$ dp(i)=\\max\\begin{cases}\\ dp(i-1) + x\\\\ dp(l(a(i)) - l(x) - 1) + ans(a(i)) \\texttt{ if l(x) \u0026lt; l(a(i)) and r(a(i)) = i + l(x)}\\end{cases} $$ 其中当前区间的首尾元素为 \\(x\\)，考虑区间的前 \\(i\\) 个元素，对于当前这个数 \\(a(i)\\)，\\(l(i)\\) 为第一次出现的下标，\\(r(i)\\) 为最后一次出现的下标，有两种操作策略：\n选择 \\(a(i)\\) 和 \\(x\\) 的区间一起删掉，则贡献为 \\(dp(i-1)+x\\) 如果 \\(a(i)\\) 所代表的完整区间在 \\(x\\) 区间内，则优先考虑这个代表区间，此时的答案为除了 \\(a(i)\\) 区间的最大值 \\(dp(l(i)-1)\\) 加上 \\(a(i)\\) 区间的最大值 \\(ans(a(i))\\)。最后让 \\(ans(x)\\) 等于 \\(dp(r(x))\\) 即可。 求一下最大值就可以了。很显然最终的答案为 \\(ans(0)\\)。\n3. 代码 #\rC\u0026#43;\u0026#43;\rvoid solve() { int n, m; std::cin \u0026gt;\u0026gt; n; m = (n \u0026lt;\u0026lt; 1); std::vector\u0026lt;int\u0026gt; a(m + 2); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; p(n + 1); a[0] = 0, a[m + 1] = 0; p[0] = {0, m + 1}; for (int i = 1; i \u0026lt;= m; i++) { std::cin \u0026gt;\u0026gt; a[i]; p[a[i]].push_back(i); } std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; g(n + 1); for (int i = 1; i \u0026lt;= n; i++) { int l = p[i][0], r = p[i][1]; g[i] = {r - l + 1, i}; } g[0] = {m + 2, 0}; std::sort(g.begin(), g.end()); std::vector\u0026lt;int\u0026gt; ans(n + 1); for (int i = 0; i \u0026lt;= n; i++) { auto \u0026amp;[len, now] = g[i]; int l = p[now][0], r = p[now][1]; std::vector\u0026lt;int\u0026gt; dp(len); dp[0] = now; for (int j = 1; j \u0026lt; len; j++) { dp[j] = dp[j - 1] + now; int lx = p[a[j + l]][0], rx = p[a[j + l]][1]; if (lx \u0026gt; l \u0026amp;\u0026amp; rx == j + l) { dp[j] = std::max(dp[j], dp[lx - l - 1] + ans[a[j + l]]); } } ans[now] = dp[len - 1]; } std::cout \u0026lt;\u0026lt; ans[0]; } 4. 总结 #\r这个是一个从区间 DP 变化而来的题目，就是将子区间的和转移为父亲区间的和来达到动态规划的目的。\n","date":"2024 July 31","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/2/i/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营2】I","type":"posts"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/categories/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A52/","section":"Categories","summary":"","title":"2024牛客暑期多校训练营2","type":"categories"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/series/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A52/","section":"Series","summary":"","title":"2024牛客暑期多校训练营2","type":"series"},{"content":"\r1. 题目 #\rEnglish\rRed stands at the coordinate \\((0,0)\\) of the Cartesian coordinate system. She has a string of instructions: up, down, left, right (where right increases the x-coordinate by \\(1\\), and up increases the y-coordinate by \\(1\\)).\nNow Red wants to select a continuous substring of instructions and execute them. Red hopes that the final execution of the instructions can pass through the coordinate \\((x,y)\\). She wants to know how many selection options there are.\nInput\nThe first line contains three integers \\(n\\), \\(x\\), and \\(y\\) (\\(1 \\leq n \\leq 2 \\times 10^5, -10^5 \\leq x, y \\leq 10^5)\\), — the length of the instruction string and the coordinates Red hopes to pass through.\nThe second line contains a string of length nnn, consisting of the characters \\(W\\), \\(S\\), \\(A\\), and \\(D\\). — the four directions: up, down, left, and right, respectively.\nOutput\nOutput one integer representing the number of selection options for the continuous substring.\n简体中文（大意）\r给定字符串，表示一串移动指令，假如起点为 \\((0,0)\\)，求能到达 \\((x,y)\\) 的子串的个数。\r2. 思路 #\r由于上下左右移动对应的是坐标的变化，故可以将字符串表示为对应的坐标变化，问题便转化成为：寻找坐标变化为 \\((x,y)\\) 的区间的个数。\n由于只需要路径穿过了目标点就可以，故对于所有终点在 \\((x,y)\\) 的字符串以及以该字符串为前缀的后续所有字符串都满足条件。\n所以我们可以使用前缀和保存区间的信息，然后稍作差分计算符合条件的区间的个数。\n3. 代码 #\rC\u0026#43;\u0026#43;\rvoid solve() { int n, x, y; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; std::string s; std::cin \u0026gt;\u0026gt; s; if (x == 0 \u0026amp;\u0026amp; y == 0) { std::cout \u0026lt;\u0026lt; (n * (n + 1) \u0026gt;\u0026gt; 1); return; } std::vector\u0026lt;std::pair\u0026lt;i64, i64\u0026gt;\u0026gt; l(n + 1, {0, 0}); for (int i = 0; i \u0026lt; n; i++) { auto [x0, y0] = l[i]; if (s[i] == \u0026#39;A\u0026#39;) { x0--; } else if (s[i] == \u0026#39;D\u0026#39;) { x0++; } else if (s[i] == \u0026#39;W\u0026#39;) { y0++; } else { y0--; } l[i + 1] = {x0, y0}; } i64 num = 0; std::map\u0026lt;std::pair\u0026lt;i64, i64\u0026gt;, std::vector\u0026lt;int\u0026gt;\u0026gt; ref; for (int i = n; i \u0026gt;= 0; i--) { auto [x0, y0] = l[i]; if (!ref[{x + x0, y + y0}].empty()) { int min = *ref[{x + x0, y + y0}].begin(); num += n - min + 1; } ref[l[i]].push_back(i); std::sort(ref[l[i]].begin(), ref[l[i]].end()); } std::cout \u0026lt;\u0026lt; num; } 4. 总结 #\r从代码中发现，可以使用 map 对遍历进行优化。由于正向遍历要对每一个前缀和找到第一个符合条件的值，时间复杂度为 \\(O(n^2)\\) ，而逆序遍历的时候对所有已经遍历过的前缀和进行查询，用 map 进行了保存，时间复杂度降到了 \\(O(n\\cdot logn)\\)。\n总之使用前缀和可以很简单的处理可以差分的问题。\n","date":"2024 July 31","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/2/h/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营2】H","type":"posts"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/","section":"Tags","summary":"","title":"前缀和","type":"tags"},{"content":"\r1. 题目 #\rEnglish\rBen_H has a positive integer \\(x\\). He wants you to find another positive integer \\(y\\), which is strictly less than \\(x\\), so that the equation \\(gcd(x, y) = x \\oplus y\\) holds. Can you help him?\nwhere \\(\\oplus\\) is bitwise XOR operation.\nInput\nThe first line contains a single integer \\(t (1 \\leq t \\leq 10^4)\\) — the number of test cases.\nThe only line of each test case contains a single integer \\(x (1\\leq x \\leq 10^{18})\\).\nOutput\nFor each testcase, output a single positive integer \\(y\\), if you find a feasible answer, or \\(-1\\) otherwise.\n简体中文（大意）\r给定 \\(x\\)，构造 \\(y\\) 使满足 \\(gcd(x,y) = x\\oplus y\\)。\r2. 思路 #\r签到题，由于问题只需要构造出一个数满足条件即可，故不需要遍历整个区间。\n由最大公约数的性质可知，\\(gcd(x,y)\\) 的结果通常与 \\(x\\) 成倍数关系，而等式右侧又为二进制的表示形式，故考虑是否存在 \\(2\\) 的倍数。\n又二进制的表示方法知道，设 \\(x\\) 的二进制形式为 \\(10110100\\)，则可以表示为： $$ 2^7 + 2^5 + 2^4 + 2^2 = (2^5 + 2^3 + 2^2 + 1)\\times 2^2 $$ 故 \\(x\\) 可以表示为最后一个为 \\(1\\) 位所表示的二进制数的倍数，可以通过补码性质得到。\n要保证与右侧的异或值相同，只要保证 \\(y\\) 的前半部分与 \\(x\\) 相同，从 \\(x\\) 的最后一个 \\(1\\) 位往后均为 \\(0\\) 即可： $$ \\begin{array}{cc} x\u0026amp;10110100\\\\ y\u0026amp;10110\\color{red}{\\underline{0}00}\\\\ \\hline \\oplus\\rightarrow\u0026amp;00000\\color{blue}{100} \\end{array} $$\n此外要特别注意的是，如果 \\(x\\) 为 \\(2^k\\)，那么按照这种方法找到的数为 \\(0\\)，不满足条件。\n3. 代码 #\rC\u0026#43;\u0026#43;\rvoid solve() { i64 x; std::cin \u0026gt;\u0026gt; x; i64 lowbit = (x \u0026amp; -x); if (lowbit == x) { std::cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; x - lowbit \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } 4. 总结 #\r签到题，但是本题注意数据范围 \\((1\\leq x \\leq 10^{18})\\) 很大，不要通过遍历去搜索满足条件的数，尽量从二进制的结构上去构造。\n掌握获取最后一个为 \\(1\\) 位的方法，也经常运用于树状数组中：lowbit = (x \u0026amp; -x)。\n","date":"2024 July 31","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/2/e/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营2】E","type":"posts"},{"content":"\r1. 题目 #\rEnglish\rRed is on a \\(2\\cdot n\\) grid, with some cells being red and others being white.\nRed can initially choose a red cell, and at each step, can choose a red cell above, below, to the left, or to the right. When Red leaves a cell, the cell immediately turns white.\nRed wants to know the maximum number of steps she can take.\nIf there are no initial red cells, please output \\(0\\).\nInput\nThe first line contains a positive integer \\(n(1\\leq n \\leq 10^6)\\).\nThe next two lines contain a \\(2\\cdot n\\) character matrix, consisting only of R and W characters. R represents a red cell, and W represents a white cell.\nOutput\nAn integer — the maximum number of steps Red can take.\n简体中文（大意）\r在 \\(2\\times n\\) 的格子中有 R 和 W，求从任意一个 R 出发能连续走到最多的 R 的个数。\r2. 思路 #\r这道题是一道比较经典的动态规划问题。假定从左往右寻找，当前位置假如为 R，则只有可能从左方或者另一条线的 R 所在的搜索路线上加 \\(1\\) 得到。因此我们能比较容易得到动态规划的转移方程： $$ \\begin{cases} dp(i,j,0)=\\max{(dp(i,j-1,0),dp(i,j-1,1))}\\\\ dp(i,j,1)=dp(1-i,j,0)+1 \\end{cases} $$ 其中 \\(dp(i,j,k)\\) 数组表示坐标为 \\((i,j)\\) 的 R 从 \\(k\\) 方向上来的 R 的个数，\\(k=0\\) 表示从左方来的个数，\\(k=1\\) 表示从另一条线上来的个数。对于同一个元素的 \\(k\\) 可以通过另一条线加 \\(1\\) 得到。\n然后对所有的 \\(dp\\) 数组遍历寻找最大值即可。\n3. 代码 #\rC\u0026#43;\u0026#43;\rvoid solve() { int n; std::cin \u0026gt;\u0026gt; n; std::string s[2]; for (int i = 0; i \u0026lt; 2; i++) { std::cin \u0026gt;\u0026gt; s[i]; } std::vector\u0026lt;std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; dp(2, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;(n, std::vector\u0026lt;int\u0026gt;(2, 0))); for (int j = 0; j \u0026lt; n; j++) { for (int i = 0; i \u0026lt; 2; i++) { if (s[i][j] == \u0026#39;R\u0026#39;) { dp[i][j][0] = 1; } } } for (int j = 0; j \u0026lt; n; j++) { for (int i = 0; i \u0026lt; 2; i++) { if (s[i][j] == \u0026#39;R\u0026#39; \u0026amp;\u0026amp; j \u0026gt; 0) { dp[i][j][0] += std::max(dp[i][j - 1][0], dp[i][j - 1][1]); } } for (int i = 0; i \u0026lt; 2; i++) { if (s[i][j] == \u0026#39;R\u0026#39;) { dp[i][j][1] = dp[i ^ 1][j][0] + 1; } } } int ans = 0; for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; n; j++) { for (int k = 0; k \u0026lt; 2; k++) { ans = std::max(ans, dp[i][j][k]); } } } std::cout \u0026lt;\u0026lt; std::max(0 ,ans - 1) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 4. 总结 #\r经典的动态规划，懂点掌握如何设计动态转移方程。一般可以将已有的条件设置为可以推导的部分（比如下标），而要求的值设置为 dp 数组的值进行递推。\n","date":"2024 July 31","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/2/c/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营2】C","type":"posts"},{"content":"\r1. 题目 #\rEnglish\rSajin has recently delved into the study of minimum spanning trees and now he has mastered the algorithm of MST.\nHe is eager to assess your grasp of minimum spanning tree concepts through a series of queries. You are confronted with an weighted undirected graph that encompasses nnn vertices and mmm edges without any self-loops.\nSajin presents \\(q\\) inquiries. For each, a vertex set \\(S\\) is given. Your objective is to determine the induced subgraph of \\(S\\) and find the weight of its minimum spanning tree.\nA minimum spanning tree (MST) is a subset of the edges of a connected, edge-weighted graph that connects all the vertices together without any cycles and with the minimum possible total edge weight.\nIn the mathematical field of graph theory, an induced subgraph of a graph is another graph, formed from a subset of the vertices of the graph and all of the edges, from the original graph, connecting pairs of vertices in that subset.\nIf the induced subgraph of \\(S\\) is disconnected, output \\(-1\\).\nInput\nThe first line contains \\(3\\) integers \\(n\\), \\(m\\), \\(q\\) (\\(2 \\le n \\le 10^5,1 \\le m, q \\le 10^5\\)), — the number of points, the number of edges, and the number of queries.\nThen mmm lines follow, each line contains three integers \\(u_i\\), \\(v_i\\), \\(w_i\\)(\\(1 \\le u_i, v_i \\le n\\), \\(u_i \\ne v_i\\), \\(1 \\le w_i \\le 10^9\\)), — the two endpoints of the iii-th edge and the edge weight.\nNext \\(q\\) lines, each line first contains an integer \\(k_i\\)(\\(1 \\le k_i \\le n\\)) — the size of the vertex set \\(S\\) for the \\(i\\)-th query.\nThen followed by \\(k_i\\) distinct integers \\(s_{i,j}\\)(\\(1 \\le s_{i,j} \\le n\\)) — the numbers of the vertex set \\(S\\) for the \\(i\\)-th query.\nIt is guaranteed that the sum of \\(k_i\\) over all queries does not exceed \\(10^5\\).\nOutput\nFor each query, output one integer representing the answer.\n简体中文（大意）\r给你一张图，求导出子图的最小生成树。\r2. 思路 #\r观察到点和边的数据范围，发现非常相近，可以理解为整体上这个图为一张稀疏图（从邻接矩阵看比较直观）。由于本题求的是导出子图的最小生成树，对于稀疏图在局部上也可能为一张稠密图。\n对于最小生成树常见的算法有 Kruskal 和 Prim，Kruskal 常用于稀疏图，Prim 常见于稀疏图。具体可以参考下面这篇文章：\n最小生成树\r2024 August 23\u0026middot;396 字\u0026middot;2 分钟\r算法\r图论\r最小生成树（MST）是连通加权无向图中权重最小的生成树。\r由于本题对于 Prim 时间复杂度的要求非常高，故使用 Kruskal 搭配边存储优化求解。\nKruskal 的算法就是从小到大遍历所有边，假如给定点集 \\(S\\)，那么在遍历两点相邻的边时，每条边会存两次。因此我们需要降低存的重复边数来减少后续遍历的次数，根据三元环计数的原理，我们可以存为单向边，每个点存的边数会降为 \\(\\sqrt{m}\\)。\n三元环计数\r2024 August 30\u0026middot;179 字\u0026middot;1 分钟\r算法\r图论\r三元环计数是图论中一个比较重要的问题，用于求解无向图中三元环的个数。\r由于有菊花图出现的可能，如果单向边的起点从每个菊花图的中心开始，那么中心所连的点可能不在点集 \\(S\\) 中，此时遍历的点数会比较多。但如果从花瓣开始，则会减少这种情况的出现。因此我们需要记录下每个点的度数，将从度数小的点指向度数大的边存起来，度数相同则存从下标小到下标大的边。\n3. 代码 #\rC\u0026#43;\u0026#43;\rstruct DSU { std::vector\u0026lt;int\u0026gt; f, sz; DSU(int n) : f(n), sz(n, 1) { std::iota(f.begin(), f.end(), 0); } int find(int x) { return f[x] == x ? x : f[x] = find(f[x]); } bool merge(int x, int y) { int fx = find(x), fy = find(y); if (fx == fy) { return false; } if (sz[fx] \u0026gt; sz[fy]) { std::swap(fx, fy); } f[fx] = fy; sz[fy] += sz[fx]; return true; } bool same(int x, int y) { return find(x) == find(y); } }; void kruskal(int k, std::vector\u0026lt;std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; \u0026amp;p, std::vector\u0026lt;bool\u0026gt; \u0026amp;vis, std::vector\u0026lt;int\u0026gt; \u0026amp;s, DSU \u0026amp;node) { std::vector\u0026lt;std::array\u0026lt;int, 3\u0026gt;\u0026gt; l; for (auto \u0026amp;u : s) { for (auto \u0026amp;[v, w] : p[u]) { if (vis[v]) { l.push_back({w, u, v}); } } } std::sort(l.begin(), l.end()); i64 sum = 0, num = 1; for (auto \u0026amp;[w, u, v] : l) { if (num == k) { break; } if (node.merge(u, v)) { num ++; sum += w; } } if (num == k) { std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; } } void solve() { int n, m, q; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; DSU node(n + 1); std::vector\u0026lt;int\u0026gt; degree(n + 1); std::vector\u0026lt;std::array\u0026lt;int, 3\u0026gt;\u0026gt; op(m + 1); for (int i = 1; i \u0026lt;= m; i++) { int u, v, w; std::cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; if (u \u0026gt; v) { std::swap(u, v); } op[i] = {u, v, w}; degree[u]++; degree[v]++; } std::vector\u0026lt;std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; p(n + 1); for (int i = 1; i \u0026lt;= m; i++) { auto \u0026amp;[u, v, w] = op[i]; if (degree[u] \u0026gt; degree[v]) { std::swap(u, v); } p[u].emplace_back(v, w); } std::vector\u0026lt;bool\u0026gt; vis(n + 1); while (q--) { int k; std::cin \u0026gt;\u0026gt; k; std::vector\u0026lt;int\u0026gt; s(k); for (int i = 0; i \u0026lt; k; i++) { std::cin \u0026gt;\u0026gt; s[i]; vis[s[i]] = true; node.f[s[i]] = s[i]; node.sz[s[i]] = 1; } kruskal(k, p, vis, s, node); for (auto \u0026amp;i : s) { vis[i] = false; } } } 4. 总结 #\r这道题其实主体还是考察最小生成树的算法，但是需要考虑存边时候效率问题。\n值得注意的是：\n稀疏图使用 Kruskal，稠密图使用 Prim 三元环原理可以帮助降低访问边的次数 函数传参的时候一定要带上引用\u0026amp;，特别是在传递的数组或vector特别大时，如果采用形式传参，会增加复制的时间复杂度。要注意对于原始数据的修改的问题。 ","date":"2024 July 31","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/2/b/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营2】B","type":"posts"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/tags/%E4%B8%89%E5%85%83%E7%8E%AF%E8%AE%A1%E6%95%B0/","section":"Tags","summary":"","title":"三元环计数","type":"tags"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","section":"Tags","summary":"","title":"最小生成树","type":"tags"},{"content":"\r第二类斯特林数是组合数学上常见的一种概念，用于解决集合拆分的问题。\n【问题1】将 n 个元素拆分为 m 个非空集合，有多少种方案？\n【问题2】将 n 个苹果分给 m 个人，每人至少有一个苹果，有多少种方案？\n上述的两个问题都可以用第二类斯特林数解决。\n将 \\(n\\) 个元素拆分为 \\(k\\) (\\(1\\leq k\\leq m\\)) 个集合的方案数我们表示为 \\(S(n,k)\\)，则我们最终要求的方案数可以表示为 \\(S(n,m)\\)。我们可以得到递推式： $$ S(n,k)=S(n-1,k-1)+C_k^1\\cdot S(n-1,k) $$\n当插入一个元素的时候，有两种方案：\n将元素插入到新的集合，元素个数从 \\(n-1\\) 变为 \\(n\\)，集合个数从 \\(k-1\\) 变为 \\(k\\)。 在已有集合任选一个集合插入元素，元素个数从 \\(n-1\\) 变为 \\(n\\)，集合个数不变。 ","date":"2024 July 29","externalUrl":null,"permalink":"/posts/math/combinatorialmath/stirlingnumber/","section":"Posts","summary":"第二类斯特林数是组合数学上常见的一种概念，用于解决集合拆分的问题。","title":"第二类斯特林数","type":"posts"},{"content":"","date":"2024 July 29","externalUrl":null,"permalink":"/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/","section":"Categories","summary":"","title":"组合数学","type":"categories"},{"content":"\r1. 题目 #\rEnglish\rThe ICPC World Finals are coming. Due to some reasons, the 46th and 47th World Finals will be held simultaneously. For the teams qualified in both competitions, they should choose one to take part in.\nAs we know, lzr010506\u0026rsquo;s team is double-qualified and should make a choice. To make a wiser choice, lzr010506 looked up the qualified lists for two competitions and trained a magic model to predict the results for all participants among the two competitions. Moreover, a result contains the number of solved problems and the time penalty. The more solved problems, the better the result is, and if two teams solved the same number of problems, the result with the lower time penalty is better.\nNow, lzr010506 wants to know the best possible ranking if the actual results are all the same as predicted and that the competition choices of the double-qualified teams can be arbitrarily arranged by him.\nInput\nThe first line contains one integer \\(n\\) (\\(1 \\le n \\le 10^5\\)), denoting the number of teams qualified in the 46th World Finals.\nNext nnn lines each contain one string \\(S\\) (\\(1 \\le |S| \\le 10\\)) and two integers \\(p,t\\) (\\(1 \\le p,t \\le 10^9\\)), denoting the name, the predicted number of solved problems, and time penalty of one team in the 46th World Finals respectively.\nNext one line contains one integer \\(m\\) (\\(1 \\le m \\le 10^5\\)), denoting the number of teams qualified in the 47th World Finals.\nNext \\(m\\) lines each contain one string \\(S\\) (\\(1 \\le |S| \\le 10\\)) and two integers \\(p,t\\) (\\(1 \\le p,t \\le 10^9\\)), denoting the name, the predicted number of solved problems, and time penalty of one team in the 47th World Finals respectively.\nIt is guaranteed that:\nthe team names only contain digits and English letters; the team names in one competition are different from each other; no two teams have the same predicted number of solved problems and the time penalty simultaneously in one competition; the same names among two qualified name lists refer to the same team in real; lzr010506 appears in both two qualified name lists. Output\nOutput one line containing one integer, denoting the best possible ranking of lzr010506\u0026rsquo;s team.\n简体中文（大意）\r一些队伍同时参加了两场比赛，但只能选择一场比赛积分，求 lzr010506 能获得的最高名次。\r2. 思路 #\r签到题，只需要将两次比赛的队伍按照规则排个序，然后假设在两场比赛在lzr010506之前的队伍都参加另一场比赛（如果能参加另一场比赛的话），比较lzr010506在两场比赛中的名次取最小值。\n3. 代码 #\rC\u0026#43;\u0026#43;\rstruct part { std::string s; int pass, pen; }; bool cmp(part x, part y) { if (x.pass \u0026gt; y.pass) { return true; } else if (x.pass == y.pass) { return x.pen \u0026lt; y.pen; } else { return false; } } void solve() { int n; std::cin \u0026gt;\u0026gt; n; std::set\u0026lt;std::string\u0026gt; l46b, l47b; std::vector\u0026lt;part\u0026gt; l46(n); for (int i = 0; i \u0026lt; n; i++) { std::string s; int p, t; std::cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; p \u0026gt;\u0026gt; t; l46[i] = {s, p, t}; l46b.insert(s); } int m; std::cin \u0026gt;\u0026gt; m; std::vector\u0026lt;part\u0026gt; l47(m); for (int i = 0; i \u0026lt; m; i++) { std::string s; int p, t; std::cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; p \u0026gt;\u0026gt; t; l47[i] = {s, p, t}; l47b.insert(s); } std::sort(l46.begin(), l46.end(), cmp); std::sort(l47.begin(), l47.end(), cmp); std::set\u0026lt;std::string\u0026gt; l46f, l47f; for (int i = 0; i \u0026lt; n; i++) { if (l46[i].s == \u0026#34;lzr010506\u0026#34;) { break; } l46f.insert(l46[i].s); } for (int i = 0; i \u0026lt; m; i++) { if (l47[i].s == \u0026#34;lzr010506\u0026#34;) { break; } l47f.insert(l47[i].s); } int num1 = 1, num2 = 1; for (auto i : l46f) { if (l47b.find(i) == l47b.end()) { num1 ++; } } for (auto i : l47f) { if (l46b.find(i) == l46b.end()) { num2 ++; } } std::cout \u0026lt;\u0026lt; std::min(num1, num2); } 4. 总结 #\r签到题\n","date":"2024 July 27","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/1/h/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营1】H","type":"posts"},{"content":"","date":"2024 July 27","externalUrl":null,"permalink":"/categories/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A51/","section":"Categories","summary":"","title":"2024牛客暑期多校训练营1","type":"categories"},{"content":"","date":"2024 July 27","externalUrl":null,"permalink":"/series/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A51/","section":"Series","summary":"","title":"2024牛客暑期多校训练营1","type":"series"},{"content":"\r1. 题目 #\rEnglish\rGiven an array which is initially empty, you need to perform \\(q\\) operations:\nGiven two non-negative integers \\(t\\) and \\(v\\), take out the element from the end of the array for \\(t\\) times and then append \\(v\\) to the end of the array. It is guaranteed that \\(t\\) does not exceed the length of the array before this operation. After each operation, let \\(a_1,a_2,\\dots,a_n\\) be the current array, find the sum of \\(s_1,s_2,\\dots,s_n\\) , where \\(s_i =a_i +a_{i+1}+\\dots+a_n\\) is the sum of the suffix starting from position \\(i\\).\nSince the answers may be very large, output them modulo \\(1000000007\\).\nInput\nThe first line contains an integer \\(q\\) ( \\(1\\leq q\\leq 5\\times 10^5\\) ), denoting the number of operations.\nEach of the following \\(q\\) lines contains two non-negative integers \\(t\\) and \\(v\\) ( \\(0\\leq v\\leq 10^9\\) ), describing an operation, where \\(t\\) does not exceed the length of the array before this operation.\nOutput\nOutput \\(q\\) lines, each of which contains an integer, denoting the answer.\n简体中文（大意）\r\\(q\\) 次询问，每次从序列末尾删除 \\(t\\) 个数，并添加一个数 \\(v\\)，求每次询问后的后缀和的和。\r2. 思路 #\r观察到元素在后缀和中拥有不同的权重，假如 \\(a_1,a_2,a_3,a_4=[1,2,3,4]\\)，那么有： $$ \\begin{aligned} s_1\u0026amp;=\u0026amp;a_1+a_2+a_3+a_4\\\\ s_2\u0026amp;=\u0026amp;a_2+a_3+a_4\\\\ s_3\u0026amp;=\u0026amp;a_3+a_4\\\\ s_4\u0026amp;=\u0026amp;a_4\\\\ \\end{aligned} $$ 则该 \\(before=\\sum\\limits^n_{i=1}{s_i} = a_1+2a_2+3a_3+4a_4\\)。假如 \\(t=1\\)，那么有： $$ \\begin{aligned} s_1\u0026amp;=\u0026amp;a_1+a_2+a_3\\\\ s_2\u0026amp;=\u0026amp;a_2+a_3\\\\ s_3\u0026amp;=\u0026amp;a_3\\\\ s_4\u0026amp;=\u0026amp;\\\\ \\end{aligned} $$ 此时 \\(after=\\sum\\limits^{n-t}_{i=1}{s_i} = a_1+2a_2+3a_3=before-4a_4\\)。\n计算 \\(\\sum\\limits^n_{i=1}{s_i}\\) 时，每次从末尾删除 \\(t\\) 个元素，都会删掉对应的 权重 \\(\\times\\) 数。\n那么每次操作的时候，只需要在总的 \\(\\sum\\limits^n_{i=1}{s_i}\\) 上进行增删就可以了。\n3. 代码 #\rC\u0026#43;\u0026#43;\rconstexpr int mod = 1000000007; void solve() { int q; std::cin \u0026gt;\u0026gt; q; i64 sum = 0; std::stack\u0026lt;i64\u0026gt; l; while (q--) { i64 t, v; std::cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; v; while (t--) { sum += mod; // 防止减的时候成为负数 sum -= (l.top() * l.size()) % mod; sum %= mod; l.pop(); } l.push(v); sum += (v * l.size()) % mod; sum %= mod; std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } 4. 总结 #\r这个题主要对模运算进行了考察，有几个点需要特别注意一下：\n模运算中：\\((A\\pm* B)\\mod P=((A\\mod P)\\pm* (B\\mod P))\\mod P\\) 由于第一条特性，在程序的减法的过程中会对每一项元素取模后再取模，所以在计算过程中迭代器很容易在做减法的时候变为负数，此时需要在对迭代器取模前先加上一个模数防止溢出。 ","date":"2024 July 26","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/1/c/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营1】C","type":"posts"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E6%A8%A1%E8%BF%90%E7%AE%97/","section":"Tags","summary":"","title":"模运算","type":"tags"},{"content":"\r1. 题目（Problem A Enhanced） #\rEnglish\rGiven two integers \\(n\\) and \\(m\\), among all the sequences containing \\(n\\) non-negative integers less than \\(2^m\\), you need to count the number of such sequences \\(A\\) that there exists two different non-empty subsequencesc of \\(A\\) in which the bitwise AND of the integers is \\(1\\).\nNote that a non-empty subsequence of a sequence \\(A\\) is a non-empty sequence that can be obtained by deleting zero or more elements from \\(A\\) and arranging the remaining elements in their original order. Two subsequences are different if they are composed of different locations in the original sequence.\nSince the answer may be very large, output it modulo a positive integer \\(q\\).\nThe bitwise AND of non-negative integers \\(A\\) and \\(B\\), \\(A\\) AND \\(B\\) is defined as follows:\nWhen \\(A\\) AND \\(B\\) is written in base two, the digit in the \\(2^d\\)\u0026rsquo;s place ( \\(d\\geq 0\\) ) is \\(1\\) if those of \\(A\\) and \\(B\\) are both \\(1\\), and \\(0\\) otherwise. For example, we have \\(4\\) AND \\(6\\) = \\(4\\) (in base two: \\(100\\) AND \\(110\\) = \\(100\\)).\nGenerally, the bitwise AND of \\(k\\) non-negative integers \\(p_1,𝑝_2,\\dots,p_k\\) is defined as (\\(\\dots\\)((\\(p_1\\) AND \\(p_2\\)) AND \\(p_3\\)) AND \\(\\dots\\) AND \\(p_𝑘\\)) and we can prove that this value does not depend on the order of \\(p_1,𝑝_2,\\dots,p_k\\).\nInput\nThe only line contains three integers \\(n\\) (\\(1 \\le n \\le 5,000\\)), \\(m\\) (\\(1 \\le m \\le 5,000\\)) and \\(q\\) (\\(1 \\le q \\le 10^9\\)).\nOutput\nOutput a line containing an integer, denoting the answer.\n简体中文（大意）\r给两个数 \\(n\\) 和 \\(m\\)，表示 \\(n\\) 个 \\(m\\) 位（B）长度的数，寻找【仅存在一个 AND 和为 \\(1\\) 的子序列】的序列的个数。\r2. 思路 #\r这是 \\(A\\) 题的加强版，\\(A\\) 题前序内容参考：\n【2024牛客暑期多校训练营1】A\r2024 July 26\u0026middot;501 字\u0026middot;3 分钟\r比赛\r2024牛客暑期多校训练营\r2024牛客暑期多校训练营1\r数学归纳法\r组合数\r快速幂\r模运算\r此题可以简化为：\\(A\\) 题中的答案 -【有且仅有一个子序列 AND 和为 1 】的数量。\n可以根据 \\(A\\) 题的推导过程发现，每次我们选择 \\(k\\) 个末尾均为 \\(1\\) 的数，剩下的 \\(n - k\\) 数末尾均为 \\(0\\)，那么仅有的这个 AND 和为 \\(1\\) 的子序列必须为当前选定的 \\(k\\) 个数的子序列。但是这个子序列要想满足唯一的条件，就必须修改【除末尾为 \\(1\\)，其余 \\(m - 1\\) 位任选含 \\(0\\) 的 \\(2^k-1\\) 种选择】的条件。\n假如 \\(k=3\\)，最后一位为 \\(1\\)，那么下式中的所有的 \\(\\underline{\\bold{0}}\\) 均为所有选中的 \\(k\\) 个数中所在位唯一的 \\(0\\)（称为特殊位）： $$ \\begin{array}{c|ccc|c} \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\\\ \\hline p_1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \\\\ p_2 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \\\\ p_3 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \\\\ \\end{array} $$ 因此可以发现，当选取 \\(k\\) 个数为子序列的时候，我们要满足这些数都至少包含一个特殊位，当满足 \\(1\\leq k\\leq m-1\\) 的时候，确保不会有重复的特殊位出现： $$ \\begin{array}{c|ccccc|c} \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; \\dots \u0026amp; m-1 \u0026amp; m \\\\ \\hline p_1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \u0026amp; 1 \\\\ p_2 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \u0026amp; 1 \\\\ p_3 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; \\dots \u0026amp; 1 \u0026amp; 1 \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots\\\\ p_k \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \\end{array} $$ 当删除这些特殊位的时候，就会使得某一位不含有 \\(0\\)，不满足 AND 和为 \\(1\\) 的条件，确保了唯一性。\n假如此时选取了 \\(k-1\\) 个数，当在为 \\(k\\) 个数添加特殊位的时候，有以下两种情况：\n添加到新选择的数的某一位上。 添加到已选择的 \\(k-1\\) 中某一个数的某一位上 我们采用动态规划，假设选择 \\(k\\) 个数，有 \\(t\\) (\\(k\\leq t\\leq m-1\\)) 个特殊位的方案数为 \\(dp(k,t)\\)，那么状态转移方程为： $$ dp(k,t)=C^1_k\\cdot(dp(k-1,t-1) + dp(k,t-1)) $$ 即特殊位要么加在 \\(k-1\\) 个数的基础上新加的一个数上，要么加在已经存在的一个数上。直观体现为如下两种情况（红色为已有的特殊位，蓝色为新加的特殊位）： $$ \\begin{align*} \\begin{array}{c|cccccc|c} \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; \\dots \u0026amp; 6 \\\\ \\hline p_1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \\\\ p_2 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \\\\ p_3 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1\\\\ p_4 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{blue}{\\underline{\\bold{0}}} \u0026amp; \\dots \u0026amp; 1\\\\ \\end{array} \\hspace{1cm} \\begin{array}{c|cccccc|c} \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; \\dots \u0026amp; 5 \\\\ \\hline p_1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \\\\ p_2 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \\\\ p_3 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1\\\\ p_4 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; \\color{blue}{\\underline{\\bold{0}}} \u0026amp; \\dots \u0026amp; 1\\\\ \\end{array} \\end{align*} $$ 由于 \\(t\\) 的范围为 \\(k\\leq t\\leq m-1\\)，相当于将 \\(t\\) 个特殊位分给 \\(k\\) 个数，每个数至少含有一个特殊位，类似于第二类斯特林数，故也可以结合斯特林数的推导过程理解状态转移方程。\n需要注意的是：\n当 \\(k=1\\) 的时候，当且仅当子序列为 \\(1\\) 的时候，这个数满足条件，需要单独计算：\\(C_n^1\\cdot2^{(n-1)\\cdot(m-1)}\\) 当 \\(k\u0026gt;1\\) 的时候，我们选择其中 \\(t\\) 位，其他 \\(m-1-t\\) 位依然可以任选，但是注意每位不能只含有一个 \\(0\\) （防止成为特殊位，有 k 种只有一位有 \\(0\\) 情况），再减去全为 \\(1\\) 的情况：\\((2^k-k-1)^{{m-1-t}}\\) 于是最终结果为： $$ \\begin{align*} ans \u0026amp;= \\sum\\limits_{k=1}^n(C_n^k \\cdot(2^k-1)^{m-1}\\cdot2^{(m-1)\\cdot(n-k)})-\\sum\\limits_{k=2}^n(C_n^k\\cdot2^{(m-1)\\cdot(n-k)}\\cdot\\sum\\limits_{t=k}^{m-1}(C_{m-1}^t\\cdot dp(k,t)\\cdot(2^k-k-1)^{m-1-t}))+C_n^1\\cdot2^{(n-1)\\cdot(m-1)}\\\\ \u0026amp;=\\sum\\limits_{k=2}^n(C_n^k\\cdot2^{(m-1)\\cdot(n-k)}\\cdot((2^k-1)^{m-1}-\\sum\\limits_{t=k}^{m-1}(C_{m-1}^t\\cdot dp(k,t)\\cdot(2^k-k-1)^{m-1-t}))) \\end{align*} $$\n3. 代码 #\rC\u0026#43;\u0026#43;\ri64 binpow(i64 a, i64 b, i64 mod) { a %= mod; i64 ans = 1; while (b \u0026gt; 0) { if (b \u0026amp; 1) { ans *= a; ans %= mod; } a *= a; a %= mod; b \u0026gt;\u0026gt;= 1; } return ans; } void solve() { int n, m; i64 q; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; std::vector\u0026lt;i64\u0026gt; a(n + 1), c(n + 1), ct(m); a[0] = c[0] = ct[0] = 1; for (int k = 1; k \u0026lt;= n; k++) { a[k] = a[k - 1] \u0026lt;\u0026lt; 1; a[k] %= q; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = i; j \u0026gt; 0; j--) { c[j] = (c[j] + c[j - 1]) % q; } } for (int i = 1; i \u0026lt;= m - 1; i++) { for (int j = i; j \u0026gt; 0; j--) { ct[j] = (ct[j] + ct[j - 1]) % q; } } std::vector\u0026lt;std::vector\u0026lt;i64\u0026gt;\u0026gt; dp(n + 1, std::vector\u0026lt;i64\u0026gt;(m)); dp[0][0] = 1; for (int k = 1; k \u0026lt;= n; k++) { for (int t = 1; t \u0026lt;= m - 1; t++) { dp[k][t] = ((dp[k][t - 1] + dp[k - 1][t - 1]) % q * k) % q; } } i64 ans = 0; for (int k = 2; k \u0026lt;= n; k++) { i64 tmp1 = binpow(a[k] - 1, m - 1, q); i64 tmp2 = 0, tp = (a[k] + q - k - 1) % q, tmpt = 1; for (int t = m - 1; t \u0026gt;= k; t--) { tmp2 += ((ct[t] * dp[k][t]) % q * tmpt) % q; tmp2 %= q; tmpt *= tp; tmpt %= q; } i64 tmp3 = binpow(a[n - k], m - 1, q); ans += (((tmp1 + q - tmp2) % q * tmp3) % q * c[k]) % q; ans %= q; } std::cout \u0026lt;\u0026lt; ans; } 4. 总结 #\r本题是 \\(A\\) 题的加强版，在 \\(A\\) 的基础上引入了第二类斯特林数的思想对【有且仅有一个子序列 AND 和为 1 】进行了解释和推导，是对于规律总结和组合数学的很好的练习。\n第二类斯特林数请参考：\n第二类斯特林数\r2024 July 29\u0026middot;38 字\u0026middot;1 分钟\r数学\r组合数学\r第二类斯特林数是组合数学上常见的一种概念，用于解决集合拆分的问题。\r","date":"2024 July 26","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/1/b/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营1】B","type":"posts"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E7%AC%AC%E4%BA%8C%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/","section":"Tags","summary":"","title":"第二类斯特林数","type":"tags"},{"content":"\r1. 题目 #\rEnglish\rGiven two integers \\(n\\) and \\(m\\), among all the sequences containing \\(n\\) non-negative integers less than \\(2^m\\), you need to count the number of such sequences \\(A\\) that there exists a non-empty subsequence of \\(A\\) in which the bitwise AND of the integers is \\(1\\).\nNote that a non-empty subsequence of a sequence \\(A\\) is a non-empty sequence that can be obtained by deleting zero or more elements from \\(A\\) and arranging the remaining elements in their original order.\nSince the answer may be very large, output it modulo a positive integer \\(q\\).\nThe bitwise AND of non-negative integers \\(A\\) and \\(B\\), \\(A\\) AND \\(B\\) is defined as follows:\nWhen \\(A\\) AND \\(B\\) is written in base two, the digit in the \\(2^d\\)\u0026rsquo;s place ( \\(d\\geq 0\\) ) is \\(1\\) if those of \\(A\\) and \\(B\\) are both \\(1\\), and \\(0\\) otherwise. For example, we have \\(4\\) AND \\(6\\) = \\(4\\) (in base two: \\(100\\) AND \\(110\\) = \\(100\\)).\nGenerally, the bitwise AND of \\(k\\) non-negative integers \\(p_1,𝑝_2,\\dots,p_k\\) is defined as (\\(\\dots\\)((\\(p_1\\) AND \\(p_2\\)) AND \\(p_3\\)) AND \\(\\dots\\) AND \\(p_𝑘\\)) and we can prove that this value does not depend on the order of \\(p_1,𝑝_2,\\dots,p_k\\).\nInput\nThe only line contains three integers \\(n\\) (\\(1 \\le n \\le 5,000\\)), \\(m\\) (\\(1 \\le m \\le 5,000\\)) and \\(q\\) (\\(1 \\le q \\le 10^9\\)).\nOutput\nOutput a line containing an integer, denoting the answer.\n简体中文（大意）\r给两个数 \\(n\\) 和 \\(m\\)，表示 \\(n\\) 个 \\(m\\) 位（B）长度的数，寻找【存在 AND 和为 \\(1\\) 的子序列】的序列的个数。\r2. 思路 #\r这是一道找规律的题。通过观察样例2 3 998244353 -\u0026gt; 17可以发现如下的计算过程：\n选择含有一个数的子序列，则选择的这个子序列必须为 001。另外一个数的各位任选，有 \\(2^3\\) 种方案。由于子序列按照不同顺序排列算作不同的子序列，那将001放在另一个数的位置为另一种情况。此时还需要减去[001, 001]的情况，出现了两次。故此时的结果为 \\(2^3+2^3 - 1=15\\)。 选择含有两个数的子序列，则选择的两个子序列的末尾那一位必须均为 \\(1\\)。由于刚刚已经计算过了其中一位为001的情况，再加上两个末尾为 \\(1\\) 但是不为001的情况：[101, 011]和[011, 101]。故此时的结果为 \\(15+2=17\\)。 将上面的过程进行推广我们可以发现有如下的规律：\n选择其中的 \\(k\\) 个数，使得这 \\(k\\) 个数的末尾一位均为 \\(1\\)，而其他位上的数，保证至少出现一个 \\(0\\)。我们可以知道第 \\(i\\) 位的数字范围为[000...0~111...1]，当我们去除最后一个全为 \\(1\\) 的数，其他的数均满足出现至少一个 \\(0\\)。此时的范围为 \\(C_n^k \\cdot(2^k-1)^{m-1}\\)，即从 \\(n\\) 个数中任选 \\(k\\) 个数并对除了最后一位的其余 \\(m-1\\) 位都获取了 \\(2^k-1\\) 种结果。 然后对于剩下的 \\(n-k\\) 个数，任意选择每一位上的结果，为了保证不会重复计算，让剩下的 \\(n-k\\) 个数的最后一位均为 \\(0\\)。此时的范围为 \\((2^{m-1})^{n-k}=2^{(m-1)\\cdot(n-k)}\\)，即对每一个数选定最后一位为 \\(0\\)，其余位置任选。 于是最终的结果为： $$ \\sum\\limits_{k=1}^n(C_n^k \\cdot(2^k-1)^{m-1}\\cdot2^{(m-1)\\cdot(n-k)}) $$\n3. 代码 #\rC\u0026#43;\u0026#43;\ri64 binpow(i64 a, i64 b, i64 mod) // 快速幂 { a %= mod; i64 ans = 1; while (b \u0026gt; 0) { if (b \u0026amp; 1) { ans = (ans * a) % mod; } a = (a * a) % mod; b \u0026gt;\u0026gt;= 1; } return ans; } void solve() { int n, m; i64 q; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; std::vector\u0026lt;i64\u0026gt; a(n + 1), c(n + 1); a[0] = c[0] = 1; for (int k = 1; k \u0026lt;= n; k++) { a[k] = a[k - 1] \u0026lt;\u0026lt; 1; a[k] %= q; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = i; j \u0026gt; 0; j--) { c[j] = (c[j] + c[j - 1]) % q; } } i64 ans = 0; for (int k = 1; k \u0026lt;= n; k++) { i64 tmp1 = binpow(a[k] - 1, m - 1, q); i64 tmp2 = binpow(a[n - k], m - 1, q); ans += ((tmp1 * tmp2) % q * c[k]) % q; ans %= q; } std::cout \u0026lt;\u0026lt; ans; } 4. 总结 #\r本题主要是考察找规律的技巧，通过数学归纳法对样例的推导过程进行总结，然后推导出计算公式。\n此外，本题还有几个小的知识点：\n组合数的计算，通过压缩到一维减少空间的使用。 取模运算的技巧。 用快速幂加快幂的运算。 总之这道题考验选手在赛场上总结规律的能力和组合数学以及其他的基本功。\n","date":"2024 July 26","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/1/a/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营1】A","type":"posts"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/","section":"Tags","summary":"","title":"快速幂","type":"tags"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95/","section":"Tags","summary":"","title":"数学归纳法","type":"tags"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E7%BB%84%E5%90%88%E6%95%B0/","section":"Tags","summary":"","title":"组合数","type":"tags"},{"content":"","date":"26 July 2024","externalUrl":null,"permalink":"/en/about/","section":"OrangeTree","summary":"","title":"About","type":"page"},{"content":"","date":"26 July 2024","externalUrl":null,"permalink":"/en/","section":"OrangeTree","summary":"","title":"OrangeTree","type":"page"},{"content":"Heyo~ I\u0026rsquo;m building my site in Chinese, wish to meet you one day.\nCiallo～(∠・ω\u0026lt; )⌒☆\n","date":"26 July 2024","externalUrl":null,"permalink":"/en/posts/building_my_site/building_my_site/","section":"Posts","summary":"Heyo~ I\u0026rsquo;m building my site in Chinese, wish to meet you one day.","title":"Building My Site...","type":"posts"},{"content":"","date":"26 July 2024","externalUrl":null,"permalink":"/en/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]