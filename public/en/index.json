


[{"content":"","date":"2024 July 28","externalUrl":null,"permalink":"/posts/24nowcodersummer/","section":"Posts","summary":"","title":"2024牛客暑期多校训练营","type":"posts"},{"content":"","date":"2024 July 28","externalUrl":null,"permalink":"/categories/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5/","section":"Categories","summary":"","title":"2024牛客暑期多校训练营","type":"categories"},{"content":"","date":"2024 July 28","externalUrl":null,"permalink":"/posts/24nowcodersummer/1/","section":"Posts","summary":"","title":"2024牛客暑期多校训练营1","type":"posts"},{"content":"\r1. 题目 #\rEnglish\rThe ICPC World Finals are coming. Due to some reasons, the 46th and 47th World Finals will be held simultaneously. For the teams qualified in both competitions, they should choose one to take part in.\nAs we know, lzr010506\u0026rsquo;s team is double-qualified and should make a choice. To make a wiser choice, lzr010506 looked up the qualified lists for two competitions and trained a magic model to predict the results for all participants among the two competitions. Moreover, a result contains the number of solved problems and the time penalty. The more solved problems, the better the result is, and if two teams solved the same number of problems, the result with the lower time penalty is better.\nNow, lzr010506 wants to know the best possible ranking if the actual results are all the same as predicted and that the competition choices of the double-qualified teams can be arbitrarily arranged by him.\nInput\nThe first line contains one integer \\(n\\) (\\(1 \\le n \\le 10^5\\)), denoting the number of teams qualified in the 46th World Finals.\nNext nnn lines each contain one string \\(S\\) (\\(1 \\le |S| \\le 10\\)) and two integers \\(p,t\\) (\\(1 \\le p,t \\le 10^9\\)), denoting the name, the predicted number of solved problems, and time penalty of one team in the 46th World Finals respectively.\nNext one line contains one integer \\(m\\) (\\(1 \\le m \\le 10^5\\)), denoting the number of teams qualified in the 47th World Finals.\nNext \\(m\\) lines each contain one string \\(S\\) (\\(1 \\le |S| \\le 10\\)) and two integers \\(p,t\\) (\\(1 \\le p,t \\le 10^9\\)), denoting the name, the predicted number of solved problems, and time penalty of one team in the 47th World Finals respectively.\nIt is guaranteed that:\nthe team names only contain digits and English letters; the team names in one competition are different from each other; no two teams have the same predicted number of solved problems and the time penalty simultaneously in one competition; the same names among two qualified name lists refer to the same team in real; lzr010506 appears in both two qualified name lists. Output\nOutput one line containing one integer, denoting the best possible ranking of lzr010506\u0026rsquo;s team.\n2. 思路 #\r签到题，只需要将两次比赛的队伍按照规则排个序，然后假设在两场比赛在lzr010506之前的队伍都参加另一场比赛（如果能参加另一场比赛的话），比较lzr010506在两场比赛中的名次取最小值。\n3. 代码 #\rC\u0026#43;\u0026#43;\rstruct part { std::string s; int pass, pen; }; bool cmp(part x, part y) { if (x.pass \u0026gt; y.pass) { return true; } else if (x.pass == y.pass) { return x.pen \u0026lt; y.pen; } else { return false; } } void solve() { int n; std::cin \u0026gt;\u0026gt; n; std::set\u0026lt;std::string\u0026gt; l46b, l47b; std::vector\u0026lt;part\u0026gt; l46(n); for (int i = 0; i \u0026lt; n; i++) { std::string s; int p, t; std::cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; p \u0026gt;\u0026gt; t; l46[i] = {s, p, t}; l46b.insert(s); } int m; std::cin \u0026gt;\u0026gt; m; std::vector\u0026lt;part\u0026gt; l47(m); for (int i = 0; i \u0026lt; m; i++) { std::string s; int p, t; std::cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; p \u0026gt;\u0026gt; t; l47[i] = {s, p, t}; l47b.insert(s); } std::sort(l46.begin(), l46.end(), cmp); std::sort(l47.begin(), l47.end(), cmp); std::set\u0026lt;std::string\u0026gt; l46f, l47f; for (int i = 0; i \u0026lt; n; i++) { if (l46[i].s == \u0026#34;lzr010506\u0026#34;) { break; } l46f.insert(l46[i].s); } for (int i = 0; i \u0026lt; m; i++) { if (l47[i].s == \u0026#34;lzr010506\u0026#34;) { break; } l47f.insert(l47[i].s); } int num1 = 1, num2 = 1; for (auto i : l46f) { if (l47b.find(i) == l47b.end()) { num1 ++; } } for (auto i : l47f) { if (l46b.find(i) == l46b.end()) { num2 ++; } } std::cout \u0026lt;\u0026lt; std::min(num1, num2); } 4. 总结 #\r签到题\n","date":"2024 July 27","externalUrl":null,"permalink":"/posts/24nowcodersummer/1/h/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营1】H","type":"posts"},{"content":"","date":"2024 July 27","externalUrl":null,"permalink":"/series/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A51/","section":"Series","summary":"","title":"2024牛客暑期多校训练营1","type":"series"},{"content":"","date":"2024 July 27","externalUrl":null,"permalink":"/tags/%E7%AD%BE%E5%88%B0%E9%A2%98/","section":"Tags","summary":"","title":"签到题","type":"tags"},{"content":"\r1. 题目 #\rEnglish\rGiven an array which is initially empty, you need to perform \\(q\\) operations:\nGiven two non-negative integers \\(t\\) and \\(v\\), take out the element from the end of the array for \\(t\\) times and then append \\(v\\) to the end of the array. It is guaranteed that \\(t\\) does not exceed the length of the array before this operation. After each operation, let \\(a_1,a_2,\\dots,a_n\\) be the current array, find the sum of \\(s_1,s_2,\\dots,s_n\\) , where \\(s_i =a_i +a_{i+1}+\\dots+a_n\\) is the sum of the suffix starting from position \\(i\\).\nSince the answers may be very large, output them modulo \\(1000000007\\).\nInput\nThe first line contains an integer \\(q\\) ( \\(1\\leq q\\leq 5\\times 10^5\\) ), denoting the number of operations.\nEach of the following \\(q\\) lines contains two non-negative integers \\(t\\) and \\(v\\) ( \\(0\\leq v\\leq 10^9\\) ), describing an operation, where \\(t\\) does not exceed the length of the array before this operation.\nOutput\nOutput \\(q\\) lines, each of which contains an integer, denoting the answer.\n2. 思路 #\r观察到元素在后缀和中拥有不同的权重，假如 \\(a_1,a_2,a_3,a_4=[1,2,3,4]\\)，那么有： $$ \\begin{aligned} s_1\u0026amp;=\u0026amp;a_1+a_2+a_3+a_4\\\\ s_2\u0026amp;=\u0026amp;a_2+a_3+a_4\\\\ s_3\u0026amp;=\u0026amp;a_3+a_4\\\\ s_4\u0026amp;=\u0026amp;a_4\\\\ \\end{aligned} $$ 则该 \\(before=\\sum\\limits^n_{i=1}{s_i} = a_1+2a_2+3a_3+4a_4\\)。假如 \\(t=1\\)，那么有： $$ \\begin{aligned} s_1\u0026amp;=\u0026amp;a_1+a_2+a_3\\\\ s_2\u0026amp;=\u0026amp;a_2+a_3\\\\ s_3\u0026amp;=\u0026amp;a_3\\\\ s_4\u0026amp;=\u0026amp;\\\\ \\end{aligned} $$ 此时 \\(after=\\sum\\limits^{n-t}_{i=1}{s_i} = a_1+2a_2+3a_3=before-4a_4\\)。\n计算 \\(\\sum\\limits^n_{i=1}{s_i}\\) 时，每次从末尾删除 \\(t\\) 个元素，都会删掉对应的 权重 \\(\\times\\) 数。\n那么每次操作的时候，只需要在总的 \\(\\sum\\limits^n_{i=1}{s_i}\\) 上进行增删就可以了。\n3. 代码 #\rC\u0026#43;\u0026#43;\rconstexpr int mod = 1000000007; void solve() { int q; std::cin \u0026gt;\u0026gt; q; i64 sum = 0; std::stack\u0026lt;i64\u0026gt; l; while (q--) { i64 t, v; std::cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; v; while (t--) { sum += mod; // 防止减的时候成为负数 sum -= (l.top() * l.size()) % mod; sum %= mod; l.pop(); } l.push(v); sum += (v * l.size()) % mod; sum %= mod; std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } 4. 总结 #\r这个题主要对模运算进行了考察，有几个点需要特别注意一下：\n模运算中：\\((A\\pm* B)\\mod P=((A\\mod P)\\pm (B\\mod P))\\mod P\\) 由于第一条特性，在程序的减法的过程中会对每一项元素取模后再取模，所以在计算过程中迭代器很容易在做减法的时候变为负数，此时需要在对迭代器取模前先加上一个模数防止溢出。 ","date":"2024 July 26","externalUrl":null,"permalink":"/posts/24nowcodersummer/1/c/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营1】C","type":"posts"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/","section":"Tags","summary":"","title":"前缀和","type":"tags"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E6%A8%A1%E8%BF%90%E7%AE%97/","section":"Tags","summary":"","title":"模运算","type":"tags"},{"content":"\r1. 题目（Problem A Enhanced） #\rEnglish\rGiven two integers \\(n\\) and \\(m\\), among all the sequences containing \\(n\\) non-negative integers less than \\(2^m\\), you need to count the number of such sequences \\(A\\) that there exists two different non-empty subsequencesc of \\(A\\) in which the bitwise AND of the integers is \\(1\\).\nNote that a non-empty subsequence of a sequence \\(A\\) is a non-empty sequence that can be obtained by deleting zero or more elements from \\(A\\) and arranging the remaining elements in their original order. Two subsequences are different if they are composed of different locations in the original sequence.\nSince the answer may be very large, output it modulo a positive integer \\(q\\).\nThe bitwise AND of non-negative integers \\(A\\) and \\(B\\), \\(A\\) AND \\(B\\) is defined as follows:\nWhen \\(A\\) AND \\(B\\) is written in base two, the digit in the \\(2^d\\)\u0026rsquo;s place ( \\(d\\geq 0\\) ) is \\(1\\) if those of \\(A\\) and \\(B\\) are both \\(1\\), and \\(0\\) otherwise. For example, we have \\(4\\) AND \\(6\\) = \\(4\\) (in base two: \\(100\\) AND \\(110\\) = \\(100\\)).\nGenerally, the bitwise AND of \\(k\\) non-negative integers \\(p_1,𝑝_2,\\dots,p_k\\) is defined as (\\(\\dots\\)((\\(p_1\\) AND \\(p_2\\)) AND \\(p_3\\)) AND \\(\\dots\\) AND \\(p_𝑘\\)) and we can prove that this value does not depend on the order of \\(p_1,𝑝_2,\\dots,p_k\\).\nInput\nThe only line contains three integers \\(n\\) (\\(1 \\le n \\le 5,000\\)), \\(m\\) (\\(1 \\le m \\le 5,000\\)) and \\(q\\) (\\(1 \\le q \\le 10^9\\)).\nOutput\nOutput a line containing an integer, denoting the answer.\n2. 思路 #\r这是 \\(A\\) 题的加强版，\\(A\\) 题前序内容参考：\n【2024牛客暑期多校训练营1】A\r2024 July 26\u0026middot;488 字\u0026middot;3 分钟\r数学归纳法\r组合数\r快速幂\r模运算\r此题可以简化为：\\(A\\) 题中的答案 -【有且仅有一个子序列 AND 和为 1 】的数量。\n可以根据 \\(A\\) 题的推导过程发现，每次我们选择 \\(k\\) 个末尾均为 \\(1\\) 的数，剩下的 \\(n - k\\) 数末尾均为 \\(0\\)，那么仅有的这个 AND 和为 \\(1\\) 的子序列必须为当前选定的 \\(k\\) 个数的子序列。但是这个子序列要想满足唯一的条件，就必须修改【除末尾为 \\(1\\)，其余 \\(m - 1\\) 位任选含 \\(0\\) 的 \\(2^k-1\\) 种选择】的条件。\n假如 \\(k=3\\)，最后一位为 \\(1\\)，那么下式中的所有的 \\(\\underline{\\bold{0}}\\) 均为所有选中的 \\(k\\) 个数中所在位唯一的 \\(0\\)（称为特殊位）： $$ \\begin{array}{c|ccc|c} \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\\\ \\hline p_1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \\\\ p_2 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \\\\ p_3 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \\\\ \\end{array} $$ 因此可以发现，当选取 \\(k\\) 个数为子序列的时候，我们要满足这些数都至少包含一个特殊位，当满足 \\(1\\leq k\\leq m-1\\) 的时候，确保不会有重复的特殊位出现： $$ \\begin{array}{c|ccccc|c} \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; \\dots \u0026amp; m-1 \u0026amp; m \\\\ \\hline p_1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \u0026amp; 1 \\\\ p_2 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \u0026amp; 1 \\\\ p_3 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; \\dots \u0026amp; 1 \u0026amp; 1 \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots\\\\ p_k \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \\end{array} $$ 当删除这些特殊位的时候，就会使得某一位不含有 \\(0\\)，不满足 AND 和为 \\(1\\) 的条件，确保了唯一性。\n假如此时选取了 \\(k-1\\) 个数，当在为 \\(k\\) 个数添加特殊位的时候，有以下两种情况：\n添加到新选择的数的某一位上。 添加到已选择的 \\(k-1\\) 中某一个数的某一位上 我们采用动态规划，假设选择 \\(k\\) 个数，有 \\(t\\) (\\(k\\leq t\\leq m-1\\)) 个特殊位的方案数为 \\(dp(k,t)\\)，那么状态转移方程为： $$ dp(k,t)=C^1_k\\cdot(dp(k-1,t-1) + dp(k,t-1)) $$ 即特殊位要么加在 \\(k-1\\) 个数的基础上新加的一个数上，要么加在已经存在的一个数上。直观体现为如下两种情况（红色为已有的特殊位，蓝色为新加的特殊位）： $$ \\begin{align*} \\begin{array}{c|cccccc|c} \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; \\dots \u0026amp; 6 \\\\ \\hline p_1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \\\\ p_2 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \\\\ p_3 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1\\\\ p_4 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{blue}{\\underline{\\bold{0}}} \u0026amp; \\dots \u0026amp; 1\\\\ \\end{array} \\hspace{1cm} \\begin{array}{c|cccccc|c} \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; \\dots \u0026amp; 5 \\\\ \\hline p_1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \\\\ p_2 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \\\\ p_3 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1\\\\ p_4 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; \\color{blue}{\\underline{\\bold{0}}} \u0026amp; \\dots \u0026amp; 1\\\\ \\end{array} \\end{align*} $$ 由于 \\(t\\) 的范围为 \\(k\\leq t\\leq m-1\\)，相当于将 \\(t\\) 个特殊位分给 \\(k\\) 个数，每个数至少含有一个特殊位，类似于斯特林数，故也可以结合斯特林数的推导过程理解状态转移方程。\n需要注意的是：\n当 \\(k=1\\) 的时候，当且仅当子序列为 \\(1\\) 的时候，这个数满足条件，需要单独计算：\\(C_n^1\\cdot2^{(n-1)\\cdot(m-1)}\\) 当 \\(k\u0026gt;1\\) 的时候，我们选择其中 \\(t\\) 位，其他位 \\(m-1-t\\) 依然可以任选，但是注意不能只含有一个 \\(0\\) （防止成为特殊位），有 k 种情况（只有一位有 \\(0\\)），再减去全为 \\(1\\) 的情况：\\((2^k-k-1)^{{m-1-t}}\\) 于是最终结果为： $$ \\begin{align*} ans \u0026amp;= \\sum\\limits_{k=1}^n(C_n^k \\cdot(2^k-1)^{m-1}\\cdot2^{(m-1)\\cdot(n-k)})-\\sum\\limits_{k=2}^n(C_n^k\\cdot2^{(m-1)\\cdot(n-k)}\\cdot\\sum\\limits_{t=k}^{m-1}(C_{m-1}^t\\cdot dp(k,t)\\cdot(2^k-k-1)^{m-1-t}))+C_n^1\\cdot2^{(n-1)\\cdot(m-1)}\\\\ \u0026amp;=\\sum\\limits_{k=2}^n(C_n^k\\cdot2^{(m-1)\\cdot(n-k)}\\cdot((2^k-1)^{m-1}-\\sum\\limits_{t=k}^{m-1}(C_{m-1}^t\\cdot dp(k,t)\\cdot(2^k-k-1)^{m-1-t}))) \\end{align*} $$\n3. 代码 #\rC\u0026#43;\u0026#43;\ri64 binpow(i64 a, i64 b, i64 mod) { a %= mod; i64 ans = 1; while (b \u0026gt; 0) { if (b \u0026amp; 1) { ans *= a; ans %= mod; } a *= a; a %= mod; b \u0026gt;\u0026gt;= 1; } return ans; } void solve() { int n, m; i64 q; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; std::vector\u0026lt;i64\u0026gt; a(n + 1), c(n + 1), ct(m); a[0] = c[0] = ct[0] = 1; for (int k = 1; k \u0026lt;= n; k++) { a[k] = a[k - 1] \u0026lt;\u0026lt; 1; a[k] %= q; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = i; j \u0026gt; 0; j--) { c[j] = (c[j] + c[j - 1]) % q; } } for (int i = 1; i \u0026lt;= m - 1; i++) { for (int j = i; j \u0026gt; 0; j--) { ct[j] = (ct[j] + ct[j - 1]) % q; } } std::vector\u0026lt;std::vector\u0026lt;i64\u0026gt;\u0026gt; dp(n + 1, std::vector\u0026lt;i64\u0026gt;(m)); dp[0][0] = 1; for (int k = 1; k \u0026lt;= n; k++) { for (int t = 1; t \u0026lt;= m - 1; t++) { dp[k][t] = ((dp[k][t - 1] + dp[k - 1][t - 1]) % q * k) % q; } } i64 ans = 0; for (int k = 2; k \u0026lt;= n; k++) { i64 tmp1 = binpow(a[k] - 1, m - 1, q); i64 tmp2 = 0, tp = (a[k] + q - k - 1) % q, tmpt = 1; for (int t = m - 1; t \u0026gt;= k; t--) { tmp2 += ((ct[t] * dp[k][t]) % q * tmpt) % q; tmp2 %= q; tmpt *= tp; tmpt %= q; } i64 tmp3 = binpow(a[n - k], m - 1, q); ans += (((tmp1 + q - tmp2) % q * tmp3) % q * c[k]) % q; ans %= q; } std::cout \u0026lt;\u0026lt; ans; } 4. 总结 #\r本题是 \\(A\\) 题的加强版，在 \\(A\\) 的基础上引入了斯特林数的思想对【有且仅有一个子序列 AND 和为 1 】进行了解释和推导，是对于规律总结和组合数学的很好的练习。\n","date":"2024 July 26","externalUrl":null,"permalink":"/posts/24nowcodersummer/1/b/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营1】B","type":"posts"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/","section":"Tags","summary":"","title":"斯特林数","type":"tags"},{"content":"\r1. 题目 #\rEnglish\rGiven two integers \\(n\\) and \\(m\\), among all the sequences containing \\(n\\) non-negative integers less than \\(2^m\\), you need to count the number of such sequences \\(A\\) that there exists a non-empty subsequence of \\(A\\) in which the bitwise AND of the integers is \\(1\\).\nNote that a non-empty subsequence of a sequence \\(A\\) is a non-empty sequence that can be obtained by deleting zero or more elements from \\(A\\) and arranging the remaining elements in their original order.\nSince the answer may be very large, output it modulo a positive integer \\(q\\).\nThe bitwise AND of non-negative integers \\(A\\) and \\(B\\), \\(A\\) AND \\(B\\) is defined as follows:\nWhen \\(A\\) AND \\(B\\) is written in base two, the digit in the \\(2^d\\)\u0026rsquo;s place ( \\(d\\geq 0\\) ) is \\(1\\) if those of \\(A\\) and \\(B\\) are both \\(1\\), and \\(0\\) otherwise. For example, we have \\(4\\) AND \\(6\\) = \\(4\\) (in base two: \\(100\\) AND \\(110\\) = \\(100\\)).\nGenerally, the bitwise AND of \\(k\\) non-negative integers \\(p_1,𝑝_2,\\dots,p_k\\) is defined as (\\(\\dots\\)((\\(p_1\\) AND \\(p_2\\)) AND \\(p_3\\)) AND \\(\\dots\\) AND \\(p_𝑘\\)) and we can prove that this value does not depend on the order of \\(p_1,𝑝_2,\\dots,p_k\\).\nInput\nThe only line contains three integers \\(n\\) (\\(1 \\le n \\le 5,000\\)), \\(m\\) (\\(1 \\le m \\le 5,000\\)) and \\(q\\) (\\(1 \\le q \\le 10^9\\)).\nOutput\nOutput a line containing an integer, denoting the answer.\n2. 思路 #\r这是一道找规律的题。通过观察样例2 3 998244353 -\u0026gt; 17可以发现如下的计算过程：\n选择含有一个数的子序列，则选择的这个子序列必须为 001。另外一个数的各位任选，有 \\(2^3\\) 种方案。由于子序列按照不同顺序排列算作不同的子序列，那将001放在另一个数的位置为另一种情况。此时还需要减去[001, 001]的情况，出现了两次。故此时的结果为 \\(2^3+2^3 - 1=15\\)。 选择含有两个数的子序列，则选择的两个子序列的末尾那一位必须均为 \\(1\\)。由于刚刚已经计算过了其中一位为001的情况，再加上两个末尾为 \\(1\\) 但是不为001的情况：[101, 011]和[011, 101]。故此时的结果为 \\(15+2=17\\)。 将上面的过程进行推广我们可以发现有如下的规律：\n选择其中的 \\(k\\) 个数，使得这 \\(k\\) 个数的末尾一位均为 \\(1\\)，而其他位上的数，保证至少出出现一个 \\(0\\)。我们可以知道第 \\(i\\) 位的数字范围为[000...0~111...1]，当我们去除最后一个全为 \\(1\\) 的数，其他的数均满足出现至少一个 \\(0\\)。此时的范围为 \\(C_n^k \\cdot(2^k-1)^{m-1}\\)，即从 \\(n\\) 个数中任选 \\(k\\) 个数并对除了最后一位的其余 \\(m-1\\) 位都获取了 \\(2^k-1\\) 种结果。 然后对于剩下的 \\(n-k\\) 个数，任意选择每一位上的结果，为了保证不会重复计算，让剩下的 \\(n-k\\) 个数的最后一位均为 \\(0\\)。此时的范围为 \\((2^{m-1})^{n-k}=2^{(m-1)\\cdot(n-k)}\\)，即对每一个数选定最后一位为 \\(0\\)，其余位置任选。 于是最终的结果为： $$ \\sum\\limits_{k=1}^n(C_n^k \\cdot(2^k-1)^{m-1}\\cdot2^{(m-1)\\cdot(n-k)}) $$\n3. 代码 #\rC\u0026#43;\u0026#43;\ri64 binpow(i64 a, i64 b, i64 mod) // 快速幂 { a %= mod; i64 ans = 1; while (b \u0026gt; 0) { if (b \u0026amp; 1) { ans = (ans * a) % mod; } a = (a * a) % mod; b \u0026gt;\u0026gt;= 1; } return ans; } void solve() { int n, m; i64 q; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; std::vector\u0026lt;i64\u0026gt; a(n + 1), c(n + 1); a[0] = c[0] = 1; for (int k = 1; k \u0026lt;= n; k++) { a[k] = a[k - 1] \u0026lt;\u0026lt; 1; a[k] %= q; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = i; j \u0026gt; 0; j--) { c[j] = (c[j] + c[j - 1]) % q; } } i64 ans = 0; for (int k = 1; k \u0026lt;= n; k++) { i64 tmp1 = binpow(a[k] - 1, m - 1, q); i64 tmp2 = binpow(a[n - k], m - 1, q); ans += ((tmp1 * tmp2) % q * c[k]) % q; ans %= q; } std::cout \u0026lt;\u0026lt; ans; } 4. 总结 #\r本题主要是考察找规律的技巧，通过数学归纳法对样例的推导过程进行总结，然后推导出计算公式。\n此外，本题还有几个小的知识点：\n组合数的计算，通过压缩到一维减少空间的使用。 取模运算的技巧。 用快速幂加快幂的运算。 总之这道题考验选手在赛场上总结规律的能力和组合数学以及其他的基本功。\n","date":"2024 July 26","externalUrl":null,"permalink":"/posts/24nowcodersummer/1/a/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营1】A","type":"posts"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/","section":"Tags","summary":"","title":"快速幂","type":"tags"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95/","section":"Tags","summary":"","title":"数学归纳法","type":"tags"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E7%BB%84%E5%90%88%E6%95%B0/","section":"Tags","summary":"","title":"组合数","type":"tags"},{"content":"","date":"26 July 2024","externalUrl":null,"permalink":"/en/about/","section":"OrangeTree","summary":"","title":"About","type":"page"},{"content":"","date":"26 July 2024","externalUrl":null,"permalink":"/en/","section":"OrangeTree","summary":"","title":"OrangeTree","type":"page"},{"content":"Hi there! I\u0026rsquo;m building my site in Chinese, wish to meet you one day.\nCiallo～(∠・ω\u0026lt; )⌒☆\n","date":"26 July 2024","externalUrl":null,"permalink":"/en/posts/building_my_site/building_my_site/","section":"Posts","summary":"Hi there!","title":"Building My Site","type":"posts"},{"content":"","date":"26 July 2024","externalUrl":null,"permalink":"/en/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]