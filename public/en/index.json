


[{"content":"","date":"2024 July 28","externalUrl":null,"permalink":"/posts/24nowcodersummer/","section":"Posts","summary":"","title":"2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥","type":"posts"},{"content":"","date":"2024 July 28","externalUrl":null,"permalink":"/categories/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5/","section":"Categories","summary":"","title":"2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥","type":"categories"},{"content":"","date":"2024 July 28","externalUrl":null,"permalink":"/posts/24nowcodersummer/1/","section":"Posts","summary":"","title":"2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥1","type":"posts"},{"content":"\r1. é¢˜ç›® #\rEnglish\rThe ICPC World Finals are coming. Due to some reasons, the 46th and 47th World Finals will be held simultaneously. For the teams qualified in both competitions, they should choose one to take part in.\nAs we know, lzr010506\u0026rsquo;s team is double-qualified and should make a choice. To make a wiser choice, lzr010506 looked up the qualified lists for two competitions and trained a magic model to predict the results for all participants among the two competitions. Moreover, a result contains the number of solved problems and the time penalty. The more solved problems, the better the result is, and if two teams solved the same number of problems, the result with the lower time penalty is better.\nNow, lzr010506 wants to know the best possible ranking if the actual results are all the same as predicted and that the competition choices of the double-qualified teams can be arbitrarily arranged by him.\nInput\nThe first line contains one integer \\(n\\) (\\(1 \\le n \\le 10^5\\)), denoting the number of teams qualified in the 46th World Finals.\nNext nnn lines each contain one string \\(S\\) (\\(1 \\le |S| \\le 10\\)) and two integers \\(p,t\\) (\\(1 \\le p,t \\le 10^9\\)), denoting the name, the predicted number of solved problems, and time penalty of one team in the 46th World Finals respectively.\nNext one line contains one integer \\(m\\) (\\(1 \\le m \\le 10^5\\)), denoting the number of teams qualified in the 47th World Finals.\nNext \\(m\\) lines each contain one string \\(S\\) (\\(1 \\le |S| \\le 10\\)) and two integers \\(p,t\\) (\\(1 \\le p,t \\le 10^9\\)), denoting the name, the predicted number of solved problems, and time penalty of one team in the 47th World Finals respectively.\nIt is guaranteed that:\nthe team names only contain digits and English letters; the team names in one competition are different from each other; no two teams have the same predicted number of solved problems and the time penalty simultaneously in one competition; the same names among two qualified name lists refer to the same team in real; lzr010506 appears in both two qualified name lists. Output\nOutput one line containing one integer, denoting the best possible ranking of lzr010506\u0026rsquo;s team.\n2. æ€è·¯ #\rç­¾åˆ°é¢˜ï¼Œåªéœ€è¦å°†ä¸¤æ¬¡æ¯”èµ›çš„é˜Ÿä¼æŒ‰ç…§è§„åˆ™æ’ä¸ªåºï¼Œç„¶åå‡è®¾åœ¨ä¸¤åœºæ¯”èµ›åœ¨lzr010506ä¹‹å‰çš„é˜Ÿä¼éƒ½å‚åŠ å¦ä¸€åœºæ¯”èµ›ï¼ˆå¦‚æœèƒ½å‚åŠ å¦ä¸€åœºæ¯”èµ›çš„è¯ï¼‰ï¼Œæ¯”è¾ƒlzr010506åœ¨ä¸¤åœºæ¯”èµ›ä¸­çš„åæ¬¡å–æœ€å°å€¼ã€‚\n3. ä»£ç  #\rC\u0026#43;\u0026#43;\rstruct part { std::string s; int pass, pen; }; bool cmp(part x, part y) { if (x.pass \u0026gt; y.pass) { return true; } else if (x.pass == y.pass) { return x.pen \u0026lt; y.pen; } else { return false; } } void solve() { int n; std::cin \u0026gt;\u0026gt; n; std::set\u0026lt;std::string\u0026gt; l46b, l47b; std::vector\u0026lt;part\u0026gt; l46(n); for (int i = 0; i \u0026lt; n; i++) { std::string s; int p, t; std::cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; p \u0026gt;\u0026gt; t; l46[i] = {s, p, t}; l46b.insert(s); } int m; std::cin \u0026gt;\u0026gt; m; std::vector\u0026lt;part\u0026gt; l47(m); for (int i = 0; i \u0026lt; m; i++) { std::string s; int p, t; std::cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; p \u0026gt;\u0026gt; t; l47[i] = {s, p, t}; l47b.insert(s); } std::sort(l46.begin(), l46.end(), cmp); std::sort(l47.begin(), l47.end(), cmp); std::set\u0026lt;std::string\u0026gt; l46f, l47f; for (int i = 0; i \u0026lt; n; i++) { if (l46[i].s == \u0026#34;lzr010506\u0026#34;) { break; } l46f.insert(l46[i].s); } for (int i = 0; i \u0026lt; m; i++) { if (l47[i].s == \u0026#34;lzr010506\u0026#34;) { break; } l47f.insert(l47[i].s); } int num1 = 1, num2 = 1; for (auto i : l46f) { if (l47b.find(i) == l47b.end()) { num1 ++; } } for (auto i : l47f) { if (l46b.find(i) == l46b.end()) { num2 ++; } } std::cout \u0026lt;\u0026lt; std::min(num1, num2); } 4. æ€»ç»“ #\rç­¾åˆ°é¢˜\n","date":"2024 July 27","externalUrl":null,"permalink":"/posts/24nowcodersummer/1/h/","section":"Posts","summary":"1.","title":"ã€2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥1ã€‘H","type":"posts"},{"content":"","date":"2024 July 27","externalUrl":null,"permalink":"/series/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A51/","section":"Series","summary":"","title":"2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥1","type":"series"},{"content":"","date":"2024 July 27","externalUrl":null,"permalink":"/tags/%E7%AD%BE%E5%88%B0%E9%A2%98/","section":"Tags","summary":"","title":"ç­¾åˆ°é¢˜","type":"tags"},{"content":"\r1. é¢˜ç›® #\rEnglish\rGiven an array which is initially empty, you need to perform \\(q\\) operations:\nGiven two non-negative integers \\(t\\) and \\(v\\), take out the element from the end of the array for \\(t\\) times and then append \\(v\\) to the end of the array. It is guaranteed that \\(t\\) does not exceed the length of the array before this operation. After each operation, let \\(a_1,a_2,\\dots,a_n\\) be the current array, find the sum of \\(s_1,s_2,\\dots,s_n\\) , where \\(s_i =a_i +a_{i+1}+\\dots+a_n\\) is the sum of the suffix starting from position \\(i\\).\nSince the answers may be very large, output them modulo \\(1000000007\\).\nInput\nThe first line contains an integer \\(q\\) ( \\(1\\leq q\\leq 5\\times 10^5\\) ), denoting the number of operations.\nEach of the following \\(q\\) lines contains two non-negative integers \\(t\\) and \\(v\\) ( \\(0\\leq v\\leq 10^9\\) ), describing an operation, where \\(t\\) does not exceed the length of the array before this operation.\nOutput\nOutput \\(q\\) lines, each of which contains an integer, denoting the answer.\n2. æ€è·¯ #\rè§‚å¯Ÿåˆ°å…ƒç´ åœ¨åç¼€å’Œä¸­æ‹¥æœ‰ä¸åŒçš„æƒé‡ï¼Œå‡å¦‚ \\(a_1,a_2,a_3,a_4=[1,2,3,4]\\)ï¼Œé‚£ä¹ˆæœ‰ï¼š $$ \\begin{aligned} s_1\u0026amp;=\u0026amp;a_1+a_2+a_3+a_4\\\\ s_2\u0026amp;=\u0026amp;a_2+a_3+a_4\\\\ s_3\u0026amp;=\u0026amp;a_3+a_4\\\\ s_4\u0026amp;=\u0026amp;a_4\\\\ \\end{aligned} $$ åˆ™è¯¥ \\(before=\\sum\\limits^n_{i=1}{s_i} = a_1+2a_2+3a_3+4a_4\\)ã€‚å‡å¦‚ \\(t=1\\)ï¼Œé‚£ä¹ˆæœ‰ï¼š $$ \\begin{aligned} s_1\u0026amp;=\u0026amp;a_1+a_2+a_3\\\\ s_2\u0026amp;=\u0026amp;a_2+a_3\\\\ s_3\u0026amp;=\u0026amp;a_3\\\\ s_4\u0026amp;=\u0026amp;\\\\ \\end{aligned} $$ æ­¤æ—¶ \\(after=\\sum\\limits^{n-t}_{i=1}{s_i} = a_1+2a_2+3a_3=before-4a_4\\)ã€‚\nè®¡ç®— \\(\\sum\\limits^n_{i=1}{s_i}\\) æ—¶ï¼Œæ¯æ¬¡ä»æœ«å°¾åˆ é™¤ \\(t\\) ä¸ªå…ƒç´ ï¼Œéƒ½ä¼šåˆ æ‰å¯¹åº”çš„ æƒé‡ \\(\\times\\) æ•°ã€‚\né‚£ä¹ˆæ¯æ¬¡æ“ä½œçš„æ—¶å€™ï¼Œåªéœ€è¦åœ¨æ€»çš„ \\(\\sum\\limits^n_{i=1}{s_i}\\) ä¸Šè¿›è¡Œå¢åˆ å°±å¯ä»¥äº†ã€‚\n3. ä»£ç  #\rC\u0026#43;\u0026#43;\rconstexpr int mod = 1000000007; void solve() { int q; std::cin \u0026gt;\u0026gt; q; i64 sum = 0; std::stack\u0026lt;i64\u0026gt; l; while (q--) { i64 t, v; std::cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; v; while (t--) { sum += mod; // é˜²æ­¢å‡çš„æ—¶å€™æˆä¸ºè´Ÿæ•° sum -= (l.top() * l.size()) % mod; sum %= mod; l.pop(); } l.push(v); sum += (v * l.size()) % mod; sum %= mod; std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } 4. æ€»ç»“ #\rè¿™ä¸ªé¢˜ä¸»è¦å¯¹æ¨¡è¿ç®—è¿›è¡Œäº†è€ƒå¯Ÿï¼Œæœ‰å‡ ä¸ªç‚¹éœ€è¦ç‰¹åˆ«æ³¨æ„ä¸€ä¸‹ï¼š\næ¨¡è¿ç®—ä¸­ï¼š\\((A\\pm* B)\\mod P=((A\\mod P)\\pm (B\\mod P))\\mod P\\) ç”±äºç¬¬ä¸€æ¡ç‰¹æ€§ï¼Œåœ¨ç¨‹åºçš„å‡æ³•çš„è¿‡ç¨‹ä¸­ä¼šå¯¹æ¯ä¸€é¡¹å…ƒç´ å–æ¨¡åå†å–æ¨¡ï¼Œæ‰€ä»¥åœ¨è®¡ç®—è¿‡ç¨‹ä¸­è¿­ä»£å™¨å¾ˆå®¹æ˜“åœ¨åšå‡æ³•çš„æ—¶å€™å˜ä¸ºè´Ÿæ•°ï¼Œæ­¤æ—¶éœ€è¦åœ¨å¯¹è¿­ä»£å™¨å–æ¨¡å‰å…ˆåŠ ä¸Šä¸€ä¸ªæ¨¡æ•°é˜²æ­¢æº¢å‡ºã€‚ ","date":"2024 July 26","externalUrl":null,"permalink":"/posts/24nowcodersummer/1/c/","section":"Posts","summary":"1.","title":"ã€2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥1ã€‘C","type":"posts"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/","section":"Tags","summary":"","title":"å‰ç¼€å’Œ","type":"tags"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E6%A8%A1%E8%BF%90%E7%AE%97/","section":"Tags","summary":"","title":"æ¨¡è¿ç®—","type":"tags"},{"content":"\r1. é¢˜ç›®ï¼ˆProblem A Enhancedï¼‰ #\rEnglish\rGiven two integers \\(n\\) and \\(m\\), among all the sequences containing \\(n\\) non-negative integers less than \\(2^m\\), you need to count the number of such sequences \\(A\\) that there exists two different non-empty subsequencesc of \\(A\\) in which the bitwise AND of the integers is \\(1\\).\nNote that a non-empty subsequence of a sequence \\(A\\) is a non-empty sequence that can be obtained by deleting zero or more elements from \\(A\\) and arranging the remaining elements in their original order. Two subsequences are different if they are composed of different locations in the original sequence.\nSince the answer may be very large, output it modulo a positive integer \\(q\\).\nThe bitwise AND of non-negative integers \\(A\\) and \\(B\\), \\(A\\) AND \\(B\\) is defined as follows:\nWhen \\(A\\) AND \\(B\\) is written in base two, the digit in the \\(2^d\\)\u0026rsquo;s place ( \\(d\\geq 0\\) ) is \\(1\\) if those of \\(A\\) and \\(B\\) are both \\(1\\), and \\(0\\) otherwise. For example, we have \\(4\\) AND \\(6\\) = \\(4\\) (in base two: \\(100\\) AND \\(110\\) = \\(100\\)).\nGenerally, the bitwise AND of \\(k\\) non-negative integers \\(p_1,ğ‘_2,\\dots,p_k\\) is defined as (\\(\\dots\\)((\\(p_1\\) AND \\(p_2\\)) AND \\(p_3\\)) AND \\(\\dots\\) AND \\(p_ğ‘˜\\)) and we can prove that this value does not depend on the order of \\(p_1,ğ‘_2,\\dots,p_k\\).\nInput\nThe only line contains three integers \\(n\\) (\\(1 \\le n \\le 5,000\\)), \\(m\\) (\\(1 \\le m \\le 5,000\\)) and \\(q\\) (\\(1 \\le q \\le 10^9\\)).\nOutput\nOutput a line containing an integer, denoting the answer.\n2. æ€è·¯ #\rè¿™æ˜¯ \\(A\\) é¢˜çš„åŠ å¼ºç‰ˆï¼Œ\\(A\\) é¢˜å‰åºå†…å®¹å‚è€ƒï¼š\nã€2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥1ã€‘A\r2024 July 26\u0026middot;488 å­—\u0026middot;3 åˆ†é’Ÿ\ræ•°å­¦å½’çº³æ³•\rç»„åˆæ•°\rå¿«é€Ÿå¹‚\ræ¨¡è¿ç®—\ræ­¤é¢˜å¯ä»¥ç®€åŒ–ä¸ºï¼š\\(A\\) é¢˜ä¸­çš„ç­”æ¡ˆ -ã€æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªå­åºåˆ— AND å’Œä¸º 1 ã€‘çš„æ•°é‡ã€‚\nå¯ä»¥æ ¹æ® \\(A\\) é¢˜çš„æ¨å¯¼è¿‡ç¨‹å‘ç°ï¼Œæ¯æ¬¡æˆ‘ä»¬é€‰æ‹© \\(k\\) ä¸ªæœ«å°¾å‡ä¸º \\(1\\) çš„æ•°ï¼Œå‰©ä¸‹çš„ \\(n - k\\) æ•°æœ«å°¾å‡ä¸º \\(0\\)ï¼Œé‚£ä¹ˆä»…æœ‰çš„è¿™ä¸ª AND å’Œä¸º \\(1\\) çš„å­åºåˆ—å¿…é¡»ä¸ºå½“å‰é€‰å®šçš„ \\(k\\) ä¸ªæ•°çš„å­åºåˆ—ã€‚ä½†æ˜¯è¿™ä¸ªå­åºåˆ—è¦æƒ³æ»¡è¶³å”¯ä¸€çš„æ¡ä»¶ï¼Œå°±å¿…é¡»ä¿®æ”¹ã€é™¤æœ«å°¾ä¸º \\(1\\)ï¼Œå…¶ä½™ \\(m - 1\\) ä½ä»»é€‰å« \\(0\\) çš„ \\(2^k-1\\) ç§é€‰æ‹©ã€‘çš„æ¡ä»¶ã€‚\nå‡å¦‚ \\(k=3\\)ï¼Œæœ€åä¸€ä½ä¸º \\(1\\)ï¼Œé‚£ä¹ˆä¸‹å¼ä¸­çš„æ‰€æœ‰çš„ \\(\\underline{\\bold{0}}\\) å‡ä¸ºæ‰€æœ‰é€‰ä¸­çš„ \\(k\\) ä¸ªæ•°ä¸­æ‰€åœ¨ä½å”¯ä¸€çš„ \\(0\\)ï¼ˆç§°ä¸ºç‰¹æ®Šä½ï¼‰ï¼š $$ \\begin{array}{c|ccc|c} \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\\\ \\hline p_1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \\\\ p_2 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \\\\ p_3 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \\\\ \\end{array} $$ å› æ­¤å¯ä»¥å‘ç°ï¼Œå½“é€‰å– \\(k\\) ä¸ªæ•°ä¸ºå­åºåˆ—çš„æ—¶å€™ï¼Œæˆ‘ä»¬è¦æ»¡è¶³è¿™äº›æ•°éƒ½è‡³å°‘åŒ…å«ä¸€ä¸ªç‰¹æ®Šä½ï¼Œå½“æ»¡è¶³ \\(1\\leq k\\leq m-1\\) çš„æ—¶å€™ï¼Œç¡®ä¿ä¸ä¼šæœ‰é‡å¤çš„ç‰¹æ®Šä½å‡ºç°ï¼š $$ \\begin{array}{c|ccccc|c} \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; \\dots \u0026amp; m-1 \u0026amp; m \\\\ \\hline p_1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \u0026amp; 1 \\\\ p_2 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \u0026amp; 1 \\\\ p_3 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; \\dots \u0026amp; 1 \u0026amp; 1 \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots\\\\ p_k \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \\end{array} $$ å½“åˆ é™¤è¿™äº›ç‰¹æ®Šä½çš„æ—¶å€™ï¼Œå°±ä¼šä½¿å¾—æŸä¸€ä½ä¸å«æœ‰ \\(0\\)ï¼Œä¸æ»¡è¶³ AND å’Œä¸º \\(1\\) çš„æ¡ä»¶ï¼Œç¡®ä¿äº†å”¯ä¸€æ€§ã€‚\nå‡å¦‚æ­¤æ—¶é€‰å–äº† \\(k-1\\) ä¸ªæ•°ï¼Œå½“åœ¨ä¸º \\(k\\) ä¸ªæ•°æ·»åŠ ç‰¹æ®Šä½çš„æ—¶å€™ï¼Œæœ‰ä»¥ä¸‹ä¸¤ç§æƒ…å†µï¼š\næ·»åŠ åˆ°æ–°é€‰æ‹©çš„æ•°çš„æŸä¸€ä½ä¸Šã€‚ æ·»åŠ åˆ°å·²é€‰æ‹©çš„ \\(k-1\\) ä¸­æŸä¸€ä¸ªæ•°çš„æŸä¸€ä½ä¸Š æˆ‘ä»¬é‡‡ç”¨åŠ¨æ€è§„åˆ’ï¼Œå‡è®¾é€‰æ‹© \\(k\\) ä¸ªæ•°ï¼Œæœ‰ \\(t\\) (\\(k\\leq t\\leq m-1\\)) ä¸ªç‰¹æ®Šä½çš„æ–¹æ¡ˆæ•°ä¸º \\(dp(k,t)\\)ï¼Œé‚£ä¹ˆçŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºï¼š $$ dp(k,t)=C^1_k\\cdot(dp(k-1,t-1) + dp(k,t-1)) $$ å³ç‰¹æ®Šä½è¦ä¹ˆåŠ åœ¨ \\(k-1\\) ä¸ªæ•°çš„åŸºç¡€ä¸Šæ–°åŠ çš„ä¸€ä¸ªæ•°ä¸Šï¼Œè¦ä¹ˆåŠ åœ¨å·²ç»å­˜åœ¨çš„ä¸€ä¸ªæ•°ä¸Šã€‚ç›´è§‚ä½“ç°ä¸ºå¦‚ä¸‹ä¸¤ç§æƒ…å†µï¼ˆçº¢è‰²ä¸ºå·²æœ‰çš„ç‰¹æ®Šä½ï¼Œè“è‰²ä¸ºæ–°åŠ çš„ç‰¹æ®Šä½ï¼‰ï¼š $$ \\begin{align*} \\begin{array}{c|cccccc|c} \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; \\dots \u0026amp; 6 \\\\ \\hline p_1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \\\\ p_2 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \\\\ p_3 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1\\\\ p_4 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{blue}{\\underline{\\bold{0}}} \u0026amp; \\dots \u0026amp; 1\\\\ \\end{array} \\hspace{1cm} \\begin{array}{c|cccccc|c} \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; \\dots \u0026amp; 5 \\\\ \\hline p_1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \\\\ p_2 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \\\\ p_3 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1\\\\ p_4 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; \\color{blue}{\\underline{\\bold{0}}} \u0026amp; \\dots \u0026amp; 1\\\\ \\end{array} \\end{align*} $$ ç”±äº \\(t\\) çš„èŒƒå›´ä¸º \\(k\\leq t\\leq m-1\\)ï¼Œç›¸å½“äºå°† \\(t\\) ä¸ªç‰¹æ®Šä½åˆ†ç»™ \\(k\\) ä¸ªæ•°ï¼Œæ¯ä¸ªæ•°è‡³å°‘å«æœ‰ä¸€ä¸ªç‰¹æ®Šä½ï¼Œç±»ä¼¼äºæ–¯ç‰¹æ—æ•°ï¼Œæ•…ä¹Ÿå¯ä»¥ç»“åˆæ–¯ç‰¹æ—æ•°çš„æ¨å¯¼è¿‡ç¨‹ç†è§£çŠ¶æ€è½¬ç§»æ–¹ç¨‹ã€‚\néœ€è¦æ³¨æ„çš„æ˜¯ï¼š\nå½“ \\(k=1\\) çš„æ—¶å€™ï¼Œå½“ä¸”ä»…å½“å­åºåˆ—ä¸º \\(1\\) çš„æ—¶å€™ï¼Œè¿™ä¸ªæ•°æ»¡è¶³æ¡ä»¶ï¼Œéœ€è¦å•ç‹¬è®¡ç®—ï¼š\\(C_n^1\\cdot2^{(n-1)\\cdot(m-1)}\\) å½“ \\(k\u0026gt;1\\) çš„æ—¶å€™ï¼Œæˆ‘ä»¬é€‰æ‹©å…¶ä¸­ \\(t\\) ä½ï¼Œå…¶ä»–ä½ \\(m-1-t\\) ä¾ç„¶å¯ä»¥ä»»é€‰ï¼Œä½†æ˜¯æ³¨æ„ä¸èƒ½åªå«æœ‰ä¸€ä¸ª \\(0\\) ï¼ˆé˜²æ­¢æˆä¸ºç‰¹æ®Šä½ï¼‰ï¼Œæœ‰ k ç§æƒ…å†µï¼ˆåªæœ‰ä¸€ä½æœ‰ \\(0\\)ï¼‰ï¼Œå†å‡å»å…¨ä¸º \\(1\\) çš„æƒ…å†µï¼š\\((2^k-k-1)^{{m-1-t}}\\) äºæ˜¯æœ€ç»ˆç»“æœä¸ºï¼š $$ \\begin{align*} ans \u0026amp;= \\sum\\limits_{k=1}^n(C_n^k \\cdot(2^k-1)^{m-1}\\cdot2^{(m-1)\\cdot(n-k)})-\\sum\\limits_{k=2}^n(C_n^k\\cdot2^{(m-1)\\cdot(n-k)}\\cdot\\sum\\limits_{t=k}^{m-1}(C_{m-1}^t\\cdot dp(k,t)\\cdot(2^k-k-1)^{m-1-t}))+C_n^1\\cdot2^{(n-1)\\cdot(m-1)}\\\\ \u0026amp;=\\sum\\limits_{k=2}^n(C_n^k\\cdot2^{(m-1)\\cdot(n-k)}\\cdot((2^k-1)^{m-1}-\\sum\\limits_{t=k}^{m-1}(C_{m-1}^t\\cdot dp(k,t)\\cdot(2^k-k-1)^{m-1-t}))) \\end{align*} $$\n3. ä»£ç  #\rC\u0026#43;\u0026#43;\ri64 binpow(i64 a, i64 b, i64 mod) { a %= mod; i64 ans = 1; while (b \u0026gt; 0) { if (b \u0026amp; 1) { ans *= a; ans %= mod; } a *= a; a %= mod; b \u0026gt;\u0026gt;= 1; } return ans; } void solve() { int n, m; i64 q; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; std::vector\u0026lt;i64\u0026gt; a(n + 1), c(n + 1), ct(m); a[0] = c[0] = ct[0] = 1; for (int k = 1; k \u0026lt;= n; k++) { a[k] = a[k - 1] \u0026lt;\u0026lt; 1; a[k] %= q; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = i; j \u0026gt; 0; j--) { c[j] = (c[j] + c[j - 1]) % q; } } for (int i = 1; i \u0026lt;= m - 1; i++) { for (int j = i; j \u0026gt; 0; j--) { ct[j] = (ct[j] + ct[j - 1]) % q; } } std::vector\u0026lt;std::vector\u0026lt;i64\u0026gt;\u0026gt; dp(n + 1, std::vector\u0026lt;i64\u0026gt;(m)); dp[0][0] = 1; for (int k = 1; k \u0026lt;= n; k++) { for (int t = 1; t \u0026lt;= m - 1; t++) { dp[k][t] = ((dp[k][t - 1] + dp[k - 1][t - 1]) % q * k) % q; } } i64 ans = 0; for (int k = 2; k \u0026lt;= n; k++) { i64 tmp1 = binpow(a[k] - 1, m - 1, q); i64 tmp2 = 0, tp = (a[k] + q - k - 1) % q, tmpt = 1; for (int t = m - 1; t \u0026gt;= k; t--) { tmp2 += ((ct[t] * dp[k][t]) % q * tmpt) % q; tmp2 %= q; tmpt *= tp; tmpt %= q; } i64 tmp3 = binpow(a[n - k], m - 1, q); ans += (((tmp1 + q - tmp2) % q * tmp3) % q * c[k]) % q; ans %= q; } std::cout \u0026lt;\u0026lt; ans; } 4. æ€»ç»“ #\ræœ¬é¢˜æ˜¯ \\(A\\) é¢˜çš„åŠ å¼ºç‰ˆï¼Œåœ¨ \\(A\\) çš„åŸºç¡€ä¸Šå¼•å…¥äº†æ–¯ç‰¹æ—æ•°çš„æ€æƒ³å¯¹ã€æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªå­åºåˆ— AND å’Œä¸º 1 ã€‘è¿›è¡Œäº†è§£é‡Šå’Œæ¨å¯¼ï¼Œæ˜¯å¯¹äºè§„å¾‹æ€»ç»“å’Œç»„åˆæ•°å­¦çš„å¾ˆå¥½çš„ç»ƒä¹ ã€‚\n","date":"2024 July 26","externalUrl":null,"permalink":"/posts/24nowcodersummer/1/b/","section":"Posts","summary":"1.","title":"ã€2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥1ã€‘B","type":"posts"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/","section":"Tags","summary":"","title":"æ–¯ç‰¹æ—æ•°","type":"tags"},{"content":"\r1. é¢˜ç›® #\rEnglish\rGiven two integers \\(n\\) and \\(m\\), among all the sequences containing \\(n\\) non-negative integers less than \\(2^m\\), you need to count the number of such sequences \\(A\\) that there exists a non-empty subsequence of \\(A\\) in which the bitwise AND of the integers is \\(1\\).\nNote that a non-empty subsequence of a sequence \\(A\\) is a non-empty sequence that can be obtained by deleting zero or more elements from \\(A\\) and arranging the remaining elements in their original order.\nSince the answer may be very large, output it modulo a positive integer \\(q\\).\nThe bitwise AND of non-negative integers \\(A\\) and \\(B\\), \\(A\\) AND \\(B\\) is defined as follows:\nWhen \\(A\\) AND \\(B\\) is written in base two, the digit in the \\(2^d\\)\u0026rsquo;s place ( \\(d\\geq 0\\) ) is \\(1\\) if those of \\(A\\) and \\(B\\) are both \\(1\\), and \\(0\\) otherwise. For example, we have \\(4\\) AND \\(6\\) = \\(4\\) (in base two: \\(100\\) AND \\(110\\) = \\(100\\)).\nGenerally, the bitwise AND of \\(k\\) non-negative integers \\(p_1,ğ‘_2,\\dots,p_k\\) is defined as (\\(\\dots\\)((\\(p_1\\) AND \\(p_2\\)) AND \\(p_3\\)) AND \\(\\dots\\) AND \\(p_ğ‘˜\\)) and we can prove that this value does not depend on the order of \\(p_1,ğ‘_2,\\dots,p_k\\).\nInput\nThe only line contains three integers \\(n\\) (\\(1 \\le n \\le 5,000\\)), \\(m\\) (\\(1 \\le m \\le 5,000\\)) and \\(q\\) (\\(1 \\le q \\le 10^9\\)).\nOutput\nOutput a line containing an integer, denoting the answer.\n2. æ€è·¯ #\rè¿™æ˜¯ä¸€é“æ‰¾è§„å¾‹çš„é¢˜ã€‚é€šè¿‡è§‚å¯Ÿæ ·ä¾‹2 3 998244353 -\u0026gt; 17å¯ä»¥å‘ç°å¦‚ä¸‹çš„è®¡ç®—è¿‡ç¨‹ï¼š\né€‰æ‹©å«æœ‰ä¸€ä¸ªæ•°çš„å­åºåˆ—ï¼Œåˆ™é€‰æ‹©çš„è¿™ä¸ªå­åºåˆ—å¿…é¡»ä¸º 001ã€‚å¦å¤–ä¸€ä¸ªæ•°çš„å„ä½ä»»é€‰ï¼Œæœ‰ \\(2^3\\) ç§æ–¹æ¡ˆã€‚ç”±äºå­åºåˆ—æŒ‰ç…§ä¸åŒé¡ºåºæ’åˆ—ç®—ä½œä¸åŒçš„å­åºåˆ—ï¼Œé‚£å°†001æ”¾åœ¨å¦ä¸€ä¸ªæ•°çš„ä½ç½®ä¸ºå¦ä¸€ç§æƒ…å†µã€‚æ­¤æ—¶è¿˜éœ€è¦å‡å»[001, 001]çš„æƒ…å†µï¼Œå‡ºç°äº†ä¸¤æ¬¡ã€‚æ•…æ­¤æ—¶çš„ç»“æœä¸º \\(2^3+2^3 - 1=15\\)ã€‚ é€‰æ‹©å«æœ‰ä¸¤ä¸ªæ•°çš„å­åºåˆ—ï¼Œåˆ™é€‰æ‹©çš„ä¸¤ä¸ªå­åºåˆ—çš„æœ«å°¾é‚£ä¸€ä½å¿…é¡»å‡ä¸º \\(1\\)ã€‚ç”±äºåˆšåˆšå·²ç»è®¡ç®—è¿‡äº†å…¶ä¸­ä¸€ä½ä¸º001çš„æƒ…å†µï¼Œå†åŠ ä¸Šä¸¤ä¸ªæœ«å°¾ä¸º \\(1\\) ä½†æ˜¯ä¸ä¸º001çš„æƒ…å†µï¼š[101, 011]å’Œ[011, 101]ã€‚æ•…æ­¤æ—¶çš„ç»“æœä¸º \\(15+2=17\\)ã€‚ å°†ä¸Šé¢çš„è¿‡ç¨‹è¿›è¡Œæ¨å¹¿æˆ‘ä»¬å¯ä»¥å‘ç°æœ‰å¦‚ä¸‹çš„è§„å¾‹ï¼š\né€‰æ‹©å…¶ä¸­çš„ \\(k\\) ä¸ªæ•°ï¼Œä½¿å¾—è¿™ \\(k\\) ä¸ªæ•°çš„æœ«å°¾ä¸€ä½å‡ä¸º \\(1\\)ï¼Œè€Œå…¶ä»–ä½ä¸Šçš„æ•°ï¼Œä¿è¯è‡³å°‘å‡ºå‡ºç°ä¸€ä¸ª \\(0\\)ã€‚æˆ‘ä»¬å¯ä»¥çŸ¥é“ç¬¬ \\(i\\) ä½çš„æ•°å­—èŒƒå›´ä¸º[000...0~111...1]ï¼Œå½“æˆ‘ä»¬å»é™¤æœ€åä¸€ä¸ªå…¨ä¸º \\(1\\) çš„æ•°ï¼Œå…¶ä»–çš„æ•°å‡æ»¡è¶³å‡ºç°è‡³å°‘ä¸€ä¸ª \\(0\\)ã€‚æ­¤æ—¶çš„èŒƒå›´ä¸º \\(C_n^k \\cdot(2^k-1)^{m-1}\\)ï¼Œå³ä» \\(n\\) ä¸ªæ•°ä¸­ä»»é€‰ \\(k\\) ä¸ªæ•°å¹¶å¯¹é™¤äº†æœ€åä¸€ä½çš„å…¶ä½™ \\(m-1\\) ä½éƒ½è·å–äº† \\(2^k-1\\) ç§ç»“æœã€‚ ç„¶åå¯¹äºå‰©ä¸‹çš„ \\(n-k\\) ä¸ªæ•°ï¼Œä»»æ„é€‰æ‹©æ¯ä¸€ä½ä¸Šçš„ç»“æœï¼Œä¸ºäº†ä¿è¯ä¸ä¼šé‡å¤è®¡ç®—ï¼Œè®©å‰©ä¸‹çš„ \\(n-k\\) ä¸ªæ•°çš„æœ€åä¸€ä½å‡ä¸º \\(0\\)ã€‚æ­¤æ—¶çš„èŒƒå›´ä¸º \\((2^{m-1})^{n-k}=2^{(m-1)\\cdot(n-k)}\\)ï¼Œå³å¯¹æ¯ä¸€ä¸ªæ•°é€‰å®šæœ€åä¸€ä½ä¸º \\(0\\)ï¼Œå…¶ä½™ä½ç½®ä»»é€‰ã€‚ äºæ˜¯æœ€ç»ˆçš„ç»“æœä¸ºï¼š $$ \\sum\\limits_{k=1}^n(C_n^k \\cdot(2^k-1)^{m-1}\\cdot2^{(m-1)\\cdot(n-k)}) $$\n3. ä»£ç  #\rC\u0026#43;\u0026#43;\ri64 binpow(i64 a, i64 b, i64 mod) // å¿«é€Ÿå¹‚ { a %= mod; i64 ans = 1; while (b \u0026gt; 0) { if (b \u0026amp; 1) { ans = (ans * a) % mod; } a = (a * a) % mod; b \u0026gt;\u0026gt;= 1; } return ans; } void solve() { int n, m; i64 q; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; std::vector\u0026lt;i64\u0026gt; a(n + 1), c(n + 1); a[0] = c[0] = 1; for (int k = 1; k \u0026lt;= n; k++) { a[k] = a[k - 1] \u0026lt;\u0026lt; 1; a[k] %= q; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = i; j \u0026gt; 0; j--) { c[j] = (c[j] + c[j - 1]) % q; } } i64 ans = 0; for (int k = 1; k \u0026lt;= n; k++) { i64 tmp1 = binpow(a[k] - 1, m - 1, q); i64 tmp2 = binpow(a[n - k], m - 1, q); ans += ((tmp1 * tmp2) % q * c[k]) % q; ans %= q; } std::cout \u0026lt;\u0026lt; ans; } 4. æ€»ç»“ #\ræœ¬é¢˜ä¸»è¦æ˜¯è€ƒå¯Ÿæ‰¾è§„å¾‹çš„æŠ€å·§ï¼Œé€šè¿‡æ•°å­¦å½’çº³æ³•å¯¹æ ·ä¾‹çš„æ¨å¯¼è¿‡ç¨‹è¿›è¡Œæ€»ç»“ï¼Œç„¶åæ¨å¯¼å‡ºè®¡ç®—å…¬å¼ã€‚\næ­¤å¤–ï¼Œæœ¬é¢˜è¿˜æœ‰å‡ ä¸ªå°çš„çŸ¥è¯†ç‚¹ï¼š\nç»„åˆæ•°çš„è®¡ç®—ï¼Œé€šè¿‡å‹ç¼©åˆ°ä¸€ç»´å‡å°‘ç©ºé—´çš„ä½¿ç”¨ã€‚ å–æ¨¡è¿ç®—çš„æŠ€å·§ã€‚ ç”¨å¿«é€Ÿå¹‚åŠ å¿«å¹‚çš„è¿ç®—ã€‚ æ€»ä¹‹è¿™é“é¢˜è€ƒéªŒé€‰æ‰‹åœ¨èµ›åœºä¸Šæ€»ç»“è§„å¾‹çš„èƒ½åŠ›å’Œç»„åˆæ•°å­¦ä»¥åŠå…¶ä»–çš„åŸºæœ¬åŠŸã€‚\n","date":"2024 July 26","externalUrl":null,"permalink":"/posts/24nowcodersummer/1/a/","section":"Posts","summary":"1.","title":"ã€2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥1ã€‘A","type":"posts"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/","section":"Tags","summary":"","title":"å¿«é€Ÿå¹‚","type":"tags"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95/","section":"Tags","summary":"","title":"æ•°å­¦å½’çº³æ³•","type":"tags"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E7%BB%84%E5%90%88%E6%95%B0/","section":"Tags","summary":"","title":"ç»„åˆæ•°","type":"tags"},{"content":"","date":"26 July 2024","externalUrl":null,"permalink":"/en/about/","section":"OrangeTree","summary":"","title":"About","type":"page"},{"content":"","date":"26 July 2024","externalUrl":null,"permalink":"/en/","section":"OrangeTree","summary":"","title":"OrangeTree","type":"page"},{"content":"Hi there! I\u0026rsquo;m building my site in Chinese, wish to meet you one day.\nCialloï½(âˆ ãƒ»Ï‰\u0026lt; )âŒ’â˜†\n","date":"26 July 2024","externalUrl":null,"permalink":"/en/posts/building_my_site/building_my_site/","section":"Posts","summary":"Hi there!","title":"Building My Site","type":"posts"},{"content":"","date":"26 July 2024","externalUrl":null,"permalink":"/en/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]