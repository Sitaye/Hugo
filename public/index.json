


[{"content":"","date":"2024 August 30","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2024 August 30","externalUrl":null,"permalink":"/","section":"OrangeTree","summary":"","title":"OrangeTree","type":"page"},{"content":"","date":"2024 August 30","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"\r三元环计数是图论中一个比较重要的问题，用于求解无向图中三元环的个数。\n三元环指的是简单图 \\(G\\) 中的一个无序三元组 \\((u,v,w)\\)，满足存在三条边连接 \\(u,v,w\\) 三个点。\n三元环可以看作某种意义上的等价关系，即满足自反性、对称性和传递性，如果考虑传递性，则每个三元环的三条边均看作有向重边，在代码实现上如果三种传递性都要验证，时间复杂度会很高。\n因此我们可以考虑将三元环的无向图转换为有向图，这样只需要验证一种关系的传递性即可。我们假设：\n有向边从度数小的边指向度数大的边 度数相同，有向边从下标小的边指向下标大的边 很容易证明证明没有环的存在，因为如果存在环，必定会出现度数大的指向度数小的边的情况（环的首尾）。此时的图为一张有向无环图（DAG）。\n因此将无向图转换为有单向边的有向无环图，每次遍历 \\(u\\) 的相邻点 \\(v\\)，然后验证与 \\(v\\) 的相邻点 \\(w\\) 是否存在一条有向边即可。此时 \\(w\\) 也作为 \\(u\\) 的相邻点存在，遍历 \\(u\\) 的相邻点时判断一下就可以了。\n1. 代码 #\rC\u0026#43;\u0026#43;\rvoid solve() { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::vector\u0026lt;int\u0026gt; degree(n + 1), g[n + 1]; std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; op(m + 1); for (int i = 1; i \u0026lt;= m; i++) { int u, v; std::cin\u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; if (u \u0026gt; v) { std::swap(u, v); } op[i] = {u, v}; degree[u]++, degree[v]++; } for (int i = 1; i \u0026lt;= m; i++) { auto \u0026amp;[u, v] = op[i]; if (degree[u] \u0026gt; degree[v]) { std::swap(u, v); } g[u].push_back(v); } int num = 0; std::vector\u0026lt;int\u0026gt; vis(n + 1); for (int i = 1; i \u0026lt;= n; i++) { for (auto \u0026amp;j : g[i]) { vis[j] = 1; } for (auto \u0026amp;j : g[i]) { for (auto \u0026amp;k : g[j]) { if (vis[k]) { num++; } } } for (auto \u0026amp;j : g[i]) { vis[j] = 0; } } std::cout \u0026lt;\u0026lt; num; } 2. 时间复杂度 #\r由于将每条无向边都转换为了有向边，导致每个点的度数为不超过 \\(\\sqrt{m}\\)，因此遍历总的时间复杂度为 \\(O(m\\log m)\\)。\n","date":"2024 August 30","externalUrl":null,"permalink":"/posts/algorithm/graphtheory/triangle/","section":"Posts","summary":"三元环计数是图论中一个比较重要的问题，用于求解无向图中三元环的个数。","title":"三元环计数","type":"posts"},{"content":"","date":"2024 August 30","externalUrl":null,"permalink":"/categories/%E7%AE%97%E6%B3%95/","section":"Categories","summary":"","title":"算法","type":"categories"},{"content":"","date":"2024 August 30","externalUrl":null,"permalink":"/categories/%E5%9B%BE%E8%AE%BA/","section":"Categories","summary":"","title":"图论","type":"categories"},{"content":"\r并查集（DSU）是一种负责合并、查询的集合，用于判断元素之间的所属关系。\n并查集的核心思想就是对每个元素都建立一个标记，来表示所属集合的一个代表元素。\n假如我们用f[i]来表示第 \\(i\\) 个元素的代表元素（或者是 Father ）。初始化可以将所有元素的代表元素设为自己，即：f[i] = i。\n1. 查询 #\r1. 1 一般查询 #\r查询某个元素属于哪一个集合，即查询这个元素的代表元素是哪一个。\nint find(int x) { return f[x] == x ? x : find(f[x]); } 由于代表元素的代表元素即为它本身，故很容易得到上述的代码。\n1. 2 路径压缩查询 #\r并查集的本质是一种树，通过这种方法得到的树的深度会很大，所以我们可以对树进行路径压缩，使得集合中每个元素的代表元素都是整个集合的代表元素。\nint find(int x) { return f[x] == x ? x : f[x] = find(f[x]); } 2. 合并 #\r2. 1 一般合并 #\r将两个集合合并，其实就是将两个集合的代表元素更新一下，使得其中一个集合的代表元素是另一个集合代表元素的代表元素。\nvoid merge(int x, int y) { f[find(x)] = find(y); } 2. 2 启发式合并（按秩合并） #\r一般合并的问题在于可能会影响未来操作的复杂度，比如深度加深等等问题。所以最好的合并方式就是将深度较小（或元素少）的集合合并到另一个集合去。\n因此我们需要一个size[i]数组来记录每个元素所在集合的元素个数。\nvoid merge(int x, int y) { int fx = find(x), fy = find(y); if (size[fx] \u0026gt; size[fy]) { std::swap(fx, fy); } f[fx] = fy; size[fy] += size[fx]; } 3. 结构体 #\r将上面的函数可以统一为一个结构体的形式便于并查集的生成与操作。\nstruct DSU { std::vector\u0026lt;int\u0026gt; f, sz; DSU(int n) : f(n), sz(n, 1) { std::iota(f.begin(), f.end(), 0); } int find(int x) { return f[x] == x ? x : f[x] = find(f[x]); } bool merge(int x, int y) { int fx = find(x), fy = find(y); if (fx == fy) { return false; } if (sz[fx] \u0026gt; sz[fy]) { std::swap(fx, fy); } f[fx] = fy; sz[fy] += sz[fx]; return true; } bool same(int x, int y) { return find(x) == find(y); } }; 4. 时间复杂度 #\r并查集的时间复杂度取决于实现方式：\n无优化：\\(O(n)\\)\n仅路径压缩/按秩合并：\\(O(log(n))\\)\n路径压缩 + 按秩合并：\\(O(\\alpha(n))\\)，其中 \\(\\alpha(n)\\) 为 Ackermann 函数的反函数\nAckermann 函数\rAckermann 函数 \\(A(n,m)\\)定义为：\n\\(A(n,m)=\\begin{cases}m+1\u0026amp;\\texttt{if}\\ n=m\\\\A(n-1, 1)\u0026amp;\\texttt{if}\\ n\u0026gt;0\\ \\texttt{and}\\ m=0\\\\A(n-1,A(n,m-1))\u0026amp;\\texttt{otherwise}\\end{cases}\\)\n","date":"2024 August 26","externalUrl":null,"permalink":"/posts/data_structure/dsu/","section":"Posts","summary":"并查集（DSU）是一种负责合并、查询的集合，用于判断元素之间的所属关系。","title":"并查集","type":"posts"},{"content":"","date":"2024 August 26","externalUrl":null,"permalink":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"数据结构","type":"categories"},{"content":"\r最小生成树（MST）是连通加权无向图中权重最小的生成树。\n求最小生成树的算法主要有两个：Kruskal 和 Prim\n1. Kruskal #\rKruskal 主要用于稀疏图的最小生成树的求解。\n算法的核心是选边：每次贪心地选择当前边集中选择权重最小的、且不构成回路的边。\n算法的实现是并查集，通过维护一个最小权重的边的并查集来实现最小生成树。\n并查集可以参考：\n并查集\r2024 August 26\u0026middot;213 字\u0026middot;1 分钟\r数据结构\r并查集（DSU）是一种负责合并、查询的集合，用于判断元素之间的所属关系。\rKruskal 动图解释。来源：OI-Wiki\r1. 1 代码 #\rC\u0026#43;\u0026#43;\rstruct DSU { std::vector\u0026lt;int\u0026gt; f, sz; DSU(int n) : f(n), sz(n, 1) { std::iota(f.begin(), f.end(), 0); } int find(int x) { return f[x] == x ? f[x] : f[x] = find(f[x]); } bool merge(int x, int y) { int fx = find(x), fy = find(y); if (fx == fy) { return false; } if (sz[fx] \u0026gt; sz[fy]) { std::swap(fx, fy); } f[fx] = fy; sz[fy] += sz[fx]; return true; } bool same(int x, int y) { return find(x) == find(y); } }; void solve() { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::vector\u0026lt;std::array\u0026lt;int, 3\u0026gt;\u0026gt; l; DSU node(n + 1); for (int i = 0; i \u0026lt; m; i++) { int u, v, w; std::cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; l.push_back({w, u, v}); } std::sort(l.begin(), l.end()); int sum = 0, num = 1; for (auto [w, u, v] : l) { if (node.merge(u, v)) { sum += w; num ++; } if (num == n) { break; } } if (num == n) { std::cout \u0026lt;\u0026lt; sum; } else { std::cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34;; } } 可以看出，我们按照边权的大小对边进行排序，然后遍历边。判断一条边是否能加入到最小生成树中（即不成回路）的依据是边的两个顶点是否在同一个并查集里面。\n1. 2 时间复杂度 #\rKruskal 的时间复杂度为 \\(O(mlog(m))\\)，即遍历边以及维护并查集的时间复杂度。\n2. Prim #\rPrim 主要用于稠密图的最小生成树的求解。\n算法的核心是选点：随机选择一个点作为起点，每次贪心地选择当前点相邻边集中选择权重最小的、且不构成回路的边。\n算法的实现是DFS，即逐步选择每一个点。\nPrim 动图解释。来源：OI-Wiki\r1. 1 代码 #\rC\u0026#43;\u0026#43;\rstruct cmp { bool operator()(const std::pair\u0026lt;int, int\u0026gt; x, const std::pair\u0026lt;int, int\u0026gt; y) { return x.second \u0026gt; y.second; } }; void solve() { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; g[n + 1]; for (int i = 0; i \u0026lt; m; i++) { int x, y, z; std::cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; g[x].push_back({y, z}); g[y].push_back({x, z}); } std::priority_queue\u0026lt;std::pair\u0026lt;int, int\u0026gt;, std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt;, cmp\u0026gt; l; std::vector\u0026lt;int\u0026gt; dis(n + 1, 0x3f3f3f3f); std::vector\u0026lt;bool\u0026gt; vis(n + 1, false); dis[1] = 0, l.push({1, 0}); int sum = 0, num = 0; while (!l.empty()) { if (num == n) { break; } auto [u, d] = l.top(); l.pop(); if (!vis[u]) { vis[u] = true; num ++; sum += d; for (auto [v, w] : g[u]) { if (!vis[v] \u0026amp;\u0026amp; w \u0026lt; dis[v]) { dis[v] = w, l.push({v, w}); } } } } if (num == n) { std::cout \u0026lt;\u0026lt; sum; } else { std::cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34;; } } 我们使用堆优化的方式实现 Prim ，其实现方式类似于 Dijkstra 逐步更新周边点的距离从而找到路径最近的点。\n每次都将周围点到当前点的距离都更新一次，然后压入堆中进行选择。由于每次都会只选择堆顶元素加入到 MST 中，后续更新当前点的周围点距离的时候，可能某些点在之前已经更新过了，那么再次加入堆中更有可能出现到堆顶附近，而之前的那次更新自然不会出现到这次更新之上了。\n1. 2 时间复杂度 #\rPrim 的时间复杂度为 \\(O((n+m)log(n))\\)，即遍历边维护检查堆以及顶点检查的时间复杂度之和。\n​\n","date":"2024 August 23","externalUrl":null,"permalink":"/posts/algorithm/graphtheory/mst/","section":"Posts","summary":"最小生成树（MST）是连通加权无向图中权重最小的生成树。","title":"最小生成树","type":"posts"},{"content":"\r1. 题目 #\rEnglish\rThere are \\(2\\cdot n\\) cards arranged in a row, with each card numbered from \\(1\\) to \\(n\\) having exactly \\(2\\) copies.\nEach time, Red can choose a subarray of consecutive cards (at least \\(2\\) cards) to remove from the deck. The chosen subarray must satisfy that the first and last cards have the same number. The score for this operation is: the number of cards multiplied by the number on the first card.\nNow Red wants to know what is the maximum value of the final score?\nInput\nThe first line contains a positive integer \\(n(1\\leq n \\leq 3\\times 10^3)\\) — the number of card types.\nThe second line contains \\(2\\cdot n\\) positive integers \\(a_i(1\\leq a_i \\leq n)\\) — the number on each card from left to right.\nOutput\nA single positive integer — representing the maximum final score.\n简体中文（大意）\r一个序列包含 \\(1\\) ~ \\(n\\)，每个数出现两次。每次选择删掉首尾两个数相同的区间，得到的值为 区间元素个数 \\(\\times\\) 首/尾的数，并将所得到的值求和。求和的最大值。\r2. 思路 #\r这很显然是一个区间 DP 问题。很容易想到，区间和区间之间可能会出现包含关系，所以一个大的区间可以由所包含的小的区间转移得到。\n虽然区间之间可能会有包含关系，但是最后也有可能出现单个没有配对的数。因此我们在原题的基础上添加一个条件：在首尾添加两个 \\(0\\)。问题就变成了将所有数都删掉所能得到的最大值是多少，因为最后假如还剩下了无法配对的数，虽然不会产生贡献，但是可以归纳到 \\(0\\) 的区间里面。这样所有的数都能通过计算除去。\n假如一个大的区间包含了很多完整的小的区间，那么状态转移就可以变为：每个小的区间的最大值 + 单独出现的值产生的贡献。\n因此对于这个区间的状态转移方程为： $$ dp(i)=\\max\\begin{cases}\\ dp(i-1) + x\\\\ dp(l(a(i)) - l(x) - 1) + ans(a(i)) \\texttt{ if l(x) \u0026lt; l(a(i)) and r(a(i)) = i + l(x)}\\end{cases} $$ 其中当前区间的首尾元素为 \\(x\\)，考虑区间的前 \\(i\\) 个元素，对于当前这个数 \\(a(i)\\)，\\(l(i)\\) 为第一次出现的下标，\\(r(i)\\) 为最后一次出现的下标，有两种操作策略：\n选择 \\(a(i)\\) 和 \\(x\\) 的区间一起删掉，则贡献为 \\(dp(i-1)+x\\) 如果 \\(a(i)\\) 所代表的完整区间在 \\(x\\) 区间内，则优先考虑这个代表区间，此时的答案为除了 \\(a(i)\\) 区间的最大值 \\(dp(l(i)-1)\\) 加上 \\(a(i)\\) 区间的最大值 \\(ans(a(i))\\)。最后让 \\(ans(x)\\) 等于 \\(dp(r(x))\\) 即可。 求一下最大值就可以了。很显然最终的答案为 \\(ans(0)\\)。\n3. 代码 #\rC\u0026#43;\u0026#43;\rvoid solve() { int n, m; std::cin \u0026gt;\u0026gt; n; m = (n \u0026lt;\u0026lt; 1); std::vector\u0026lt;int\u0026gt; a(m + 2); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; p(n + 1); a[0] = 0, a[m + 1] = 0; p[0] = {0, m + 1}; for (int i = 1; i \u0026lt;= m; i++) { std::cin \u0026gt;\u0026gt; a[i]; p[a[i]].push_back(i); } std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; g(n + 1); for (int i = 1; i \u0026lt;= n; i++) { int l = p[i][0], r = p[i][1]; g[i] = {r - l + 1, i}; } g[0] = {m + 2, 0}; std::sort(g.begin(), g.end()); std::vector\u0026lt;int\u0026gt; ans(n + 1); for (int i = 0; i \u0026lt;= n; i++) { auto \u0026amp;[len, now] = g[i]; int l = p[now][0], r = p[now][1]; std::vector\u0026lt;int\u0026gt; dp(len); dp[0] = now; for (int j = 1; j \u0026lt; len; j++) { dp[j] = dp[j - 1] + now; int lx = p[a[j + l]][0], rx = p[a[j + l]][1]; if (lx \u0026gt; l \u0026amp;\u0026amp; rx == j + l) { dp[j] = std::max(dp[j], dp[lx - l - 1] + ans[a[j + l]]); } } ans[now] = dp[len - 1]; } std::cout \u0026lt;\u0026lt; ans[0]; } 4. 总结 #\r这个是一个从区间 DP 变化而来的题目，就是将子区间的和转移为父亲区间的和来达到动态规划的目的。\n","date":"2024 July 31","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/2/i/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营2】I","type":"posts"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/categories/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5/","section":"Categories","summary":"","title":"2024牛客暑期多校训练营","type":"categories"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/categories/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A52/","section":"Categories","summary":"","title":"2024牛客暑期多校训练营2","type":"categories"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/series/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A52/","section":"Series","summary":"","title":"2024牛客暑期多校训练营2","type":"series"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/categories/%E6%AF%94%E8%B5%9B/","section":"Categories","summary":"","title":"比赛","type":"categories"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划","type":"tags"},{"content":"\r1. 题目 #\rEnglish\rRed stands at the coordinate \\((0,0)\\) of the Cartesian coordinate system. She has a string of instructions: up, down, left, right (where right increases the x-coordinate by \\(1\\), and up increases the y-coordinate by \\(1\\)).\nNow Red wants to select a continuous substring of instructions and execute them. Red hopes that the final execution of the instructions can pass through the coordinate \\((x,y)\\). She wants to know how many selection options there are.\nInput\nThe first line contains three integers \\(n\\), \\(x\\), and \\(y\\) (\\(1 \\leq n \\leq 2 \\times 10^5, -10^5 \\leq x, y \\leq 10^5)\\), — the length of the instruction string and the coordinates Red hopes to pass through.\nThe second line contains a string of length nnn, consisting of the characters \\(W\\), \\(S\\), \\(A\\), and \\(D\\). — the four directions: up, down, left, and right, respectively.\nOutput\nOutput one integer representing the number of selection options for the continuous substring.\n简体中文（大意）\r给定字符串，表示一串移动指令，假如起点为 \\((0,0)\\)，求能到达 \\((x,y)\\) 的子串的个数。\r2. 思路 #\r由于上下左右移动对应的是坐标的变化，故可以将字符串表示为对应的坐标变化，问题便转化成为：寻找坐标变化为 \\((x,y)\\) 的区间的个数。\n由于只需要路径穿过了目标点就可以，故对于所有终点在 \\((x,y)\\) 的字符串以及以该字符串为前缀的后续所有字符串都满足条件。\n所以我们可以使用前缀和保存区间的信息，然后稍作差分计算符合条件的区间的个数。\n3. 代码 #\rC\u0026#43;\u0026#43;\rvoid solve() { int n, x, y; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; std::string s; std::cin \u0026gt;\u0026gt; s; if (x == 0 \u0026amp;\u0026amp; y == 0) { std::cout \u0026lt;\u0026lt; (n * (n + 1) \u0026gt;\u0026gt; 1); return; } std::vector\u0026lt;std::pair\u0026lt;i64, i64\u0026gt;\u0026gt; l(n + 1, {0, 0}); for (int i = 0; i \u0026lt; n; i++) { auto [x0, y0] = l[i]; if (s[i] == \u0026#39;A\u0026#39;) { x0--; } else if (s[i] == \u0026#39;D\u0026#39;) { x0++; } else if (s[i] == \u0026#39;W\u0026#39;) { y0++; } else { y0--; } l[i + 1] = {x0, y0}; } i64 num = 0; std::map\u0026lt;std::pair\u0026lt;i64, i64\u0026gt;, std::vector\u0026lt;int\u0026gt;\u0026gt; ref; for (int i = n; i \u0026gt;= 0; i--) { auto [x0, y0] = l[i]; if (!ref[{x + x0, y + y0}].empty()) { int min = *ref[{x + x0, y + y0}].begin(); num += n - min + 1; } ref[l[i]].push_back(i); std::sort(ref[l[i]].begin(), ref[l[i]].end()); } std::cout \u0026lt;\u0026lt; num; } 4. 总结 #\r从代码中发现，可以使用 map 对遍历进行优化。由于正向遍历要对每一个前缀和找到第一个符合条件的值，时间复杂度为 \\(O(n^2)\\) ，而逆序遍历的时候对所有已经遍历过的前缀和进行查询，用 map 进行了保存，时间复杂度降到了 \\(O(n\\cdot logn)\\)。\n总之使用前缀和可以很简单的处理可以差分的问题。\n","date":"2024 July 31","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/2/h/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营2】H","type":"posts"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/","section":"Tags","summary":"","title":"前缀和","type":"tags"},{"content":"\r1. 题目 #\rEnglish\rBen_H has a positive integer \\(x\\). He wants you to find another positive integer \\(y\\), which is strictly less than \\(x\\), so that the equation \\(gcd(x, y) = x \\oplus y\\) holds. Can you help him?\nwhere \\(\\oplus\\) is bitwise XOR operation.\nInput\nThe first line contains a single integer \\(t (1 \\leq t \\leq 10^4)\\) — the number of test cases.\nThe only line of each test case contains a single integer \\(x (1\\leq x \\leq 10^{18})\\).\nOutput\nFor each testcase, output a single positive integer \\(y\\), if you find a feasible answer, or \\(-1\\) otherwise.\n简体中文（大意）\r给定 \\(x\\)，构造 \\(y\\) 使满足 \\(gcd(x,y) = x\\oplus y\\)。\r2. 思路 #\r签到题，由于问题只需要构造出一个数满足条件即可，故不需要遍历整个区间。\n由最大公约数的性质可知，\\(gcd(x,y)\\) 的结果通常与 \\(x\\) 成倍数关系，而等式右侧又为二进制的表示形式，故考虑是否存在 \\(2\\) 的倍数。\n又二进制的表示方法知道，设 \\(x\\) 的二进制形式为 \\(10110100\\)，则可以表示为： $$ 2^7 + 2^5 + 2^4 + 2^2 = (2^5 + 2^3 + 2^2 + 1)\\times 2^2 $$ 故 \\(x\\) 可以表示为最后一个为 \\(1\\) 位所表示的二进制数的倍数，可以通过补码性质得到。\n要保证与右侧的异或值相同，只要保证 \\(y\\) 的前半部分与 \\(x\\) 相同，从 \\(x\\) 的最后一个 \\(1\\) 位往后均为 \\(0\\) 即可： $$ \\begin{array}{cc} x\u0026amp;10110100\\\\ y\u0026amp;10110\\color{red}{\\underline{0}00}\\\\ \\hline \\oplus\\rightarrow\u0026amp;00000\\color{blue}{100} \\end{array} $$\n此外要特别注意的是，如果 \\(x\\) 为 \\(2^k\\)，那么按照这种方法找到的数为 \\(0\\)，不满足条件。\n3. 代码 #\rC\u0026#43;\u0026#43;\rvoid solve() { i64 x; std::cin \u0026gt;\u0026gt; x; i64 lowbit = (x \u0026amp; -x); if (lowbit == x) { std::cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; x - lowbit \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } 4. 总结 #\r签到题，但是本题注意数据范围 \\((1\\leq x \\leq 10^{18})\\) 很大，不要通过遍历去搜索满足条件的数，尽量从二进制的结构上去构造。\n掌握获取最后一个为 \\(1\\) 位的方法，也经常运用于树状数组中：lowbit = (x \u0026amp; -x)。\n","date":"2024 July 31","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/2/e/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营2】E","type":"posts"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/tags/%E7%AD%BE%E5%88%B0%E9%A2%98/","section":"Tags","summary":"","title":"签到题","type":"tags"},{"content":"\r1. 题目 #\rEnglish\rRed is on a \\(2\\cdot n\\) grid, with some cells being red and others being white.\nRed can initially choose a red cell, and at each step, can choose a red cell above, below, to the left, or to the right. When Red leaves a cell, the cell immediately turns white.\nRed wants to know the maximum number of steps she can take.\nIf there are no initial red cells, please output \\(0\\).\nInput\nThe first line contains a positive integer \\(n(1\\leq n \\leq 10^6)\\).\nThe next two lines contain a \\(2\\cdot n\\) character matrix, consisting only of R and W characters. R represents a red cell, and W represents a white cell.\nOutput\nAn integer — the maximum number of steps Red can take.\n简体中文（大意）\r在 \\(2\\times n\\) 的格子中有 R 和 W，求从任意一个 R 出发能连续走到最多的 R 的个数。\r2. 思路 #\r这道题是一道比较经典的动态规划问题。假定从左往右寻找，当前位置假如为 R，则只有可能从左方或者另一条线的 R 所在的搜索路线上加 \\(1\\) 得到。因此我们能比较容易得到动态规划的转移方程： $$ \\begin{cases} dp(i,j,0)=\\max{(dp(i,j-1,0),dp(i,j-1,1))}\\\\ dp(i,j,1)=dp(1-i,j,0)+1 \\end{cases} $$ 其中 \\(dp(i,j,k)\\) 数组表示坐标为 \\((i,j)\\) 的 R 从 \\(k\\) 方向上来的 R 的个数，\\(k=0\\) 表示从左方来的个数，\\(k=1\\) 表示从另一条线上来的个数。对于同一个元素的 \\(k\\) 可以通过另一条线加 \\(1\\) 得到。\n然后对所有的 \\(dp\\) 数组遍历寻找最大值即可。\n3. 代码 #\rC\u0026#43;\u0026#43;\rvoid solve() { int n; std::cin \u0026gt;\u0026gt; n; std::string s[2]; for (int i = 0; i \u0026lt; 2; i++) { std::cin \u0026gt;\u0026gt; s[i]; } std::vector\u0026lt;std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; dp(2, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;(n, std::vector\u0026lt;int\u0026gt;(2, 0))); for (int j = 0; j \u0026lt; n; j++) { for (int i = 0; i \u0026lt; 2; i++) { if (s[i][j] == \u0026#39;R\u0026#39;) { dp[i][j][0] = 1; } } } for (int j = 0; j \u0026lt; n; j++) { for (int i = 0; i \u0026lt; 2; i++) { if (s[i][j] == \u0026#39;R\u0026#39; \u0026amp;\u0026amp; j \u0026gt; 0) { dp[i][j][0] += std::max(dp[i][j - 1][0], dp[i][j - 1][1]); } } for (int i = 0; i \u0026lt; 2; i++) { if (s[i][j] == \u0026#39;R\u0026#39;) { dp[i][j][1] = dp[i ^ 1][j][0] + 1; } } } int ans = 0; for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; n; j++) { for (int k = 0; k \u0026lt; 2; k++) { ans = std::max(ans, dp[i][j][k]); } } } std::cout \u0026lt;\u0026lt; std::max(0 ,ans - 1) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 4. 总结 #\r经典的动态规划，懂点掌握如何设计动态转移方程。一般可以将已有的条件设置为可以推导的部分（比如下标），而要求的值设置为 dp 数组的值进行递推。\n","date":"2024 July 31","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/2/c/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营2】C","type":"posts"},{"content":"\r1. 题目 #\rEnglish\rSajin has recently delved into the study of minimum spanning trees and now he has mastered the algorithm of MST.\nHe is eager to assess your grasp of minimum spanning tree concepts through a series of queries. You are confronted with an weighted undirected graph that encompasses nnn vertices and mmm edges without any self-loops.\nSajin presents \\(q\\) inquiries. For each, a vertex set \\(S\\) is given. Your objective is to determine the induced subgraph of \\(S\\) and find the weight of its minimum spanning tree.\nA minimum spanning tree (MST) is a subset of the edges of a connected, edge-weighted graph that connects all the vertices together without any cycles and with the minimum possible total edge weight.\nIn the mathematical field of graph theory, an induced subgraph of a graph is another graph, formed from a subset of the vertices of the graph and all of the edges, from the original graph, connecting pairs of vertices in that subset.\nIf the induced subgraph of \\(S\\) is disconnected, output \\(-1\\).\nInput\nThe first line contains \\(3\\) integers \\(n\\), \\(m\\), \\(q\\) (\\(2 \\le n \\le 10^5,1 \\le m, q \\le 10^5\\)), — the number of points, the number of edges, and the number of queries.\nThen mmm lines follow, each line contains three integers \\(u_i\\), \\(v_i\\), \\(w_i\\)(\\(1 \\le u_i, v_i \\le n\\), \\(u_i \\ne v_i\\), \\(1 \\le w_i \\le 10^9\\)), — the two endpoints of the iii-th edge and the edge weight.\nNext \\(q\\) lines, each line first contains an integer \\(k_i\\)(\\(1 \\le k_i \\le n\\)) — the size of the vertex set \\(S\\) for the \\(i\\)-th query.\nThen followed by \\(k_i\\) distinct integers \\(s_{i,j}\\)(\\(1 \\le s_{i,j} \\le n\\)) — the numbers of the vertex set \\(S\\) for the \\(i\\)-th query.\nIt is guaranteed that the sum of \\(k_i\\) over all queries does not exceed \\(10^5\\).\nOutput\nFor each query, output one integer representing the answer.\n简体中文（大意）\r给你一张图，求导出子图的最小生成树。\r2. 思路 #\r观察到点和边的数据范围，发现非常相近，可以理解为整体上这个图为一张稀疏图（从邻接矩阵看比较直观）。由于本题求的是导出子图的最小生成树，对于稀疏图在局部上也可能为一张稠密图。\n对于最小生成树常见的算法有 Kruskal 和 Prim，Kruskal 常用于稀疏图，Prim 常见于稀疏图。具体可以参考下面这篇文章：\n由于本题对于 Prim 时间复杂度的要求非常高，故使用 Kruskal 搭配边存储优化求解。\nKruskal 的算法就是从小到大遍历所有边，假如给定点集 \\(S\\)，那么在遍历两点相邻的边时，每条边会存两次。因此我们需要降低存的重复边数来减少后续遍历的次数，根据三元环计数的原理，我们可以存为单向边，每个点存的边数会降为 \\(\\sqrt{m}\\)。\n三元环计数参考：\n三元环计数\r2024 August 30\u0026middot;179 字\u0026middot;1 分钟\r算法\r图论\r三元环计数是图论中一个比较重要的问题，用于求解无向图中三元环的个数。\r由于有菊花图出现的可能，如果单向边的起点从每个菊花图的中心开始，那么中心所连的点可能不在点集 \\(S\\) 中，此时遍历的点数会比较多。但如果从花瓣开始，则会减少这种情况的出现。因此我们需要记录下每个点的度数，将从度数小的点指向度数大的边存起来，度数相同则存从下标小到下标大的边。\n3. 代码 #\rC\u0026#43;\u0026#43;\rstruct DSU { std::vector\u0026lt;int\u0026gt; f, sz; DSU(int n) : f(n), sz(n, 1) { std::iota(f.begin(), f.end(), 0); } int find(int x) { return f[x] == x ? x : f[x] = find(f[x]); } bool merge(int x, int y) { int fx = find(x), fy = find(y); if (fx == fy) { return false; } if (sz[fx] \u0026gt; sz[fy]) { std::swap(fx, fy); } f[fx] = fy; sz[fy] += sz[fx]; return true; } bool same(int x, int y) { return find(x) == find(y); } }; void kruskal(int k, std::vector\u0026lt;std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; \u0026amp;p, std::vector\u0026lt;bool\u0026gt; \u0026amp;vis, std::vector\u0026lt;int\u0026gt; \u0026amp;s, DSU \u0026amp;node) { std::vector\u0026lt;std::array\u0026lt;int, 3\u0026gt;\u0026gt; l; for (auto \u0026amp;u : s) { for (auto \u0026amp;[v, w] : p[u]) { if (vis[v]) { l.push_back({w, u, v}); } } } std::sort(l.begin(), l.end()); i64 sum = 0, num = 1; for (auto \u0026amp;[w, u, v] : l) { if (num == k) { break; } if (node.merge(u, v)) { num ++; sum += w; } } if (num == k) { std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; } } void solve() { int n, m, q; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; DSU node(n + 1); std::vector\u0026lt;int\u0026gt; degree(n + 1); std::vector\u0026lt;std::array\u0026lt;int, 3\u0026gt;\u0026gt; op(m + 1); for (int i = 1; i \u0026lt;= m; i++) { int u, v, w; std::cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; if (u \u0026gt; v) { std::swap(u, v); } op[i] = {u, v, w}; degree[u]++; degree[v]++; } std::vector\u0026lt;std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; p(n + 1); for (int i = 1; i \u0026lt;= m; i++) { auto \u0026amp;[u, v, w] = op[i]; if (degree[u] \u0026gt; degree[v]) { std::swap(u, v); } p[u].emplace_back(v, w); } std::vector\u0026lt;bool\u0026gt; vis(n + 1); while (q--) { int k; std::cin \u0026gt;\u0026gt; k; std::vector\u0026lt;int\u0026gt; s(k); for (int i = 0; i \u0026lt; k; i++) { std::cin \u0026gt;\u0026gt; s[i]; vis[s[i]] = true; node.f[s[i]] = s[i]; node.sz[s[i]] = 1; } kruskal(k, p, vis, s, node); for (auto \u0026amp;i : s) { vis[i] = false; } } } 4. 总结 #\r这道题其实主体还是考察最小生成树的算法，但是需要考虑存边时候效率问题。\n值得注意的是：\n稀疏图使用 Kruskal，稠密图使用 Prim 三元环原理可以帮助降低访问边的次数 函数传参的时候一定要带上引用\u0026amp;，特别是在传递的数组或vector特别大时，如果采用形式传参，会增加复制的时间复杂度。要注意对于原始数据的修改的问题。 ","date":"2024 July 31","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/2/b/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营2】B","type":"posts"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/tags/%E4%B8%89%E5%85%83%E7%8E%AF%E8%AE%A1%E6%95%B0/","section":"Tags","summary":"","title":"三元环计数","type":"tags"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","section":"Tags","summary":"","title":"最小生成树","type":"tags"},{"content":"\r第二类斯特林数是组合数学上常见的一种概念，用于解决集合拆分的问题。\n【问题1】将 n 个元素拆分为 m 个非空集合，有多少种方案？\n【问题2】将 n 个苹果分给 m 个人，每人至少有一个苹果，有多少种方案？\n上述的两个问题都可以用第二类斯特林数解决。\n将 \\(n\\) 个元素拆分为 \\(k\\) (\\(1\\leq k\\leq m\\)) 个集合的方案数我们表示为 \\(S(n,k)\\)，则我们最终要求的方案数可以表示为 \\(S(n,m)\\)。我们可以得到递推式： $$ S(n,k)=S(n-1,k-1)+C_k^1\\cdot S(n-1,k) $$\n当插入一个元素的时候，有两种方案：\n将元素插入到新的集合，元素个数从 \\(n-1\\) 变为 \\(n\\)，集合个数从 \\(k-1\\) 变为 \\(k\\)。 在已有集合任选一个集合插入元素，元素个数从 \\(n-1\\) 变为 \\(n\\)，集合个数不变。 ","date":"2024 July 29","externalUrl":null,"permalink":"/posts/math/combinatorialmath/stirlingnumber/","section":"Posts","summary":"第二类斯特林数是组合数学上常见的一种概念，用于解决集合拆分的问题。","title":"第二类斯特林数","type":"posts"},{"content":"","date":"2024 July 29","externalUrl":null,"permalink":"/categories/%E6%95%B0%E5%AD%A6/","section":"Categories","summary":"","title":"数学","type":"categories"},{"content":"","date":"2024 July 29","externalUrl":null,"permalink":"/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/","section":"Categories","summary":"","title":"组合数学","type":"categories"},{"content":"\r1. 题目 #\rEnglish\rThe ICPC World Finals are coming. Due to some reasons, the 46th and 47th World Finals will be held simultaneously. For the teams qualified in both competitions, they should choose one to take part in.\nAs we know, lzr010506\u0026rsquo;s team is double-qualified and should make a choice. To make a wiser choice, lzr010506 looked up the qualified lists for two competitions and trained a magic model to predict the results for all participants among the two competitions. Moreover, a result contains the number of solved problems and the time penalty. The more solved problems, the better the result is, and if two teams solved the same number of problems, the result with the lower time penalty is better.\nNow, lzr010506 wants to know the best possible ranking if the actual results are all the same as predicted and that the competition choices of the double-qualified teams can be arbitrarily arranged by him.\nInput\nThe first line contains one integer \\(n\\) (\\(1 \\le n \\le 10^5\\)), denoting the number of teams qualified in the 46th World Finals.\nNext nnn lines each contain one string \\(S\\) (\\(1 \\le |S| \\le 10\\)) and two integers \\(p,t\\) (\\(1 \\le p,t \\le 10^9\\)), denoting the name, the predicted number of solved problems, and time penalty of one team in the 46th World Finals respectively.\nNext one line contains one integer \\(m\\) (\\(1 \\le m \\le 10^5\\)), denoting the number of teams qualified in the 47th World Finals.\nNext \\(m\\) lines each contain one string \\(S\\) (\\(1 \\le |S| \\le 10\\)) and two integers \\(p,t\\) (\\(1 \\le p,t \\le 10^9\\)), denoting the name, the predicted number of solved problems, and time penalty of one team in the 47th World Finals respectively.\nIt is guaranteed that:\nthe team names only contain digits and English letters; the team names in one competition are different from each other; no two teams have the same predicted number of solved problems and the time penalty simultaneously in one competition; the same names among two qualified name lists refer to the same team in real; lzr010506 appears in both two qualified name lists. Output\nOutput one line containing one integer, denoting the best possible ranking of lzr010506\u0026rsquo;s team.\n简体中文（大意）\r一些队伍同时参加了两场比赛，但只能选择一场比赛积分，求 lzr010506 能获得的最高名次。\r2. 思路 #\r签到题，只需要将两次比赛的队伍按照规则排个序，然后假设在两场比赛在lzr010506之前的队伍都参加另一场比赛（如果能参加另一场比赛的话），比较lzr010506在两场比赛中的名次取最小值。\n3. 代码 #\rC\u0026#43;\u0026#43;\rstruct part { std::string s; int pass, pen; }; bool cmp(part x, part y) { if (x.pass \u0026gt; y.pass) { return true; } else if (x.pass == y.pass) { return x.pen \u0026lt; y.pen; } else { return false; } } void solve() { int n; std::cin \u0026gt;\u0026gt; n; std::set\u0026lt;std::string\u0026gt; l46b, l47b; std::vector\u0026lt;part\u0026gt; l46(n); for (int i = 0; i \u0026lt; n; i++) { std::string s; int p, t; std::cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; p \u0026gt;\u0026gt; t; l46[i] = {s, p, t}; l46b.insert(s); } int m; std::cin \u0026gt;\u0026gt; m; std::vector\u0026lt;part\u0026gt; l47(m); for (int i = 0; i \u0026lt; m; i++) { std::string s; int p, t; std::cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; p \u0026gt;\u0026gt; t; l47[i] = {s, p, t}; l47b.insert(s); } std::sort(l46.begin(), l46.end(), cmp); std::sort(l47.begin(), l47.end(), cmp); std::set\u0026lt;std::string\u0026gt; l46f, l47f; for (int i = 0; i \u0026lt; n; i++) { if (l46[i].s == \u0026#34;lzr010506\u0026#34;) { break; } l46f.insert(l46[i].s); } for (int i = 0; i \u0026lt; m; i++) { if (l47[i].s == \u0026#34;lzr010506\u0026#34;) { break; } l47f.insert(l47[i].s); } int num1 = 1, num2 = 1; for (auto i : l46f) { if (l47b.find(i) == l47b.end()) { num1 ++; } } for (auto i : l47f) { if (l46b.find(i) == l46b.end()) { num2 ++; } } std::cout \u0026lt;\u0026lt; std::min(num1, num2); } 4. 总结 #\r签到题\n","date":"2024 July 27","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/1/h/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营1】H","type":"posts"},{"content":"","date":"2024 July 27","externalUrl":null,"permalink":"/categories/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A51/","section":"Categories","summary":"","title":"2024牛客暑期多校训练营1","type":"categories"},{"content":"","date":"2024 July 27","externalUrl":null,"permalink":"/series/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A51/","section":"Series","summary":"","title":"2024牛客暑期多校训练营1","type":"series"},{"content":"\r1. 题目 #\rEnglish\rGiven an array which is initially empty, you need to perform \\(q\\) operations:\nGiven two non-negative integers \\(t\\) and \\(v\\), take out the element from the end of the array for \\(t\\) times and then append \\(v\\) to the end of the array. It is guaranteed that \\(t\\) does not exceed the length of the array before this operation. After each operation, let \\(a_1,a_2,\\dots,a_n\\) be the current array, find the sum of \\(s_1,s_2,\\dots,s_n\\) , where \\(s_i =a_i +a_{i+1}+\\dots+a_n\\) is the sum of the suffix starting from position \\(i\\).\nSince the answers may be very large, output them modulo \\(1000000007\\).\nInput\nThe first line contains an integer \\(q\\) ( \\(1\\leq q\\leq 5\\times 10^5\\) ), denoting the number of operations.\nEach of the following \\(q\\) lines contains two non-negative integers \\(t\\) and \\(v\\) ( \\(0\\leq v\\leq 10^9\\) ), describing an operation, where \\(t\\) does not exceed the length of the array before this operation.\nOutput\nOutput \\(q\\) lines, each of which contains an integer, denoting the answer.\n简体中文（大意）\r\\(q\\) 次询问，每次从序列末尾删除 \\(t\\) 个数，并添加一个数 \\(v\\)，求每次询问后的后缀和的和。\r2. 思路 #\r观察到元素在后缀和中拥有不同的权重，假如 \\(a_1,a_2,a_3,a_4=[1,2,3,4]\\)，那么有： $$ \\begin{aligned} s_1\u0026amp;=\u0026amp;a_1+a_2+a_3+a_4\\\\ s_2\u0026amp;=\u0026amp;a_2+a_3+a_4\\\\ s_3\u0026amp;=\u0026amp;a_3+a_4\\\\ s_4\u0026amp;=\u0026amp;a_4\\\\ \\end{aligned} $$ 则该 \\(before=\\sum\\limits^n_{i=1}{s_i} = a_1+2a_2+3a_3+4a_4\\)。假如 \\(t=1\\)，那么有： $$ \\begin{aligned} s_1\u0026amp;=\u0026amp;a_1+a_2+a_3\\\\ s_2\u0026amp;=\u0026amp;a_2+a_3\\\\ s_3\u0026amp;=\u0026amp;a_3\\\\ s_4\u0026amp;=\u0026amp;\\\\ \\end{aligned} $$ 此时 \\(after=\\sum\\limits^{n-t}_{i=1}{s_i} = a_1+2a_2+3a_3=before-4a_4\\)。\n计算 \\(\\sum\\limits^n_{i=1}{s_i}\\) 时，每次从末尾删除 \\(t\\) 个元素，都会删掉对应的 权重 \\(\\times\\) 数。\n那么每次操作的时候，只需要在总的 \\(\\sum\\limits^n_{i=1}{s_i}\\) 上进行增删就可以了。\n3. 代码 #\rC\u0026#43;\u0026#43;\rconstexpr int mod = 1000000007; void solve() { int q; std::cin \u0026gt;\u0026gt; q; i64 sum = 0; std::stack\u0026lt;i64\u0026gt; l; while (q--) { i64 t, v; std::cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; v; while (t--) { sum += mod; // 防止减的时候成为负数 sum -= (l.top() * l.size()) % mod; sum %= mod; l.pop(); } l.push(v); sum += (v * l.size()) % mod; sum %= mod; std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } 4. 总结 #\r这个题主要对模运算进行了考察，有几个点需要特别注意一下：\n模运算中：\\((A\\pm* B)\\mod P=((A\\mod P)\\pm* (B\\mod P))\\mod P\\) 由于第一条特性，在程序的减法的过程中会对每一项元素取模后再取模，所以在计算过程中迭代器很容易在做减法的时候变为负数，此时需要在对迭代器取模前先加上一个模数防止溢出。 ","date":"2024 July 26","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/1/c/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营1】C","type":"posts"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E6%A8%A1%E8%BF%90%E7%AE%97/","section":"Tags","summary":"","title":"模运算","type":"tags"},{"content":"\r1. 题目（Problem A Enhanced） #\rEnglish\rGiven two integers \\(n\\) and \\(m\\), among all the sequences containing \\(n\\) non-negative integers less than \\(2^m\\), you need to count the number of such sequences \\(A\\) that there exists two different non-empty subsequencesc of \\(A\\) in which the bitwise AND of the integers is \\(1\\).\nNote that a non-empty subsequence of a sequence \\(A\\) is a non-empty sequence that can be obtained by deleting zero or more elements from \\(A\\) and arranging the remaining elements in their original order. Two subsequences are different if they are composed of different locations in the original sequence.\nSince the answer may be very large, output it modulo a positive integer \\(q\\).\nThe bitwise AND of non-negative integers \\(A\\) and \\(B\\), \\(A\\) AND \\(B\\) is defined as follows:\nWhen \\(A\\) AND \\(B\\) is written in base two, the digit in the \\(2^d\\)\u0026rsquo;s place ( \\(d\\geq 0\\) ) is \\(1\\) if those of \\(A\\) and \\(B\\) are both \\(1\\), and \\(0\\) otherwise. For example, we have \\(4\\) AND \\(6\\) = \\(4\\) (in base two: \\(100\\) AND \\(110\\) = \\(100\\)).\nGenerally, the bitwise AND of \\(k\\) non-negative integers \\(p_1,𝑝_2,\\dots,p_k\\) is defined as (\\(\\dots\\)((\\(p_1\\) AND \\(p_2\\)) AND \\(p_3\\)) AND \\(\\dots\\) AND \\(p_𝑘\\)) and we can prove that this value does not depend on the order of \\(p_1,𝑝_2,\\dots,p_k\\).\nInput\nThe only line contains three integers \\(n\\) (\\(1 \\le n \\le 5,000\\)), \\(m\\) (\\(1 \\le m \\le 5,000\\)) and \\(q\\) (\\(1 \\le q \\le 10^9\\)).\nOutput\nOutput a line containing an integer, denoting the answer.\n简体中文（大意）\r给两个数 \\(n\\) 和 \\(m\\)，表示 \\(n\\) 个 \\(m\\) 位（B）长度的数，寻找【仅存在一个 AND 和为 \\(1\\) 的子序列】的序列的个数。\r2. 思路 #\r这是 \\(A\\) 题的加强版，\\(A\\) 题前序内容参考：\n此题可以简化为：\\(A\\) 题中的答案 -【有且仅有一个子序列 AND 和为 1 】的数量。\n可以根据 \\(A\\) 题的推导过程发现，每次我们选择 \\(k\\) 个末尾均为 \\(1\\) 的数，剩下的 \\(n - k\\) 数末尾均为 \\(0\\)，那么仅有的这个 AND 和为 \\(1\\) 的子序列必须为当前选定的 \\(k\\) 个数的子序列。但是这个子序列要想满足唯一的条件，就必须修改【除末尾为 \\(1\\)，其余 \\(m - 1\\) 位任选含 \\(0\\) 的 \\(2^k-1\\) 种选择】的条件。\n假如 \\(k=3\\)，最后一位为 \\(1\\)，那么下式中的所有的 \\(\\underline{\\bold{0}}\\) 均为所有选中的 \\(k\\) 个数中所在位唯一的 \\(0\\)（称为特殊位）： $$ \\begin{array}{c|ccc|c} \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\\\ \\hline p_1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \\\\ p_2 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \\\\ p_3 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \\\\ \\end{array} $$ 因此可以发现，当选取 \\(k\\) 个数为子序列的时候，我们要满足这些数都至少包含一个特殊位，当满足 \\(1\\leq k\\leq m-1\\) 的时候，确保不会有重复的特殊位出现： $$ \\begin{array}{c|ccccc|c} \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; \\dots \u0026amp; m-1 \u0026amp; m \\\\ \\hline p_1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \u0026amp; 1 \\\\ p_2 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \u0026amp; 1 \\\\ p_3 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; \\dots \u0026amp; 1 \u0026amp; 1 \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots\\\\ p_k \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \\end{array} $$ 当删除这些特殊位的时候，就会使得某一位不含有 \\(0\\)，不满足 AND 和为 \\(1\\) 的条件，确保了唯一性。\n假如此时选取了 \\(k-1\\) 个数，当在为 \\(k\\) 个数添加特殊位的时候，有以下两种情况：\n添加到新选择的数的某一位上。 添加到已选择的 \\(k-1\\) 中某一个数的某一位上 我们采用动态规划，假设选择 \\(k\\) 个数，有 \\(t\\) (\\(k\\leq t\\leq m-1\\)) 个特殊位的方案数为 \\(dp(k,t)\\)，那么状态转移方程为： $$ dp(k,t)=C^1_k\\cdot(dp(k-1,t-1) + dp(k,t-1)) $$ 即特殊位要么加在 \\(k-1\\) 个数的基础上新加的一个数上，要么加在已经存在的一个数上。直观体现为如下两种情况（红色为已有的特殊位，蓝色为新加的特殊位）： $$ \\begin{align*} \\begin{array}{c|cccccc|c} \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; \\dots \u0026amp; 6 \\\\ \\hline p_1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \\\\ p_2 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \\\\ p_3 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1\\\\ p_4 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{blue}{\\underline{\\bold{0}}} \u0026amp; \\dots \u0026amp; 1\\\\ \\end{array} \\hspace{1cm} \\begin{array}{c|cccccc|c} \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; \\dots \u0026amp; 5 \\\\ \\hline p_1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \\\\ p_2 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \\\\ p_3 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1\\\\ p_4 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; \\color{blue}{\\underline{\\bold{0}}} \u0026amp; \\dots \u0026amp; 1\\\\ \\end{array} \\end{align*} $$ 由于 \\(t\\) 的范围为 \\(k\\leq t\\leq m-1\\)，相当于将 \\(t\\) 个特殊位分给 \\(k\\) 个数，每个数至少含有一个特殊位，类似于第二类斯特林数，故也可以结合斯特林数的推导过程理解状态转移方程。\n需要注意的是：\n当 \\(k=1\\) 的时候，当且仅当子序列为 \\(1\\) 的时候，这个数满足条件，需要单独计算：\\(C_n^1\\cdot2^{(n-1)\\cdot(m-1)}\\) 当 \\(k\u0026gt;1\\) 的时候，我们选择其中 \\(t\\) 位，其他 \\(m-1-t\\) 位依然可以任选，但是注意每位不能只含有一个 \\(0\\) （防止成为特殊位，有 k 种只有一位有 \\(0\\) 情况），再减去全为 \\(1\\) 的情况：\\((2^k-k-1)^{{m-1-t}}\\) 于是最终结果为： $$ \\begin{align*} ans \u0026amp;= \\sum\\limits_{k=1}^n(C_n^k \\cdot(2^k-1)^{m-1}\\cdot2^{(m-1)\\cdot(n-k)})-\\sum\\limits_{k=2}^n(C_n^k\\cdot2^{(m-1)\\cdot(n-k)}\\cdot\\sum\\limits_{t=k}^{m-1}(C_{m-1}^t\\cdot dp(k,t)\\cdot(2^k-k-1)^{m-1-t}))+C_n^1\\cdot2^{(n-1)\\cdot(m-1)}\\\\ \u0026amp;=\\sum\\limits_{k=2}^n(C_n^k\\cdot2^{(m-1)\\cdot(n-k)}\\cdot((2^k-1)^{m-1}-\\sum\\limits_{t=k}^{m-1}(C_{m-1}^t\\cdot dp(k,t)\\cdot(2^k-k-1)^{m-1-t}))) \\end{align*} $$\n3. 代码 #\rC\u0026#43;\u0026#43;\ri64 binpow(i64 a, i64 b, i64 mod) { a %= mod; i64 ans = 1; while (b \u0026gt; 0) { if (b \u0026amp; 1) { ans *= a; ans %= mod; } a *= a; a %= mod; b \u0026gt;\u0026gt;= 1; } return ans; } void solve() { int n, m; i64 q; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; std::vector\u0026lt;i64\u0026gt; a(n + 1), c(n + 1), ct(m); a[0] = c[0] = ct[0] = 1; for (int k = 1; k \u0026lt;= n; k++) { a[k] = a[k - 1] \u0026lt;\u0026lt; 1; a[k] %= q; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = i; j \u0026gt; 0; j--) { c[j] = (c[j] + c[j - 1]) % q; } } for (int i = 1; i \u0026lt;= m - 1; i++) { for (int j = i; j \u0026gt; 0; j--) { ct[j] = (ct[j] + ct[j - 1]) % q; } } std::vector\u0026lt;std::vector\u0026lt;i64\u0026gt;\u0026gt; dp(n + 1, std::vector\u0026lt;i64\u0026gt;(m)); dp[0][0] = 1; for (int k = 1; k \u0026lt;= n; k++) { for (int t = 1; t \u0026lt;= m - 1; t++) { dp[k][t] = ((dp[k][t - 1] + dp[k - 1][t - 1]) % q * k) % q; } } i64 ans = 0; for (int k = 2; k \u0026lt;= n; k++) { i64 tmp1 = binpow(a[k] - 1, m - 1, q); i64 tmp2 = 0, tp = (a[k] + q - k - 1) % q, tmpt = 1; for (int t = m - 1; t \u0026gt;= k; t--) { tmp2 += ((ct[t] * dp[k][t]) % q * tmpt) % q; tmp2 %= q; tmpt *= tp; tmpt %= q; } i64 tmp3 = binpow(a[n - k], m - 1, q); ans += (((tmp1 + q - tmp2) % q * tmp3) % q * c[k]) % q; ans %= q; } std::cout \u0026lt;\u0026lt; ans; } 4. 总结 #\r本题是 \\(A\\) 题的加强版，在 \\(A\\) 的基础上引入了第二类斯特林数的思想对【有且仅有一个子序列 AND 和为 1 】进行了解释和推导，是对于规律总结和组合数学的很好的练习。\n第二类斯特林数请参考：\n","date":"2024 July 26","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/1/b/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营1】B","type":"posts"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E7%AC%AC%E4%BA%8C%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/","section":"Tags","summary":"","title":"第二类斯特林数","type":"tags"},{"content":"\r1. 题目 #\rEnglish\rGiven two integers \\(n\\) and \\(m\\), among all the sequences containing \\(n\\) non-negative integers less than \\(2^m\\), you need to count the number of such sequences \\(A\\) that there exists a non-empty subsequence of \\(A\\) in which the bitwise AND of the integers is \\(1\\).\nNote that a non-empty subsequence of a sequence \\(A\\) is a non-empty sequence that can be obtained by deleting zero or more elements from \\(A\\) and arranging the remaining elements in their original order.\nSince the answer may be very large, output it modulo a positive integer \\(q\\).\nThe bitwise AND of non-negative integers \\(A\\) and \\(B\\), \\(A\\) AND \\(B\\) is defined as follows:\nWhen \\(A\\) AND \\(B\\) is written in base two, the digit in the \\(2^d\\)\u0026rsquo;s place ( \\(d\\geq 0\\) ) is \\(1\\) if those of \\(A\\) and \\(B\\) are both \\(1\\), and \\(0\\) otherwise. For example, we have \\(4\\) AND \\(6\\) = \\(4\\) (in base two: \\(100\\) AND \\(110\\) = \\(100\\)).\nGenerally, the bitwise AND of \\(k\\) non-negative integers \\(p_1,𝑝_2,\\dots,p_k\\) is defined as (\\(\\dots\\)((\\(p_1\\) AND \\(p_2\\)) AND \\(p_3\\)) AND \\(\\dots\\) AND \\(p_𝑘\\)) and we can prove that this value does not depend on the order of \\(p_1,𝑝_2,\\dots,p_k\\).\nInput\nThe only line contains three integers \\(n\\) (\\(1 \\le n \\le 5,000\\)), \\(m\\) (\\(1 \\le m \\le 5,000\\)) and \\(q\\) (\\(1 \\le q \\le 10^9\\)).\nOutput\nOutput a line containing an integer, denoting the answer.\n简体中文（大意）\r给两个数 \\(n\\) 和 \\(m\\)，表示 \\(n\\) 个 \\(m\\) 位（B）长度的数，寻找【存在 AND 和为 \\(1\\) 的子序列】的序列的个数。\r2. 思路 #\r这是一道找规律的题。通过观察样例2 3 998244353 -\u0026gt; 17可以发现如下的计算过程：\n选择含有一个数的子序列，则选择的这个子序列必须为 001。另外一个数的各位任选，有 \\(2^3\\) 种方案。由于子序列按照不同顺序排列算作不同的子序列，那将001放在另一个数的位置为另一种情况。此时还需要减去[001, 001]的情况，出现了两次。故此时的结果为 \\(2^3+2^3 - 1=15\\)。 选择含有两个数的子序列，则选择的两个子序列的末尾那一位必须均为 \\(1\\)。由于刚刚已经计算过了其中一位为001的情况，再加上两个末尾为 \\(1\\) 但是不为001的情况：[101, 011]和[011, 101]。故此时的结果为 \\(15+2=17\\)。 将上面的过程进行推广我们可以发现有如下的规律：\n选择其中的 \\(k\\) 个数，使得这 \\(k\\) 个数的末尾一位均为 \\(1\\)，而其他位上的数，保证至少出现一个 \\(0\\)。我们可以知道第 \\(i\\) 位的数字范围为[000...0~111...1]，当我们去除最后一个全为 \\(1\\) 的数，其他的数均满足出现至少一个 \\(0\\)。此时的范围为 \\(C_n^k \\cdot(2^k-1)^{m-1}\\)，即从 \\(n\\) 个数中任选 \\(k\\) 个数并对除了最后一位的其余 \\(m-1\\) 位都获取了 \\(2^k-1\\) 种结果。 然后对于剩下的 \\(n-k\\) 个数，任意选择每一位上的结果，为了保证不会重复计算，让剩下的 \\(n-k\\) 个数的最后一位均为 \\(0\\)。此时的范围为 \\((2^{m-1})^{n-k}=2^{(m-1)\\cdot(n-k)}\\)，即对每一个数选定最后一位为 \\(0\\)，其余位置任选。 于是最终的结果为： $$ \\sum\\limits_{k=1}^n(C_n^k \\cdot(2^k-1)^{m-1}\\cdot2^{(m-1)\\cdot(n-k)}) $$\n3. 代码 #\rC\u0026#43;\u0026#43;\ri64 binpow(i64 a, i64 b, i64 mod) // 快速幂 { a %= mod; i64 ans = 1; while (b \u0026gt; 0) { if (b \u0026amp; 1) { ans = (ans * a) % mod; } a = (a * a) % mod; b \u0026gt;\u0026gt;= 1; } return ans; } void solve() { int n, m; i64 q; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; std::vector\u0026lt;i64\u0026gt; a(n + 1), c(n + 1); a[0] = c[0] = 1; for (int k = 1; k \u0026lt;= n; k++) { a[k] = a[k - 1] \u0026lt;\u0026lt; 1; a[k] %= q; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = i; j \u0026gt; 0; j--) { c[j] = (c[j] + c[j - 1]) % q; } } i64 ans = 0; for (int k = 1; k \u0026lt;= n; k++) { i64 tmp1 = binpow(a[k] - 1, m - 1, q); i64 tmp2 = binpow(a[n - k], m - 1, q); ans += ((tmp1 * tmp2) % q * c[k]) % q; ans %= q; } std::cout \u0026lt;\u0026lt; ans; } 4. 总结 #\r本题主要是考察找规律的技巧，通过数学归纳法对样例的推导过程进行总结，然后推导出计算公式。\n此外，本题还有几个小的知识点：\n组合数的计算，通过压缩到一维减少空间的使用。 取模运算的技巧。 用快速幂加快幂的运算。 总之这道题考验选手在赛场上总结规律的能力和组合数学以及其他的基本功。\n","date":"2024 July 26","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/1/a/","section":"Posts","summary":"1.","title":"【2024牛客暑期多校训练营1】A","type":"posts"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/","section":"Tags","summary":"","title":"快速幂","type":"tags"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95/","section":"Tags","summary":"","title":"数学归纳法","type":"tags"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E7%BB%84%E5%90%88%E6%95%B0/","section":"Tags","summary":"","title":"组合数","type":"tags"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/about/","section":"OrangeTree","summary":"","title":"About","type":"page"},{"content":"Hi there! I\u0026rsquo;m building my site in Chinese, wish to meet you one day.\nCiallo～(∠・ω\u0026lt; )⌒☆\n","date":"26 July 2024","externalUrl":null,"permalink":"/en/posts/building_my_site/building_my_site/","section":"Posts","summary":"Hi there!","title":"Building My Site","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]