


[{"content":"","date":"2024 August 30","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2024 August 30","externalUrl":null,"permalink":"/","section":"OrangeTree","summary":"","title":"OrangeTree","type":"page"},{"content":"","date":"2024 August 30","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"\rä¸‰å…ƒç¯è®¡æ•°æ˜¯å›¾è®ºä¸­ä¸€ä¸ªæ¯”è¾ƒé‡è¦çš„é—®é¢˜ï¼Œç”¨äºæ±‚è§£æ— å‘å›¾ä¸­ä¸‰å…ƒç¯çš„ä¸ªæ•°ã€‚\nä¸‰å…ƒç¯æŒ‡çš„æ˜¯ç®€å•å›¾ \\(G\\) ä¸­çš„ä¸€ä¸ªæ— åºä¸‰å…ƒç»„ \\((u,v,w)\\)ï¼Œæ»¡è¶³å­˜åœ¨ä¸‰æ¡è¾¹è¿æ¥ \\(u,v,w\\) ä¸‰ä¸ªç‚¹ã€‚\nä¸‰å…ƒç¯å¯ä»¥çœ‹ä½œæŸç§æ„ä¹‰ä¸Šçš„ç­‰ä»·å…³ç³»ï¼Œå³æ»¡è¶³è‡ªåæ€§ã€å¯¹ç§°æ€§å’Œä¼ é€’æ€§ï¼Œå¦‚æœè€ƒè™‘ä¼ é€’æ€§ï¼Œåˆ™æ¯ä¸ªä¸‰å…ƒç¯çš„ä¸‰æ¡è¾¹å‡çœ‹ä½œæœ‰å‘é‡è¾¹ï¼Œåœ¨ä»£ç å®ç°ä¸Šå¦‚æœä¸‰ç§ä¼ é€’æ€§éƒ½è¦éªŒè¯ï¼Œæ—¶é—´å¤æ‚åº¦ä¼šå¾ˆé«˜ã€‚\nå› æ­¤æˆ‘ä»¬å¯ä»¥è€ƒè™‘å°†ä¸‰å…ƒç¯çš„æ— å‘å›¾è½¬æ¢ä¸ºæœ‰å‘å›¾ï¼Œè¿™æ ·åªéœ€è¦éªŒè¯ä¸€ç§å…³ç³»çš„ä¼ é€’æ€§å³å¯ã€‚æˆ‘ä»¬å‡è®¾ï¼š\næœ‰å‘è¾¹ä»åº¦æ•°å°çš„è¾¹æŒ‡å‘åº¦æ•°å¤§çš„è¾¹ åº¦æ•°ç›¸åŒï¼Œæœ‰å‘è¾¹ä»ä¸‹æ ‡å°çš„è¾¹æŒ‡å‘ä¸‹æ ‡å¤§çš„è¾¹ å¾ˆå®¹æ˜“è¯æ˜è¯æ˜æ²¡æœ‰ç¯çš„å­˜åœ¨ï¼Œå› ä¸ºå¦‚æœå­˜åœ¨ç¯ï¼Œå¿…å®šä¼šå‡ºç°åº¦æ•°å¤§çš„æŒ‡å‘åº¦æ•°å°çš„è¾¹çš„æƒ…å†µï¼ˆç¯çš„é¦–å°¾ï¼‰ã€‚æ­¤æ—¶çš„å›¾ä¸ºä¸€å¼ æœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰ã€‚\nå› æ­¤å°†æ— å‘å›¾è½¬æ¢ä¸ºæœ‰å•å‘è¾¹çš„æœ‰å‘æ— ç¯å›¾ï¼Œæ¯æ¬¡éå† \\(u\\) çš„ç›¸é‚»ç‚¹ \\(v\\)ï¼Œç„¶åéªŒè¯ä¸ \\(v\\) çš„ç›¸é‚»ç‚¹ \\(w\\) æ˜¯å¦å­˜åœ¨ä¸€æ¡æœ‰å‘è¾¹å³å¯ã€‚æ­¤æ—¶ \\(w\\) ä¹Ÿä½œä¸º \\(u\\) çš„ç›¸é‚»ç‚¹å­˜åœ¨ï¼Œéå† \\(u\\) çš„ç›¸é‚»ç‚¹æ—¶åˆ¤æ–­ä¸€ä¸‹å°±å¯ä»¥äº†ã€‚\n1. ä»£ç  #\rC\u0026#43;\u0026#43;\rvoid solve() { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::vector\u0026lt;int\u0026gt; degree(n + 1), g[n + 1]; std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; op(m + 1); for (int i = 1; i \u0026lt;= m; i++) { int u, v; std::cin\u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; if (u \u0026gt; v) { std::swap(u, v); } op[i] = {u, v}; degree[u]++, degree[v]++; } for (int i = 1; i \u0026lt;= m; i++) { auto \u0026amp;[u, v] = op[i]; if (degree[u] \u0026gt; degree[v]) { std::swap(u, v); } g[u].push_back(v); } int num = 0; std::vector\u0026lt;int\u0026gt; vis(n + 1); for (int i = 1; i \u0026lt;= n; i++) { for (auto \u0026amp;j : g[i]) { vis[j] = 1; } for (auto \u0026amp;j : g[i]) { for (auto \u0026amp;k : g[j]) { if (vis[k]) { num++; } } } for (auto \u0026amp;j : g[i]) { vis[j] = 0; } } std::cout \u0026lt;\u0026lt; num; } 2. æ—¶é—´å¤æ‚åº¦ #\rç”±äºå°†æ¯æ¡æ— å‘è¾¹éƒ½è½¬æ¢ä¸ºäº†æœ‰å‘è¾¹ï¼Œå¯¼è‡´æ¯ä¸ªç‚¹çš„åº¦æ•°ä¸ºä¸è¶…è¿‡ \\(\\sqrt{m}\\)ï¼Œå› æ­¤éå†æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º \\(O(m\\log m)\\)ã€‚\n","date":"2024 August 30","externalUrl":null,"permalink":"/posts/algorithm/graphtheory/triangle/","section":"Posts","summary":"ä¸‰å…ƒç¯è®¡æ•°æ˜¯å›¾è®ºä¸­ä¸€ä¸ªæ¯”è¾ƒé‡è¦çš„é—®é¢˜ï¼Œç”¨äºæ±‚è§£æ— å‘å›¾ä¸­ä¸‰å…ƒç¯çš„ä¸ªæ•°ã€‚","title":"ä¸‰å…ƒç¯è®¡æ•°","type":"posts"},{"content":"","date":"2024 August 30","externalUrl":null,"permalink":"/categories/%E7%AE%97%E6%B3%95/","section":"Categories","summary":"","title":"ç®—æ³•","type":"categories"},{"content":"","date":"2024 August 30","externalUrl":null,"permalink":"/categories/%E5%9B%BE%E8%AE%BA/","section":"Categories","summary":"","title":"å›¾è®º","type":"categories"},{"content":"\rå¹¶æŸ¥é›†ï¼ˆDSUï¼‰æ˜¯ä¸€ç§è´Ÿè´£åˆå¹¶ã€æŸ¥è¯¢çš„é›†åˆï¼Œç”¨äºåˆ¤æ–­å…ƒç´ ä¹‹é—´çš„æ‰€å±å…³ç³»ã€‚\nå¹¶æŸ¥é›†çš„æ ¸å¿ƒæ€æƒ³å°±æ˜¯å¯¹æ¯ä¸ªå…ƒç´ éƒ½å»ºç«‹ä¸€ä¸ªæ ‡è®°ï¼Œæ¥è¡¨ç¤ºæ‰€å±é›†åˆçš„ä¸€ä¸ªä»£è¡¨å…ƒç´ ã€‚\nå‡å¦‚æˆ‘ä»¬ç”¨f[i]æ¥è¡¨ç¤ºç¬¬ \\(i\\) ä¸ªå…ƒç´ çš„ä»£è¡¨å…ƒç´ ï¼ˆæˆ–è€…æ˜¯ Father ï¼‰ã€‚åˆå§‹åŒ–å¯ä»¥å°†æ‰€æœ‰å…ƒç´ çš„ä»£è¡¨å…ƒç´ è®¾ä¸ºè‡ªå·±ï¼Œå³ï¼šf[i] = iã€‚\n1. æŸ¥è¯¢ #\r1. 1 ä¸€èˆ¬æŸ¥è¯¢ #\ræŸ¥è¯¢æŸä¸ªå…ƒç´ å±äºå“ªä¸€ä¸ªé›†åˆï¼Œå³æŸ¥è¯¢è¿™ä¸ªå…ƒç´ çš„ä»£è¡¨å…ƒç´ æ˜¯å“ªä¸€ä¸ªã€‚\nint find(int x) { return f[x] == x ? x : find(f[x]); } ç”±äºä»£è¡¨å…ƒç´ çš„ä»£è¡¨å…ƒç´ å³ä¸ºå®ƒæœ¬èº«ï¼Œæ•…å¾ˆå®¹æ˜“å¾—åˆ°ä¸Šè¿°çš„ä»£ç ã€‚\n1. 2 è·¯å¾„å‹ç¼©æŸ¥è¯¢ #\rå¹¶æŸ¥é›†çš„æœ¬è´¨æ˜¯ä¸€ç§æ ‘ï¼Œé€šè¿‡è¿™ç§æ–¹æ³•å¾—åˆ°çš„æ ‘çš„æ·±åº¦ä¼šå¾ˆå¤§ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¯¹æ ‘è¿›è¡Œè·¯å¾„å‹ç¼©ï¼Œä½¿å¾—é›†åˆä¸­æ¯ä¸ªå…ƒç´ çš„ä»£è¡¨å…ƒç´ éƒ½æ˜¯æ•´ä¸ªé›†åˆçš„ä»£è¡¨å…ƒç´ ã€‚\nint find(int x) { return f[x] == x ? x : f[x] = find(f[x]); } 2. åˆå¹¶ #\r2. 1 ä¸€èˆ¬åˆå¹¶ #\rå°†ä¸¤ä¸ªé›†åˆåˆå¹¶ï¼Œå…¶å®å°±æ˜¯å°†ä¸¤ä¸ªé›†åˆçš„ä»£è¡¨å…ƒç´ æ›´æ–°ä¸€ä¸‹ï¼Œä½¿å¾—å…¶ä¸­ä¸€ä¸ªé›†åˆçš„ä»£è¡¨å…ƒç´ æ˜¯å¦ä¸€ä¸ªé›†åˆä»£è¡¨å…ƒç´ çš„ä»£è¡¨å…ƒç´ ã€‚\nvoid merge(int x, int y) { f[find(x)] = find(y); } 2. 2 å¯å‘å¼åˆå¹¶ï¼ˆæŒ‰ç§©åˆå¹¶ï¼‰ #\rä¸€èˆ¬åˆå¹¶çš„é—®é¢˜åœ¨äºå¯èƒ½ä¼šå½±å“æœªæ¥æ“ä½œçš„å¤æ‚åº¦ï¼Œæ¯”å¦‚æ·±åº¦åŠ æ·±ç­‰ç­‰é—®é¢˜ã€‚æ‰€ä»¥æœ€å¥½çš„åˆå¹¶æ–¹å¼å°±æ˜¯å°†æ·±åº¦è¾ƒå°ï¼ˆæˆ–å…ƒç´ å°‘ï¼‰çš„é›†åˆåˆå¹¶åˆ°å¦ä¸€ä¸ªé›†åˆå»ã€‚\nå› æ­¤æˆ‘ä»¬éœ€è¦ä¸€ä¸ªsize[i]æ•°ç»„æ¥è®°å½•æ¯ä¸ªå…ƒç´ æ‰€åœ¨é›†åˆçš„å…ƒç´ ä¸ªæ•°ã€‚\nvoid merge(int x, int y) { int fx = find(x), fy = find(y); if (size[fx] \u0026gt; size[fy]) { std::swap(fx, fy); } f[fx] = fy; size[fy] += size[fx]; } 3. ç»“æ„ä½“ #\rå°†ä¸Šé¢çš„å‡½æ•°å¯ä»¥ç»Ÿä¸€ä¸ºä¸€ä¸ªç»“æ„ä½“çš„å½¢å¼ä¾¿äºå¹¶æŸ¥é›†çš„ç”Ÿæˆä¸æ“ä½œã€‚\nstruct DSU { std::vector\u0026lt;int\u0026gt; f, sz; DSU(int n) : f(n), sz(n, 1) { std::iota(f.begin(), f.end(), 0); } int find(int x) { return f[x] == x ? x : f[x] = find(f[x]); } bool merge(int x, int y) { int fx = find(x), fy = find(y); if (fx == fy) { return false; } if (sz[fx] \u0026gt; sz[fy]) { std::swap(fx, fy); } f[fx] = fy; sz[fy] += sz[fx]; return true; } bool same(int x, int y) { return find(x) == find(y); } }; 4. æ—¶é—´å¤æ‚åº¦ #\rå¹¶æŸ¥é›†çš„æ—¶é—´å¤æ‚åº¦å–å†³äºå®ç°æ–¹å¼ï¼š\næ— ä¼˜åŒ–ï¼š\\(O(n)\\)\nä»…è·¯å¾„å‹ç¼©/æŒ‰ç§©åˆå¹¶ï¼š\\(O(log(n))\\)\nè·¯å¾„å‹ç¼© + æŒ‰ç§©åˆå¹¶ï¼š\\(O(\\alpha(n))\\)ï¼Œå…¶ä¸­ \\(\\alpha(n)\\) ä¸º Ackermann å‡½æ•°çš„åå‡½æ•°\nAckermann å‡½æ•°\rAckermann å‡½æ•° \\(A(n,m)\\)å®šä¹‰ä¸ºï¼š\n\\(A(n,m)=\\begin{cases}m+1\u0026amp;\\texttt{if}\\ n=m\\\\A(n-1, 1)\u0026amp;\\texttt{if}\\ n\u0026gt;0\\ \\texttt{and}\\ m=0\\\\A(n-1,A(n,m-1))\u0026amp;\\texttt{otherwise}\\end{cases}\\)\n","date":"2024 August 26","externalUrl":null,"permalink":"/posts/data_structure/dsu/","section":"Posts","summary":"å¹¶æŸ¥é›†ï¼ˆDSUï¼‰æ˜¯ä¸€ç§è´Ÿè´£åˆå¹¶ã€æŸ¥è¯¢çš„é›†åˆï¼Œç”¨äºåˆ¤æ–­å…ƒç´ ä¹‹é—´çš„æ‰€å±å…³ç³»ã€‚","title":"å¹¶æŸ¥é›†","type":"posts"},{"content":"","date":"2024 August 26","externalUrl":null,"permalink":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"æ•°æ®ç»“æ„","type":"categories"},{"content":"\ræœ€å°ç”Ÿæˆæ ‘ï¼ˆMSTï¼‰æ˜¯è¿é€šåŠ æƒæ— å‘å›¾ä¸­æƒé‡æœ€å°çš„ç”Ÿæˆæ ‘ã€‚\næ±‚æœ€å°ç”Ÿæˆæ ‘çš„ç®—æ³•ä¸»è¦æœ‰ä¸¤ä¸ªï¼šKruskal å’Œ Prim\n1. Kruskal #\rKruskal ä¸»è¦ç”¨äºç¨€ç–å›¾çš„æœ€å°ç”Ÿæˆæ ‘çš„æ±‚è§£ã€‚\nç®—æ³•çš„æ ¸å¿ƒæ˜¯é€‰è¾¹ï¼šæ¯æ¬¡è´ªå¿ƒåœ°é€‰æ‹©å½“å‰è¾¹é›†ä¸­é€‰æ‹©æƒé‡æœ€å°çš„ã€ä¸”ä¸æ„æˆå›è·¯çš„è¾¹ã€‚\nç®—æ³•çš„å®ç°æ˜¯å¹¶æŸ¥é›†ï¼Œé€šè¿‡ç»´æŠ¤ä¸€ä¸ªæœ€å°æƒé‡çš„è¾¹çš„å¹¶æŸ¥é›†æ¥å®ç°æœ€å°ç”Ÿæˆæ ‘ã€‚\nå¹¶æŸ¥é›†å¯ä»¥å‚è€ƒï¼š\nå¹¶æŸ¥é›†\r2024 August 26\u0026middot;213 å­—\u0026middot;1 åˆ†é’Ÿ\ræ•°æ®ç»“æ„\rå¹¶æŸ¥é›†ï¼ˆDSUï¼‰æ˜¯ä¸€ç§è´Ÿè´£åˆå¹¶ã€æŸ¥è¯¢çš„é›†åˆï¼Œç”¨äºåˆ¤æ–­å…ƒç´ ä¹‹é—´çš„æ‰€å±å…³ç³»ã€‚\rKruskal åŠ¨å›¾è§£é‡Šã€‚æ¥æºï¼šOI-Wiki\r1. 1 ä»£ç  #\rC\u0026#43;\u0026#43;\rstruct DSU { std::vector\u0026lt;int\u0026gt; f, sz; DSU(int n) : f(n), sz(n, 1) { std::iota(f.begin(), f.end(), 0); } int find(int x) { return f[x] == x ? f[x] : f[x] = find(f[x]); } bool merge(int x, int y) { int fx = find(x), fy = find(y); if (fx == fy) { return false; } if (sz[fx] \u0026gt; sz[fy]) { std::swap(fx, fy); } f[fx] = fy; sz[fy] += sz[fx]; return true; } bool same(int x, int y) { return find(x) == find(y); } }; void solve() { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::vector\u0026lt;std::array\u0026lt;int, 3\u0026gt;\u0026gt; l; DSU node(n + 1); for (int i = 0; i \u0026lt; m; i++) { int u, v, w; std::cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; l.push_back({w, u, v}); } std::sort(l.begin(), l.end()); int sum = 0, num = 1; for (auto [w, u, v] : l) { if (node.merge(u, v)) { sum += w; num ++; } if (num == n) { break; } } if (num == n) { std::cout \u0026lt;\u0026lt; sum; } else { std::cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34;; } } å¯ä»¥çœ‹å‡ºï¼Œæˆ‘ä»¬æŒ‰ç…§è¾¹æƒçš„å¤§å°å¯¹è¾¹è¿›è¡Œæ’åºï¼Œç„¶åéå†è¾¹ã€‚åˆ¤æ–­ä¸€æ¡è¾¹æ˜¯å¦èƒ½åŠ å…¥åˆ°æœ€å°ç”Ÿæˆæ ‘ä¸­ï¼ˆå³ä¸æˆå›è·¯ï¼‰çš„ä¾æ®æ˜¯è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹æ˜¯å¦åœ¨åŒä¸€ä¸ªå¹¶æŸ¥é›†é‡Œé¢ã€‚\n1. 2 æ—¶é—´å¤æ‚åº¦ #\rKruskal çš„æ—¶é—´å¤æ‚åº¦ä¸º \\(O(mlog(m))\\)ï¼Œå³éå†è¾¹ä»¥åŠç»´æŠ¤å¹¶æŸ¥é›†çš„æ—¶é—´å¤æ‚åº¦ã€‚\n2. Prim #\rPrim ä¸»è¦ç”¨äºç¨ å¯†å›¾çš„æœ€å°ç”Ÿæˆæ ‘çš„æ±‚è§£ã€‚\nç®—æ³•çš„æ ¸å¿ƒæ˜¯é€‰ç‚¹ï¼šéšæœºé€‰æ‹©ä¸€ä¸ªç‚¹ä½œä¸ºèµ·ç‚¹ï¼Œæ¯æ¬¡è´ªå¿ƒåœ°é€‰æ‹©å½“å‰ç‚¹ç›¸é‚»è¾¹é›†ä¸­é€‰æ‹©æƒé‡æœ€å°çš„ã€ä¸”ä¸æ„æˆå›è·¯çš„è¾¹ã€‚\nç®—æ³•çš„å®ç°æ˜¯DFSï¼Œå³é€æ­¥é€‰æ‹©æ¯ä¸€ä¸ªç‚¹ã€‚\nPrim åŠ¨å›¾è§£é‡Šã€‚æ¥æºï¼šOI-Wiki\r1. 1 ä»£ç  #\rC\u0026#43;\u0026#43;\rstruct cmp { bool operator()(const std::pair\u0026lt;int, int\u0026gt; x, const std::pair\u0026lt;int, int\u0026gt; y) { return x.second \u0026gt; y.second; } }; void solve() { int n, m; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; g[n + 1]; for (int i = 0; i \u0026lt; m; i++) { int x, y, z; std::cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; g[x].push_back({y, z}); g[y].push_back({x, z}); } std::priority_queue\u0026lt;std::pair\u0026lt;int, int\u0026gt;, std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt;, cmp\u0026gt; l; std::vector\u0026lt;int\u0026gt; dis(n + 1, 0x3f3f3f3f); std::vector\u0026lt;bool\u0026gt; vis(n + 1, false); dis[1] = 0, l.push({1, 0}); int sum = 0, num = 0; while (!l.empty()) { if (num == n) { break; } auto [u, d] = l.top(); l.pop(); if (!vis[u]) { vis[u] = true; num ++; sum += d; for (auto [v, w] : g[u]) { if (!vis[v] \u0026amp;\u0026amp; w \u0026lt; dis[v]) { dis[v] = w, l.push({v, w}); } } } } if (num == n) { std::cout \u0026lt;\u0026lt; sum; } else { std::cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34;; } } æˆ‘ä»¬ä½¿ç”¨å †ä¼˜åŒ–çš„æ–¹å¼å®ç° Prim ï¼Œå…¶å®ç°æ–¹å¼ç±»ä¼¼äº Dijkstra é€æ­¥æ›´æ–°å‘¨è¾¹ç‚¹çš„è·ç¦»ä»è€Œæ‰¾åˆ°è·¯å¾„æœ€è¿‘çš„ç‚¹ã€‚\næ¯æ¬¡éƒ½å°†å‘¨å›´ç‚¹åˆ°å½“å‰ç‚¹çš„è·ç¦»éƒ½æ›´æ–°ä¸€æ¬¡ï¼Œç„¶åå‹å…¥å †ä¸­è¿›è¡Œé€‰æ‹©ã€‚ç”±äºæ¯æ¬¡éƒ½ä¼šåªé€‰æ‹©å †é¡¶å…ƒç´ åŠ å…¥åˆ° MST ä¸­ï¼Œåç»­æ›´æ–°å½“å‰ç‚¹çš„å‘¨å›´ç‚¹è·ç¦»çš„æ—¶å€™ï¼Œå¯èƒ½æŸäº›ç‚¹åœ¨ä¹‹å‰å·²ç»æ›´æ–°è¿‡äº†ï¼Œé‚£ä¹ˆå†æ¬¡åŠ å…¥å †ä¸­æ›´æœ‰å¯èƒ½å‡ºç°åˆ°å †é¡¶é™„è¿‘ï¼Œè€Œä¹‹å‰çš„é‚£æ¬¡æ›´æ–°è‡ªç„¶ä¸ä¼šå‡ºç°åˆ°è¿™æ¬¡æ›´æ–°ä¹‹ä¸Šäº†ã€‚\n1. 2 æ—¶é—´å¤æ‚åº¦ #\rPrim çš„æ—¶é—´å¤æ‚åº¦ä¸º \\(O((n+m)log(n))\\)ï¼Œå³éå†è¾¹ç»´æŠ¤æ£€æŸ¥å †ä»¥åŠé¡¶ç‚¹æ£€æŸ¥çš„æ—¶é—´å¤æ‚åº¦ä¹‹å’Œã€‚\nâ€‹\n","date":"2024 August 23","externalUrl":null,"permalink":"/posts/algorithm/graphtheory/mst/","section":"Posts","summary":"æœ€å°ç”Ÿæˆæ ‘ï¼ˆMSTï¼‰æ˜¯è¿é€šåŠ æƒæ— å‘å›¾ä¸­æƒé‡æœ€å°çš„ç”Ÿæˆæ ‘ã€‚","title":"æœ€å°ç”Ÿæˆæ ‘","type":"posts"},{"content":"\r1. é¢˜ç›® #\rEnglish\rThere are \\(2\\cdot n\\) cards arranged in a row, with each card numbered from \\(1\\) to \\(n\\) having exactly \\(2\\) copies.\nEach time, Red can choose a subarray of consecutive cards (at least \\(2\\) cards) to remove from the deck. The chosen subarray must satisfy that the first and last cards have the same number. The score for this operation is: the number of cards multiplied by the number on the first card.\nNow Red wants to know what is the maximum value of the final score?\nInput\nThe first line contains a positive integer \\(n(1\\leq n \\leq 3\\times 10^3)\\) â€” the number of card types.\nThe second line contains \\(2\\cdot n\\) positive integers \\(a_i(1\\leq a_i \\leq n)\\) â€” the number on each card from left to right.\nOutput\nA single positive integer â€” representing the maximum final score.\nç®€ä½“ä¸­æ–‡ï¼ˆå¤§æ„ï¼‰\rä¸€ä¸ªåºåˆ—åŒ…å« \\(1\\) ~ \\(n\\)ï¼Œæ¯ä¸ªæ•°å‡ºç°ä¸¤æ¬¡ã€‚æ¯æ¬¡é€‰æ‹©åˆ æ‰é¦–å°¾ä¸¤ä¸ªæ•°ç›¸åŒçš„åŒºé—´ï¼Œå¾—åˆ°çš„å€¼ä¸º åŒºé—´å…ƒç´ ä¸ªæ•° \\(\\times\\) é¦–/å°¾çš„æ•°ï¼Œå¹¶å°†æ‰€å¾—åˆ°çš„å€¼æ±‚å’Œã€‚æ±‚å’Œçš„æœ€å¤§å€¼ã€‚\r2. æ€è·¯ #\rè¿™å¾ˆæ˜¾ç„¶æ˜¯ä¸€ä¸ªåŒºé—´ DP é—®é¢˜ã€‚å¾ˆå®¹æ˜“æƒ³åˆ°ï¼ŒåŒºé—´å’ŒåŒºé—´ä¹‹é—´å¯èƒ½ä¼šå‡ºç°åŒ…å«å…³ç³»ï¼Œæ‰€ä»¥ä¸€ä¸ªå¤§çš„åŒºé—´å¯ä»¥ç”±æ‰€åŒ…å«çš„å°çš„åŒºé—´è½¬ç§»å¾—åˆ°ã€‚\nè™½ç„¶åŒºé—´ä¹‹é—´å¯èƒ½ä¼šæœ‰åŒ…å«å…³ç³»ï¼Œä½†æ˜¯æœ€åä¹Ÿæœ‰å¯èƒ½å‡ºç°å•ä¸ªæ²¡æœ‰é…å¯¹çš„æ•°ã€‚å› æ­¤æˆ‘ä»¬åœ¨åŸé¢˜çš„åŸºç¡€ä¸Šæ·»åŠ ä¸€ä¸ªæ¡ä»¶ï¼šåœ¨é¦–å°¾æ·»åŠ ä¸¤ä¸ª \\(0\\)ã€‚é—®é¢˜å°±å˜æˆäº†å°†æ‰€æœ‰æ•°éƒ½åˆ æ‰æ‰€èƒ½å¾—åˆ°çš„æœ€å¤§å€¼æ˜¯å¤šå°‘ï¼Œå› ä¸ºæœ€åå‡å¦‚è¿˜å‰©ä¸‹äº†æ— æ³•é…å¯¹çš„æ•°ï¼Œè™½ç„¶ä¸ä¼šäº§ç”Ÿè´¡çŒ®ï¼Œä½†æ˜¯å¯ä»¥å½’çº³åˆ° \\(0\\) çš„åŒºé—´é‡Œé¢ã€‚è¿™æ ·æ‰€æœ‰çš„æ•°éƒ½èƒ½é€šè¿‡è®¡ç®—é™¤å»ã€‚\nå‡å¦‚ä¸€ä¸ªå¤§çš„åŒºé—´åŒ…å«äº†å¾ˆå¤šå®Œæ•´çš„å°çš„åŒºé—´ï¼Œé‚£ä¹ˆçŠ¶æ€è½¬ç§»å°±å¯ä»¥å˜ä¸ºï¼šæ¯ä¸ªå°çš„åŒºé—´çš„æœ€å¤§å€¼ + å•ç‹¬å‡ºç°çš„å€¼äº§ç”Ÿçš„è´¡çŒ®ã€‚\nå› æ­¤å¯¹äºè¿™ä¸ªåŒºé—´çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºï¼š $$ dp(i)=\\max\\begin{cases}\\ dp(i-1) + x\\\\ dp(l(a(i)) - l(x) - 1) + ans(a(i)) \\texttt{ if l(x) \u0026lt; l(a(i)) and r(a(i)) = i + l(x)}\\end{cases} $$ å…¶ä¸­å½“å‰åŒºé—´çš„é¦–å°¾å…ƒç´ ä¸º \\(x\\)ï¼Œè€ƒè™‘åŒºé—´çš„å‰ \\(i\\) ä¸ªå…ƒç´ ï¼Œå¯¹äºå½“å‰è¿™ä¸ªæ•° \\(a(i)\\)ï¼Œ\\(l(i)\\) ä¸ºç¬¬ä¸€æ¬¡å‡ºç°çš„ä¸‹æ ‡ï¼Œ\\(r(i)\\) ä¸ºæœ€åä¸€æ¬¡å‡ºç°çš„ä¸‹æ ‡ï¼Œæœ‰ä¸¤ç§æ“ä½œç­–ç•¥ï¼š\né€‰æ‹© \\(a(i)\\) å’Œ \\(x\\) çš„åŒºé—´ä¸€èµ·åˆ æ‰ï¼Œåˆ™è´¡çŒ®ä¸º \\(dp(i-1)+x\\) å¦‚æœ \\(a(i)\\) æ‰€ä»£è¡¨çš„å®Œæ•´åŒºé—´åœ¨ \\(x\\) åŒºé—´å†…ï¼Œåˆ™ä¼˜å…ˆè€ƒè™‘è¿™ä¸ªä»£è¡¨åŒºé—´ï¼Œæ­¤æ—¶çš„ç­”æ¡ˆä¸ºé™¤äº† \\(a(i)\\) åŒºé—´çš„æœ€å¤§å€¼ \\(dp(l(i)-1)\\) åŠ ä¸Š \\(a(i)\\) åŒºé—´çš„æœ€å¤§å€¼ \\(ans(a(i))\\)ã€‚æœ€åè®© \\(ans(x)\\) ç­‰äº \\(dp(r(x))\\) å³å¯ã€‚ æ±‚ä¸€ä¸‹æœ€å¤§å€¼å°±å¯ä»¥äº†ã€‚å¾ˆæ˜¾ç„¶æœ€ç»ˆçš„ç­”æ¡ˆä¸º \\(ans(0)\\)ã€‚\n3. ä»£ç  #\rC\u0026#43;\u0026#43;\rvoid solve() { int n, m; std::cin \u0026gt;\u0026gt; n; m = (n \u0026lt;\u0026lt; 1); std::vector\u0026lt;int\u0026gt; a(m + 2); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; p(n + 1); a[0] = 0, a[m + 1] = 0; p[0] = {0, m + 1}; for (int i = 1; i \u0026lt;= m; i++) { std::cin \u0026gt;\u0026gt; a[i]; p[a[i]].push_back(i); } std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt; g(n + 1); for (int i = 1; i \u0026lt;= n; i++) { int l = p[i][0], r = p[i][1]; g[i] = {r - l + 1, i}; } g[0] = {m + 2, 0}; std::sort(g.begin(), g.end()); std::vector\u0026lt;int\u0026gt; ans(n + 1); for (int i = 0; i \u0026lt;= n; i++) { auto \u0026amp;[len, now] = g[i]; int l = p[now][0], r = p[now][1]; std::vector\u0026lt;int\u0026gt; dp(len); dp[0] = now; for (int j = 1; j \u0026lt; len; j++) { dp[j] = dp[j - 1] + now; int lx = p[a[j + l]][0], rx = p[a[j + l]][1]; if (lx \u0026gt; l \u0026amp;\u0026amp; rx == j + l) { dp[j] = std::max(dp[j], dp[lx - l - 1] + ans[a[j + l]]); } } ans[now] = dp[len - 1]; } std::cout \u0026lt;\u0026lt; ans[0]; } 4. æ€»ç»“ #\rè¿™ä¸ªæ˜¯ä¸€ä¸ªä»åŒºé—´ DP å˜åŒ–è€Œæ¥çš„é¢˜ç›®ï¼Œå°±æ˜¯å°†å­åŒºé—´çš„å’Œè½¬ç§»ä¸ºçˆ¶äº²åŒºé—´çš„å’Œæ¥è¾¾åˆ°åŠ¨æ€è§„åˆ’çš„ç›®çš„ã€‚\n","date":"2024 July 31","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/2/i/","section":"Posts","summary":"1.","title":"ã€2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥2ã€‘I","type":"posts"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/categories/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5/","section":"Categories","summary":"","title":"2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥","type":"categories"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/categories/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A52/","section":"Categories","summary":"","title":"2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥2","type":"categories"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/series/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A52/","section":"Series","summary":"","title":"2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥2","type":"series"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/categories/%E6%AF%94%E8%B5%9B/","section":"Categories","summary":"","title":"æ¯”èµ›","type":"categories"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"åŠ¨æ€è§„åˆ’","type":"tags"},{"content":"\r1. é¢˜ç›® #\rEnglish\rRed stands at the coordinate \\((0,0)\\) of the Cartesian coordinate system. She has a string of instructions: up, down, left, right (where right increases the x-coordinate by \\(1\\), and up increases the y-coordinate by \\(1\\)).\nNow Red wants to select a continuous substring of instructions and execute them. Red hopes that the final execution of the instructions can pass through the coordinate \\((x,y)\\). She wants to know how many selection options there are.\nInput\nThe first line contains three integers \\(n\\), \\(x\\), and \\(y\\) (\\(1 \\leq n \\leq 2 \\times 10^5, -10^5 \\leq x, y \\leq 10^5)\\), â€” the length of the instruction string and the coordinates Red hopes to pass through.\nThe second line contains a string of length nnn, consisting of the characters \\(W\\), \\(S\\), \\(A\\), and \\(D\\). â€” the four directions: up, down, left, and right, respectively.\nOutput\nOutput one integer representing the number of selection options for the continuous substring.\nç®€ä½“ä¸­æ–‡ï¼ˆå¤§æ„ï¼‰\rç»™å®šå­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºä¸€ä¸²ç§»åŠ¨æŒ‡ä»¤ï¼Œå‡å¦‚èµ·ç‚¹ä¸º \\((0,0)\\)ï¼Œæ±‚èƒ½åˆ°è¾¾ \\((x,y)\\) çš„å­ä¸²çš„ä¸ªæ•°ã€‚\r2. æ€è·¯ #\rç”±äºä¸Šä¸‹å·¦å³ç§»åŠ¨å¯¹åº”çš„æ˜¯åæ ‡çš„å˜åŒ–ï¼Œæ•…å¯ä»¥å°†å­—ç¬¦ä¸²è¡¨ç¤ºä¸ºå¯¹åº”çš„åæ ‡å˜åŒ–ï¼Œé—®é¢˜ä¾¿è½¬åŒ–æˆä¸ºï¼šå¯»æ‰¾åæ ‡å˜åŒ–ä¸º \\((x,y)\\) çš„åŒºé—´çš„ä¸ªæ•°ã€‚\nç”±äºåªéœ€è¦è·¯å¾„ç©¿è¿‡äº†ç›®æ ‡ç‚¹å°±å¯ä»¥ï¼Œæ•…å¯¹äºæ‰€æœ‰ç»ˆç‚¹åœ¨ \\((x,y)\\) çš„å­—ç¬¦ä¸²ä»¥åŠä»¥è¯¥å­—ç¬¦ä¸²ä¸ºå‰ç¼€çš„åç»­æ‰€æœ‰å­—ç¬¦ä¸²éƒ½æ»¡è¶³æ¡ä»¶ã€‚\næ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å‰ç¼€å’Œä¿å­˜åŒºé—´çš„ä¿¡æ¯ï¼Œç„¶åç¨ä½œå·®åˆ†è®¡ç®—ç¬¦åˆæ¡ä»¶çš„åŒºé—´çš„ä¸ªæ•°ã€‚\n3. ä»£ç  #\rC\u0026#43;\u0026#43;\rvoid solve() { int n, x, y; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; std::string s; std::cin \u0026gt;\u0026gt; s; if (x == 0 \u0026amp;\u0026amp; y == 0) { std::cout \u0026lt;\u0026lt; (n * (n + 1) \u0026gt;\u0026gt; 1); return; } std::vector\u0026lt;std::pair\u0026lt;i64, i64\u0026gt;\u0026gt; l(n + 1, {0, 0}); for (int i = 0; i \u0026lt; n; i++) { auto [x0, y0] = l[i]; if (s[i] == \u0026#39;A\u0026#39;) { x0--; } else if (s[i] == \u0026#39;D\u0026#39;) { x0++; } else if (s[i] == \u0026#39;W\u0026#39;) { y0++; } else { y0--; } l[i + 1] = {x0, y0}; } i64 num = 0; std::map\u0026lt;std::pair\u0026lt;i64, i64\u0026gt;, std::vector\u0026lt;int\u0026gt;\u0026gt; ref; for (int i = n; i \u0026gt;= 0; i--) { auto [x0, y0] = l[i]; if (!ref[{x + x0, y + y0}].empty()) { int min = *ref[{x + x0, y + y0}].begin(); num += n - min + 1; } ref[l[i]].push_back(i); std::sort(ref[l[i]].begin(), ref[l[i]].end()); } std::cout \u0026lt;\u0026lt; num; } 4. æ€»ç»“ #\rä»ä»£ç ä¸­å‘ç°ï¼Œå¯ä»¥ä½¿ç”¨ map å¯¹éå†è¿›è¡Œä¼˜åŒ–ã€‚ç”±äºæ­£å‘éå†è¦å¯¹æ¯ä¸€ä¸ªå‰ç¼€å’Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„å€¼ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º \\(O(n^2)\\) ï¼Œè€Œé€†åºéå†çš„æ—¶å€™å¯¹æ‰€æœ‰å·²ç»éå†è¿‡çš„å‰ç¼€å’Œè¿›è¡ŒæŸ¥è¯¢ï¼Œç”¨ map è¿›è¡Œäº†ä¿å­˜ï¼Œæ—¶é—´å¤æ‚åº¦é™åˆ°äº† \\(O(n\\cdot logn)\\)ã€‚\næ€»ä¹‹ä½¿ç”¨å‰ç¼€å’Œå¯ä»¥å¾ˆç®€å•çš„å¤„ç†å¯ä»¥å·®åˆ†çš„é—®é¢˜ã€‚\n","date":"2024 July 31","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/2/h/","section":"Posts","summary":"1.","title":"ã€2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥2ã€‘H","type":"posts"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/","section":"Tags","summary":"","title":"å‰ç¼€å’Œ","type":"tags"},{"content":"\r1. é¢˜ç›® #\rEnglish\rBen_H has a positive integer \\(x\\). He wants you to find another positive integer \\(y\\), which is strictly less than \\(x\\), so that the equation \\(gcd(x, y) = x \\oplus y\\) holds. Can you help him?\nwhere \\(\\oplus\\) is bitwise XOR operation.\nInput\nThe first line contains a single integer \\(t (1 \\leq t \\leq 10^4)\\) â€” the number of test cases.\nThe only line of each test case contains a single integer \\(x (1\\leq x \\leq 10^{18})\\).\nOutput\nFor each testcase, output a single positive integer \\(y\\), if you find a feasible answer, or \\(-1\\) otherwise.\nç®€ä½“ä¸­æ–‡ï¼ˆå¤§æ„ï¼‰\rç»™å®š \\(x\\)ï¼Œæ„é€  \\(y\\) ä½¿æ»¡è¶³ \\(gcd(x,y) = x\\oplus y\\)ã€‚\r2. æ€è·¯ #\rç­¾åˆ°é¢˜ï¼Œç”±äºé—®é¢˜åªéœ€è¦æ„é€ å‡ºä¸€ä¸ªæ•°æ»¡è¶³æ¡ä»¶å³å¯ï¼Œæ•…ä¸éœ€è¦éå†æ•´ä¸ªåŒºé—´ã€‚\nç”±æœ€å¤§å…¬çº¦æ•°çš„æ€§è´¨å¯çŸ¥ï¼Œ\\(gcd(x,y)\\) çš„ç»“æœé€šå¸¸ä¸ \\(x\\) æˆå€æ•°å…³ç³»ï¼Œè€Œç­‰å¼å³ä¾§åˆä¸ºäºŒè¿›åˆ¶çš„è¡¨ç¤ºå½¢å¼ï¼Œæ•…è€ƒè™‘æ˜¯å¦å­˜åœ¨ \\(2\\) çš„å€æ•°ã€‚\nåˆäºŒè¿›åˆ¶çš„è¡¨ç¤ºæ–¹æ³•çŸ¥é“ï¼Œè®¾ \\(x\\) çš„äºŒè¿›åˆ¶å½¢å¼ä¸º \\(10110100\\)ï¼Œåˆ™å¯ä»¥è¡¨ç¤ºä¸ºï¼š $$ 2^7 + 2^5 + 2^4 + 2^2 = (2^5 + 2^3 + 2^2 + 1)\\times 2^2 $$ æ•… \\(x\\) å¯ä»¥è¡¨ç¤ºä¸ºæœ€åä¸€ä¸ªä¸º \\(1\\) ä½æ‰€è¡¨ç¤ºçš„äºŒè¿›åˆ¶æ•°çš„å€æ•°ï¼Œå¯ä»¥é€šè¿‡è¡¥ç æ€§è´¨å¾—åˆ°ã€‚\nè¦ä¿è¯ä¸å³ä¾§çš„å¼‚æˆ–å€¼ç›¸åŒï¼Œåªè¦ä¿è¯ \\(y\\) çš„å‰åŠéƒ¨åˆ†ä¸ \\(x\\) ç›¸åŒï¼Œä» \\(x\\) çš„æœ€åä¸€ä¸ª \\(1\\) ä½å¾€åå‡ä¸º \\(0\\) å³å¯ï¼š $$ \\begin{array}{cc} x\u0026amp;10110100\\\\ y\u0026amp;10110\\color{red}{\\underline{0}00}\\\\ \\hline \\oplus\\rightarrow\u0026amp;00000\\color{blue}{100} \\end{array} $$\næ­¤å¤–è¦ç‰¹åˆ«æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœ \\(x\\) ä¸º \\(2^k\\)ï¼Œé‚£ä¹ˆæŒ‰ç…§è¿™ç§æ–¹æ³•æ‰¾åˆ°çš„æ•°ä¸º \\(0\\)ï¼Œä¸æ»¡è¶³æ¡ä»¶ã€‚\n3. ä»£ç  #\rC\u0026#43;\u0026#43;\rvoid solve() { i64 x; std::cin \u0026gt;\u0026gt; x; i64 lowbit = (x \u0026amp; -x); if (lowbit == x) { std::cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; x - lowbit \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } 4. æ€»ç»“ #\rç­¾åˆ°é¢˜ï¼Œä½†æ˜¯æœ¬é¢˜æ³¨æ„æ•°æ®èŒƒå›´ \\((1\\leq x \\leq 10^{18})\\) å¾ˆå¤§ï¼Œä¸è¦é€šè¿‡éå†å»æœç´¢æ»¡è¶³æ¡ä»¶çš„æ•°ï¼Œå°½é‡ä»äºŒè¿›åˆ¶çš„ç»“æ„ä¸Šå»æ„é€ ã€‚\næŒæ¡è·å–æœ€åä¸€ä¸ªä¸º \\(1\\) ä½çš„æ–¹æ³•ï¼Œä¹Ÿç»å¸¸è¿ç”¨äºæ ‘çŠ¶æ•°ç»„ä¸­ï¼šlowbit = (x \u0026amp; -x)ã€‚\n","date":"2024 July 31","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/2/e/","section":"Posts","summary":"1.","title":"ã€2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥2ã€‘E","type":"posts"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/tags/%E7%AD%BE%E5%88%B0%E9%A2%98/","section":"Tags","summary":"","title":"ç­¾åˆ°é¢˜","type":"tags"},{"content":"\r1. é¢˜ç›® #\rEnglish\rRed is on a \\(2\\cdot n\\) grid, with some cells being red and others being white.\nRed can initially choose a red cell, and at each step, can choose a red cell above, below, to the left, or to the right. When Red leaves a cell, the cell immediately turns white.\nRed wants to know the maximum number of steps she can take.\nIf there are no initial red cells, please output \\(0\\).\nInput\nThe first line contains a positive integer \\(n(1\\leq n \\leq 10^6)\\).\nThe next two lines contain a \\(2\\cdot n\\) character matrix, consisting only of R and W characters. R represents a red cell, and W represents a white cell.\nOutput\nAn integer â€” the maximum number of steps Red can take.\nç®€ä½“ä¸­æ–‡ï¼ˆå¤§æ„ï¼‰\råœ¨ \\(2\\times n\\) çš„æ ¼å­ä¸­æœ‰ R å’Œ Wï¼Œæ±‚ä»ä»»æ„ä¸€ä¸ª R å‡ºå‘èƒ½è¿ç»­èµ°åˆ°æœ€å¤šçš„ R çš„ä¸ªæ•°ã€‚\r2. æ€è·¯ #\rè¿™é“é¢˜æ˜¯ä¸€é“æ¯”è¾ƒç»å…¸çš„åŠ¨æ€è§„åˆ’é—®é¢˜ã€‚å‡å®šä»å·¦å¾€å³å¯»æ‰¾ï¼Œå½“å‰ä½ç½®å‡å¦‚ä¸º Rï¼Œåˆ™åªæœ‰å¯èƒ½ä»å·¦æ–¹æˆ–è€…å¦ä¸€æ¡çº¿çš„ R æ‰€åœ¨çš„æœç´¢è·¯çº¿ä¸ŠåŠ  \\(1\\) å¾—åˆ°ã€‚å› æ­¤æˆ‘ä»¬èƒ½æ¯”è¾ƒå®¹æ˜“å¾—åˆ°åŠ¨æ€è§„åˆ’çš„è½¬ç§»æ–¹ç¨‹ï¼š $$ \\begin{cases} dp(i,j,0)=\\max{(dp(i,j-1,0),dp(i,j-1,1))}\\\\ dp(i,j,1)=dp(1-i,j,0)+1 \\end{cases} $$ å…¶ä¸­ \\(dp(i,j,k)\\) æ•°ç»„è¡¨ç¤ºåæ ‡ä¸º \\((i,j)\\) çš„ R ä» \\(k\\) æ–¹å‘ä¸Šæ¥çš„ R çš„ä¸ªæ•°ï¼Œ\\(k=0\\) è¡¨ç¤ºä»å·¦æ–¹æ¥çš„ä¸ªæ•°ï¼Œ\\(k=1\\) è¡¨ç¤ºä»å¦ä¸€æ¡çº¿ä¸Šæ¥çš„ä¸ªæ•°ã€‚å¯¹äºåŒä¸€ä¸ªå…ƒç´ çš„ \\(k\\) å¯ä»¥é€šè¿‡å¦ä¸€æ¡çº¿åŠ  \\(1\\) å¾—åˆ°ã€‚\nç„¶åå¯¹æ‰€æœ‰çš„ \\(dp\\) æ•°ç»„éå†å¯»æ‰¾æœ€å¤§å€¼å³å¯ã€‚\n3. ä»£ç  #\rC\u0026#43;\u0026#43;\rvoid solve() { int n; std::cin \u0026gt;\u0026gt; n; std::string s[2]; for (int i = 0; i \u0026lt; 2; i++) { std::cin \u0026gt;\u0026gt; s[i]; } std::vector\u0026lt;std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; dp(2, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;(n, std::vector\u0026lt;int\u0026gt;(2, 0))); for (int j = 0; j \u0026lt; n; j++) { for (int i = 0; i \u0026lt; 2; i++) { if (s[i][j] == \u0026#39;R\u0026#39;) { dp[i][j][0] = 1; } } } for (int j = 0; j \u0026lt; n; j++) { for (int i = 0; i \u0026lt; 2; i++) { if (s[i][j] == \u0026#39;R\u0026#39; \u0026amp;\u0026amp; j \u0026gt; 0) { dp[i][j][0] += std::max(dp[i][j - 1][0], dp[i][j - 1][1]); } } for (int i = 0; i \u0026lt; 2; i++) { if (s[i][j] == \u0026#39;R\u0026#39;) { dp[i][j][1] = dp[i ^ 1][j][0] + 1; } } } int ans = 0; for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; n; j++) { for (int k = 0; k \u0026lt; 2; k++) { ans = std::max(ans, dp[i][j][k]); } } } std::cout \u0026lt;\u0026lt; std::max(0 ,ans - 1) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 4. æ€»ç»“ #\rç»å…¸çš„åŠ¨æ€è§„åˆ’ï¼Œæ‡‚ç‚¹æŒæ¡å¦‚ä½•è®¾è®¡åŠ¨æ€è½¬ç§»æ–¹ç¨‹ã€‚ä¸€èˆ¬å¯ä»¥å°†å·²æœ‰çš„æ¡ä»¶è®¾ç½®ä¸ºå¯ä»¥æ¨å¯¼çš„éƒ¨åˆ†ï¼ˆæ¯”å¦‚ä¸‹æ ‡ï¼‰ï¼Œè€Œè¦æ±‚çš„å€¼è®¾ç½®ä¸º dp æ•°ç»„çš„å€¼è¿›è¡Œé€’æ¨ã€‚\n","date":"2024 July 31","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/2/c/","section":"Posts","summary":"1.","title":"ã€2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥2ã€‘C","type":"posts"},{"content":"\r1. é¢˜ç›® #\rEnglish\rSajin has recently delved into the study of minimum spanning trees and now he has mastered the algorithm of MST.\nHe is eager to assess your grasp of minimum spanning tree concepts through a series of queries. You are confronted with an weighted undirected graph that encompasses nnn vertices and mmm edges without any self-loops.\nSajin presents \\(q\\) inquiries. For each, a vertex set \\(S\\) is given. Your objective is to determine the induced subgraph of \\(S\\) and find the weight of its minimum spanning tree.\nA minimum spanning tree (MST) is a subset of the edges of a connected, edge-weighted graph that connects all the vertices together without any cycles and with the minimum possible total edge weight.\nIn the mathematical field of graph theory, an induced subgraph of a graph is another graph, formed from a subset of the vertices of the graph and all of the edges, from the original graph, connecting pairs of vertices in that subset.\nIf the induced subgraph of \\(S\\) is disconnected, output \\(-1\\).\nInput\nThe first line contains \\(3\\) integers \\(n\\), \\(m\\), \\(q\\) (\\(2 \\le n \\le 10^5,1 \\le m, q \\le 10^5\\)), â€” the number of points, the number of edges, and the number of queries.\nThen mmm lines follow, each line contains three integers \\(u_i\\), \\(v_i\\), \\(w_i\\)(\\(1 \\le u_i, v_i \\le n\\), \\(u_i \\ne v_i\\), \\(1 \\le w_i \\le 10^9\\)), â€” the two endpoints of the iii-th edge and the edge weight.\nNext \\(q\\) lines, each line first contains an integer \\(k_i\\)(\\(1 \\le k_i \\le n\\)) â€” the size of the vertex set \\(S\\) for the \\(i\\)-th query.\nThen followed by \\(k_i\\) distinct integers \\(s_{i,j}\\)(\\(1 \\le s_{i,j} \\le n\\)) â€” the numbers of the vertex set \\(S\\) for the \\(i\\)-th query.\nIt is guaranteed that the sum of \\(k_i\\) over all queries does not exceed \\(10^5\\).\nOutput\nFor each query, output one integer representing the answer.\nç®€ä½“ä¸­æ–‡ï¼ˆå¤§æ„ï¼‰\rç»™ä½ ä¸€å¼ å›¾ï¼Œæ±‚å¯¼å‡ºå­å›¾çš„æœ€å°ç”Ÿæˆæ ‘ã€‚\r2. æ€è·¯ #\rè§‚å¯Ÿåˆ°ç‚¹å’Œè¾¹çš„æ•°æ®èŒƒå›´ï¼Œå‘ç°éå¸¸ç›¸è¿‘ï¼Œå¯ä»¥ç†è§£ä¸ºæ•´ä½“ä¸Šè¿™ä¸ªå›¾ä¸ºä¸€å¼ ç¨€ç–å›¾ï¼ˆä»é‚»æ¥çŸ©é˜µçœ‹æ¯”è¾ƒç›´è§‚ï¼‰ã€‚ç”±äºæœ¬é¢˜æ±‚çš„æ˜¯å¯¼å‡ºå­å›¾çš„æœ€å°ç”Ÿæˆæ ‘ï¼Œå¯¹äºç¨€ç–å›¾åœ¨å±€éƒ¨ä¸Šä¹Ÿå¯èƒ½ä¸ºä¸€å¼ ç¨ å¯†å›¾ã€‚\nå¯¹äºæœ€å°ç”Ÿæˆæ ‘å¸¸è§çš„ç®—æ³•æœ‰ Kruskal å’Œ Primï¼ŒKruskal å¸¸ç”¨äºç¨€ç–å›¾ï¼ŒPrim å¸¸è§äºç¨€ç–å›¾ã€‚å…·ä½“å¯ä»¥å‚è€ƒä¸‹é¢è¿™ç¯‡æ–‡ç« ï¼š\nç”±äºæœ¬é¢˜å¯¹äº Prim æ—¶é—´å¤æ‚åº¦çš„è¦æ±‚éå¸¸é«˜ï¼Œæ•…ä½¿ç”¨ Kruskal æ­é…è¾¹å­˜å‚¨ä¼˜åŒ–æ±‚è§£ã€‚\nKruskal çš„ç®—æ³•å°±æ˜¯ä»å°åˆ°å¤§éå†æ‰€æœ‰è¾¹ï¼Œå‡å¦‚ç»™å®šç‚¹é›† \\(S\\)ï¼Œé‚£ä¹ˆåœ¨éå†ä¸¤ç‚¹ç›¸é‚»çš„è¾¹æ—¶ï¼Œæ¯æ¡è¾¹ä¼šå­˜ä¸¤æ¬¡ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦é™ä½å­˜çš„é‡å¤è¾¹æ•°æ¥å‡å°‘åç»­éå†çš„æ¬¡æ•°ï¼Œæ ¹æ®ä¸‰å…ƒç¯è®¡æ•°çš„åŸç†ï¼Œæˆ‘ä»¬å¯ä»¥å­˜ä¸ºå•å‘è¾¹ï¼Œæ¯ä¸ªç‚¹å­˜çš„è¾¹æ•°ä¼šé™ä¸º \\(\\sqrt{m}\\)ã€‚\nä¸‰å…ƒç¯è®¡æ•°å‚è€ƒï¼š\nä¸‰å…ƒç¯è®¡æ•°\r2024 August 30\u0026middot;179 å­—\u0026middot;1 åˆ†é’Ÿ\rç®—æ³•\rå›¾è®º\rä¸‰å…ƒç¯è®¡æ•°æ˜¯å›¾è®ºä¸­ä¸€ä¸ªæ¯”è¾ƒé‡è¦çš„é—®é¢˜ï¼Œç”¨äºæ±‚è§£æ— å‘å›¾ä¸­ä¸‰å…ƒç¯çš„ä¸ªæ•°ã€‚\rç”±äºæœ‰èŠèŠ±å›¾å‡ºç°çš„å¯èƒ½ï¼Œå¦‚æœå•å‘è¾¹çš„èµ·ç‚¹ä»æ¯ä¸ªèŠèŠ±å›¾çš„ä¸­å¿ƒå¼€å§‹ï¼Œé‚£ä¹ˆä¸­å¿ƒæ‰€è¿çš„ç‚¹å¯èƒ½ä¸åœ¨ç‚¹é›† \\(S\\) ä¸­ï¼Œæ­¤æ—¶éå†çš„ç‚¹æ•°ä¼šæ¯”è¾ƒå¤šã€‚ä½†å¦‚æœä»èŠ±ç“£å¼€å§‹ï¼Œåˆ™ä¼šå‡å°‘è¿™ç§æƒ…å†µçš„å‡ºç°ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦è®°å½•ä¸‹æ¯ä¸ªç‚¹çš„åº¦æ•°ï¼Œå°†ä»åº¦æ•°å°çš„ç‚¹æŒ‡å‘åº¦æ•°å¤§çš„è¾¹å­˜èµ·æ¥ï¼Œåº¦æ•°ç›¸åŒåˆ™å­˜ä»ä¸‹æ ‡å°åˆ°ä¸‹æ ‡å¤§çš„è¾¹ã€‚\n3. ä»£ç  #\rC\u0026#43;\u0026#43;\rstruct DSU { std::vector\u0026lt;int\u0026gt; f, sz; DSU(int n) : f(n), sz(n, 1) { std::iota(f.begin(), f.end(), 0); } int find(int x) { return f[x] == x ? x : f[x] = find(f[x]); } bool merge(int x, int y) { int fx = find(x), fy = find(y); if (fx == fy) { return false; } if (sz[fx] \u0026gt; sz[fy]) { std::swap(fx, fy); } f[fx] = fy; sz[fy] += sz[fx]; return true; } bool same(int x, int y) { return find(x) == find(y); } }; void kruskal(int k, std::vector\u0026lt;std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; \u0026amp;p, std::vector\u0026lt;bool\u0026gt; \u0026amp;vis, std::vector\u0026lt;int\u0026gt; \u0026amp;s, DSU \u0026amp;node) { std::vector\u0026lt;std::array\u0026lt;int, 3\u0026gt;\u0026gt; l; for (auto \u0026amp;u : s) { for (auto \u0026amp;[v, w] : p[u]) { if (vis[v]) { l.push_back({w, u, v}); } } } std::sort(l.begin(), l.end()); i64 sum = 0, num = 1; for (auto \u0026amp;[w, u, v] : l) { if (num == k) { break; } if (node.merge(u, v)) { num ++; sum += w; } } if (num == k) { std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; } } void solve() { int n, m, q; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; DSU node(n + 1); std::vector\u0026lt;int\u0026gt; degree(n + 1); std::vector\u0026lt;std::array\u0026lt;int, 3\u0026gt;\u0026gt; op(m + 1); for (int i = 1; i \u0026lt;= m; i++) { int u, v, w; std::cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; if (u \u0026gt; v) { std::swap(u, v); } op[i] = {u, v, w}; degree[u]++; degree[v]++; } std::vector\u0026lt;std::vector\u0026lt;std::pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; p(n + 1); for (int i = 1; i \u0026lt;= m; i++) { auto \u0026amp;[u, v, w] = op[i]; if (degree[u] \u0026gt; degree[v]) { std::swap(u, v); } p[u].emplace_back(v, w); } std::vector\u0026lt;bool\u0026gt; vis(n + 1); while (q--) { int k; std::cin \u0026gt;\u0026gt; k; std::vector\u0026lt;int\u0026gt; s(k); for (int i = 0; i \u0026lt; k; i++) { std::cin \u0026gt;\u0026gt; s[i]; vis[s[i]] = true; node.f[s[i]] = s[i]; node.sz[s[i]] = 1; } kruskal(k, p, vis, s, node); for (auto \u0026amp;i : s) { vis[i] = false; } } } 4. æ€»ç»“ #\rè¿™é“é¢˜å…¶å®ä¸»ä½“è¿˜æ˜¯è€ƒå¯Ÿæœ€å°ç”Ÿæˆæ ‘çš„ç®—æ³•ï¼Œä½†æ˜¯éœ€è¦è€ƒè™‘å­˜è¾¹æ—¶å€™æ•ˆç‡é—®é¢˜ã€‚\nå€¼å¾—æ³¨æ„çš„æ˜¯ï¼š\nç¨€ç–å›¾ä½¿ç”¨ Kruskalï¼Œç¨ å¯†å›¾ä½¿ç”¨ Prim ä¸‰å…ƒç¯åŸç†å¯ä»¥å¸®åŠ©é™ä½è®¿é—®è¾¹çš„æ¬¡æ•° å‡½æ•°ä¼ å‚çš„æ—¶å€™ä¸€å®šè¦å¸¦ä¸Šå¼•ç”¨\u0026amp;ï¼Œç‰¹åˆ«æ˜¯åœ¨ä¼ é€’çš„æ•°ç»„æˆ–vectorç‰¹åˆ«å¤§æ—¶ï¼Œå¦‚æœé‡‡ç”¨å½¢å¼ä¼ å‚ï¼Œä¼šå¢åŠ å¤åˆ¶çš„æ—¶é—´å¤æ‚åº¦ã€‚è¦æ³¨æ„å¯¹äºåŸå§‹æ•°æ®çš„ä¿®æ”¹çš„é—®é¢˜ã€‚ ","date":"2024 July 31","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/2/b/","section":"Posts","summary":"1.","title":"ã€2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥2ã€‘B","type":"posts"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/tags/%E4%B8%89%E5%85%83%E7%8E%AF%E8%AE%A1%E6%95%B0/","section":"Tags","summary":"","title":"ä¸‰å…ƒç¯è®¡æ•°","type":"tags"},{"content":"","date":"2024 July 31","externalUrl":null,"permalink":"/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","section":"Tags","summary":"","title":"æœ€å°ç”Ÿæˆæ ‘","type":"tags"},{"content":"\rç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°æ˜¯ç»„åˆæ•°å­¦ä¸Šå¸¸è§çš„ä¸€ç§æ¦‚å¿µï¼Œç”¨äºè§£å†³é›†åˆæ‹†åˆ†çš„é—®é¢˜ã€‚\nã€é—®é¢˜1ã€‘å°† n ä¸ªå…ƒç´ æ‹†åˆ†ä¸º m ä¸ªéç©ºé›†åˆï¼Œæœ‰å¤šå°‘ç§æ–¹æ¡ˆï¼Ÿ\nã€é—®é¢˜2ã€‘å°† n ä¸ªè‹¹æœåˆ†ç»™ m ä¸ªäººï¼Œæ¯äººè‡³å°‘æœ‰ä¸€ä¸ªè‹¹æœï¼Œæœ‰å¤šå°‘ç§æ–¹æ¡ˆï¼Ÿ\nä¸Šè¿°çš„ä¸¤ä¸ªé—®é¢˜éƒ½å¯ä»¥ç”¨ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°è§£å†³ã€‚\nå°† \\(n\\) ä¸ªå…ƒç´ æ‹†åˆ†ä¸º \\(k\\) (\\(1\\leq k\\leq m\\)) ä¸ªé›†åˆçš„æ–¹æ¡ˆæ•°æˆ‘ä»¬è¡¨ç¤ºä¸º \\(S(n,k)\\)ï¼Œåˆ™æˆ‘ä»¬æœ€ç»ˆè¦æ±‚çš„æ–¹æ¡ˆæ•°å¯ä»¥è¡¨ç¤ºä¸º \\(S(n,m)\\)ã€‚æˆ‘ä»¬å¯ä»¥å¾—åˆ°é€’æ¨å¼ï¼š $$ S(n,k)=S(n-1,k-1)+C_k^1\\cdot S(n-1,k) $$\nå½“æ’å…¥ä¸€ä¸ªå…ƒç´ çš„æ—¶å€™ï¼Œæœ‰ä¸¤ç§æ–¹æ¡ˆï¼š\nå°†å…ƒç´ æ’å…¥åˆ°æ–°çš„é›†åˆï¼Œå…ƒç´ ä¸ªæ•°ä» \\(n-1\\) å˜ä¸º \\(n\\)ï¼Œé›†åˆä¸ªæ•°ä» \\(k-1\\) å˜ä¸º \\(k\\)ã€‚ åœ¨å·²æœ‰é›†åˆä»»é€‰ä¸€ä¸ªé›†åˆæ’å…¥å…ƒç´ ï¼Œå…ƒç´ ä¸ªæ•°ä» \\(n-1\\) å˜ä¸º \\(n\\)ï¼Œé›†åˆä¸ªæ•°ä¸å˜ã€‚ ","date":"2024 July 29","externalUrl":null,"permalink":"/posts/math/combinatorialmath/stirlingnumber/","section":"Posts","summary":"ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°æ˜¯ç»„åˆæ•°å­¦ä¸Šå¸¸è§çš„ä¸€ç§æ¦‚å¿µï¼Œç”¨äºè§£å†³é›†åˆæ‹†åˆ†çš„é—®é¢˜ã€‚","title":"ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°","type":"posts"},{"content":"","date":"2024 July 29","externalUrl":null,"permalink":"/categories/%E6%95%B0%E5%AD%A6/","section":"Categories","summary":"","title":"æ•°å­¦","type":"categories"},{"content":"","date":"2024 July 29","externalUrl":null,"permalink":"/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/","section":"Categories","summary":"","title":"ç»„åˆæ•°å­¦","type":"categories"},{"content":"\r1. é¢˜ç›® #\rEnglish\rThe ICPC World Finals are coming. Due to some reasons, the 46th and 47th World Finals will be held simultaneously. For the teams qualified in both competitions, they should choose one to take part in.\nAs we know, lzr010506\u0026rsquo;s team is double-qualified and should make a choice. To make a wiser choice, lzr010506 looked up the qualified lists for two competitions and trained a magic model to predict the results for all participants among the two competitions. Moreover, a result contains the number of solved problems and the time penalty. The more solved problems, the better the result is, and if two teams solved the same number of problems, the result with the lower time penalty is better.\nNow, lzr010506 wants to know the best possible ranking if the actual results are all the same as predicted and that the competition choices of the double-qualified teams can be arbitrarily arranged by him.\nInput\nThe first line contains one integer \\(n\\) (\\(1 \\le n \\le 10^5\\)), denoting the number of teams qualified in the 46th World Finals.\nNext nnn lines each contain one string \\(S\\) (\\(1 \\le |S| \\le 10\\)) and two integers \\(p,t\\) (\\(1 \\le p,t \\le 10^9\\)), denoting the name, the predicted number of solved problems, and time penalty of one team in the 46th World Finals respectively.\nNext one line contains one integer \\(m\\) (\\(1 \\le m \\le 10^5\\)), denoting the number of teams qualified in the 47th World Finals.\nNext \\(m\\) lines each contain one string \\(S\\) (\\(1 \\le |S| \\le 10\\)) and two integers \\(p,t\\) (\\(1 \\le p,t \\le 10^9\\)), denoting the name, the predicted number of solved problems, and time penalty of one team in the 47th World Finals respectively.\nIt is guaranteed that:\nthe team names only contain digits and English letters; the team names in one competition are different from each other; no two teams have the same predicted number of solved problems and the time penalty simultaneously in one competition; the same names among two qualified name lists refer to the same team in real; lzr010506 appears in both two qualified name lists. Output\nOutput one line containing one integer, denoting the best possible ranking of lzr010506\u0026rsquo;s team.\nç®€ä½“ä¸­æ–‡ï¼ˆå¤§æ„ï¼‰\rä¸€äº›é˜Ÿä¼åŒæ—¶å‚åŠ äº†ä¸¤åœºæ¯”èµ›ï¼Œä½†åªèƒ½é€‰æ‹©ä¸€åœºæ¯”èµ›ç§¯åˆ†ï¼Œæ±‚ lzr010506 èƒ½è·å¾—çš„æœ€é«˜åæ¬¡ã€‚\r2. æ€è·¯ #\rç­¾åˆ°é¢˜ï¼Œåªéœ€è¦å°†ä¸¤æ¬¡æ¯”èµ›çš„é˜Ÿä¼æŒ‰ç…§è§„åˆ™æ’ä¸ªåºï¼Œç„¶åå‡è®¾åœ¨ä¸¤åœºæ¯”èµ›åœ¨lzr010506ä¹‹å‰çš„é˜Ÿä¼éƒ½å‚åŠ å¦ä¸€åœºæ¯”èµ›ï¼ˆå¦‚æœèƒ½å‚åŠ å¦ä¸€åœºæ¯”èµ›çš„è¯ï¼‰ï¼Œæ¯”è¾ƒlzr010506åœ¨ä¸¤åœºæ¯”èµ›ä¸­çš„åæ¬¡å–æœ€å°å€¼ã€‚\n3. ä»£ç  #\rC\u0026#43;\u0026#43;\rstruct part { std::string s; int pass, pen; }; bool cmp(part x, part y) { if (x.pass \u0026gt; y.pass) { return true; } else if (x.pass == y.pass) { return x.pen \u0026lt; y.pen; } else { return false; } } void solve() { int n; std::cin \u0026gt;\u0026gt; n; std::set\u0026lt;std::string\u0026gt; l46b, l47b; std::vector\u0026lt;part\u0026gt; l46(n); for (int i = 0; i \u0026lt; n; i++) { std::string s; int p, t; std::cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; p \u0026gt;\u0026gt; t; l46[i] = {s, p, t}; l46b.insert(s); } int m; std::cin \u0026gt;\u0026gt; m; std::vector\u0026lt;part\u0026gt; l47(m); for (int i = 0; i \u0026lt; m; i++) { std::string s; int p, t; std::cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; p \u0026gt;\u0026gt; t; l47[i] = {s, p, t}; l47b.insert(s); } std::sort(l46.begin(), l46.end(), cmp); std::sort(l47.begin(), l47.end(), cmp); std::set\u0026lt;std::string\u0026gt; l46f, l47f; for (int i = 0; i \u0026lt; n; i++) { if (l46[i].s == \u0026#34;lzr010506\u0026#34;) { break; } l46f.insert(l46[i].s); } for (int i = 0; i \u0026lt; m; i++) { if (l47[i].s == \u0026#34;lzr010506\u0026#34;) { break; } l47f.insert(l47[i].s); } int num1 = 1, num2 = 1; for (auto i : l46f) { if (l47b.find(i) == l47b.end()) { num1 ++; } } for (auto i : l47f) { if (l46b.find(i) == l46b.end()) { num2 ++; } } std::cout \u0026lt;\u0026lt; std::min(num1, num2); } 4. æ€»ç»“ #\rç­¾åˆ°é¢˜\n","date":"2024 July 27","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/1/h/","section":"Posts","summary":"1.","title":"ã€2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥1ã€‘H","type":"posts"},{"content":"","date":"2024 July 27","externalUrl":null,"permalink":"/categories/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A51/","section":"Categories","summary":"","title":"2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥1","type":"categories"},{"content":"","date":"2024 July 27","externalUrl":null,"permalink":"/series/2024%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A51/","section":"Series","summary":"","title":"2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥1","type":"series"},{"content":"\r1. é¢˜ç›® #\rEnglish\rGiven an array which is initially empty, you need to perform \\(q\\) operations:\nGiven two non-negative integers \\(t\\) and \\(v\\), take out the element from the end of the array for \\(t\\) times and then append \\(v\\) to the end of the array. It is guaranteed that \\(t\\) does not exceed the length of the array before this operation. After each operation, let \\(a_1,a_2,\\dots,a_n\\) be the current array, find the sum of \\(s_1,s_2,\\dots,s_n\\) , where \\(s_i =a_i +a_{i+1}+\\dots+a_n\\) is the sum of the suffix starting from position \\(i\\).\nSince the answers may be very large, output them modulo \\(1000000007\\).\nInput\nThe first line contains an integer \\(q\\) ( \\(1\\leq q\\leq 5\\times 10^5\\) ), denoting the number of operations.\nEach of the following \\(q\\) lines contains two non-negative integers \\(t\\) and \\(v\\) ( \\(0\\leq v\\leq 10^9\\) ), describing an operation, where \\(t\\) does not exceed the length of the array before this operation.\nOutput\nOutput \\(q\\) lines, each of which contains an integer, denoting the answer.\nç®€ä½“ä¸­æ–‡ï¼ˆå¤§æ„ï¼‰\r\\(q\\) æ¬¡è¯¢é—®ï¼Œæ¯æ¬¡ä»åºåˆ—æœ«å°¾åˆ é™¤ \\(t\\) ä¸ªæ•°ï¼Œå¹¶æ·»åŠ ä¸€ä¸ªæ•° \\(v\\)ï¼Œæ±‚æ¯æ¬¡è¯¢é—®åçš„åç¼€å’Œçš„å’Œã€‚\r2. æ€è·¯ #\rè§‚å¯Ÿåˆ°å…ƒç´ åœ¨åç¼€å’Œä¸­æ‹¥æœ‰ä¸åŒçš„æƒé‡ï¼Œå‡å¦‚ \\(a_1,a_2,a_3,a_4=[1,2,3,4]\\)ï¼Œé‚£ä¹ˆæœ‰ï¼š $$ \\begin{aligned} s_1\u0026amp;=\u0026amp;a_1+a_2+a_3+a_4\\\\ s_2\u0026amp;=\u0026amp;a_2+a_3+a_4\\\\ s_3\u0026amp;=\u0026amp;a_3+a_4\\\\ s_4\u0026amp;=\u0026amp;a_4\\\\ \\end{aligned} $$ åˆ™è¯¥ \\(before=\\sum\\limits^n_{i=1}{s_i} = a_1+2a_2+3a_3+4a_4\\)ã€‚å‡å¦‚ \\(t=1\\)ï¼Œé‚£ä¹ˆæœ‰ï¼š $$ \\begin{aligned} s_1\u0026amp;=\u0026amp;a_1+a_2+a_3\\\\ s_2\u0026amp;=\u0026amp;a_2+a_3\\\\ s_3\u0026amp;=\u0026amp;a_3\\\\ s_4\u0026amp;=\u0026amp;\\\\ \\end{aligned} $$ æ­¤æ—¶ \\(after=\\sum\\limits^{n-t}_{i=1}{s_i} = a_1+2a_2+3a_3=before-4a_4\\)ã€‚\nè®¡ç®— \\(\\sum\\limits^n_{i=1}{s_i}\\) æ—¶ï¼Œæ¯æ¬¡ä»æœ«å°¾åˆ é™¤ \\(t\\) ä¸ªå…ƒç´ ï¼Œéƒ½ä¼šåˆ æ‰å¯¹åº”çš„ æƒé‡ \\(\\times\\) æ•°ã€‚\né‚£ä¹ˆæ¯æ¬¡æ“ä½œçš„æ—¶å€™ï¼Œåªéœ€è¦åœ¨æ€»çš„ \\(\\sum\\limits^n_{i=1}{s_i}\\) ä¸Šè¿›è¡Œå¢åˆ å°±å¯ä»¥äº†ã€‚\n3. ä»£ç  #\rC\u0026#43;\u0026#43;\rconstexpr int mod = 1000000007; void solve() { int q; std::cin \u0026gt;\u0026gt; q; i64 sum = 0; std::stack\u0026lt;i64\u0026gt; l; while (q--) { i64 t, v; std::cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; v; while (t--) { sum += mod; // é˜²æ­¢å‡çš„æ—¶å€™æˆä¸ºè´Ÿæ•° sum -= (l.top() * l.size()) % mod; sum %= mod; l.pop(); } l.push(v); sum += (v * l.size()) % mod; sum %= mod; std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } 4. æ€»ç»“ #\rè¿™ä¸ªé¢˜ä¸»è¦å¯¹æ¨¡è¿ç®—è¿›è¡Œäº†è€ƒå¯Ÿï¼Œæœ‰å‡ ä¸ªç‚¹éœ€è¦ç‰¹åˆ«æ³¨æ„ä¸€ä¸‹ï¼š\næ¨¡è¿ç®—ä¸­ï¼š\\((A\\pm* B)\\mod P=((A\\mod P)\\pm* (B\\mod P))\\mod P\\) ç”±äºç¬¬ä¸€æ¡ç‰¹æ€§ï¼Œåœ¨ç¨‹åºçš„å‡æ³•çš„è¿‡ç¨‹ä¸­ä¼šå¯¹æ¯ä¸€é¡¹å…ƒç´ å–æ¨¡åå†å–æ¨¡ï¼Œæ‰€ä»¥åœ¨è®¡ç®—è¿‡ç¨‹ä¸­è¿­ä»£å™¨å¾ˆå®¹æ˜“åœ¨åšå‡æ³•çš„æ—¶å€™å˜ä¸ºè´Ÿæ•°ï¼Œæ­¤æ—¶éœ€è¦åœ¨å¯¹è¿­ä»£å™¨å–æ¨¡å‰å…ˆåŠ ä¸Šä¸€ä¸ªæ¨¡æ•°é˜²æ­¢æº¢å‡ºã€‚ ","date":"2024 July 26","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/1/c/","section":"Posts","summary":"1.","title":"ã€2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥1ã€‘C","type":"posts"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E6%A8%A1%E8%BF%90%E7%AE%97/","section":"Tags","summary":"","title":"æ¨¡è¿ç®—","type":"tags"},{"content":"\r1. é¢˜ç›®ï¼ˆProblem A Enhancedï¼‰ #\rEnglish\rGiven two integers \\(n\\) and \\(m\\), among all the sequences containing \\(n\\) non-negative integers less than \\(2^m\\), you need to count the number of such sequences \\(A\\) that there exists two different non-empty subsequencesc of \\(A\\) in which the bitwise AND of the integers is \\(1\\).\nNote that a non-empty subsequence of a sequence \\(A\\) is a non-empty sequence that can be obtained by deleting zero or more elements from \\(A\\) and arranging the remaining elements in their original order. Two subsequences are different if they are composed of different locations in the original sequence.\nSince the answer may be very large, output it modulo a positive integer \\(q\\).\nThe bitwise AND of non-negative integers \\(A\\) and \\(B\\), \\(A\\) AND \\(B\\) is defined as follows:\nWhen \\(A\\) AND \\(B\\) is written in base two, the digit in the \\(2^d\\)\u0026rsquo;s place ( \\(d\\geq 0\\) ) is \\(1\\) if those of \\(A\\) and \\(B\\) are both \\(1\\), and \\(0\\) otherwise. For example, we have \\(4\\) AND \\(6\\) = \\(4\\) (in base two: \\(100\\) AND \\(110\\) = \\(100\\)).\nGenerally, the bitwise AND of \\(k\\) non-negative integers \\(p_1,ğ‘_2,\\dots,p_k\\) is defined as (\\(\\dots\\)((\\(p_1\\) AND \\(p_2\\)) AND \\(p_3\\)) AND \\(\\dots\\) AND \\(p_ğ‘˜\\)) and we can prove that this value does not depend on the order of \\(p_1,ğ‘_2,\\dots,p_k\\).\nInput\nThe only line contains three integers \\(n\\) (\\(1 \\le n \\le 5,000\\)), \\(m\\) (\\(1 \\le m \\le 5,000\\)) and \\(q\\) (\\(1 \\le q \\le 10^9\\)).\nOutput\nOutput a line containing an integer, denoting the answer.\nç®€ä½“ä¸­æ–‡ï¼ˆå¤§æ„ï¼‰\rç»™ä¸¤ä¸ªæ•° \\(n\\) å’Œ \\(m\\)ï¼Œè¡¨ç¤º \\(n\\) ä¸ª \\(m\\) ä½ï¼ˆBï¼‰é•¿åº¦çš„æ•°ï¼Œå¯»æ‰¾ã€ä»…å­˜åœ¨ä¸€ä¸ª AND å’Œä¸º \\(1\\) çš„å­åºåˆ—ã€‘çš„åºåˆ—çš„ä¸ªæ•°ã€‚\r2. æ€è·¯ #\rè¿™æ˜¯ \\(A\\) é¢˜çš„åŠ å¼ºç‰ˆï¼Œ\\(A\\) é¢˜å‰åºå†…å®¹å‚è€ƒï¼š\næ­¤é¢˜å¯ä»¥ç®€åŒ–ä¸ºï¼š\\(A\\) é¢˜ä¸­çš„ç­”æ¡ˆ -ã€æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªå­åºåˆ— AND å’Œä¸º 1 ã€‘çš„æ•°é‡ã€‚\nå¯ä»¥æ ¹æ® \\(A\\) é¢˜çš„æ¨å¯¼è¿‡ç¨‹å‘ç°ï¼Œæ¯æ¬¡æˆ‘ä»¬é€‰æ‹© \\(k\\) ä¸ªæœ«å°¾å‡ä¸º \\(1\\) çš„æ•°ï¼Œå‰©ä¸‹çš„ \\(n - k\\) æ•°æœ«å°¾å‡ä¸º \\(0\\)ï¼Œé‚£ä¹ˆä»…æœ‰çš„è¿™ä¸ª AND å’Œä¸º \\(1\\) çš„å­åºåˆ—å¿…é¡»ä¸ºå½“å‰é€‰å®šçš„ \\(k\\) ä¸ªæ•°çš„å­åºåˆ—ã€‚ä½†æ˜¯è¿™ä¸ªå­åºåˆ—è¦æƒ³æ»¡è¶³å”¯ä¸€çš„æ¡ä»¶ï¼Œå°±å¿…é¡»ä¿®æ”¹ã€é™¤æœ«å°¾ä¸º \\(1\\)ï¼Œå…¶ä½™ \\(m - 1\\) ä½ä»»é€‰å« \\(0\\) çš„ \\(2^k-1\\) ç§é€‰æ‹©ã€‘çš„æ¡ä»¶ã€‚\nå‡å¦‚ \\(k=3\\)ï¼Œæœ€åä¸€ä½ä¸º \\(1\\)ï¼Œé‚£ä¹ˆä¸‹å¼ä¸­çš„æ‰€æœ‰çš„ \\(\\underline{\\bold{0}}\\) å‡ä¸ºæ‰€æœ‰é€‰ä¸­çš„ \\(k\\) ä¸ªæ•°ä¸­æ‰€åœ¨ä½å”¯ä¸€çš„ \\(0\\)ï¼ˆç§°ä¸ºç‰¹æ®Šä½ï¼‰ï¼š $$ \\begin{array}{c|ccc|c} \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\\\ \\hline p_1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \\\\ p_2 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \\\\ p_3 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \\\\ \\end{array} $$ å› æ­¤å¯ä»¥å‘ç°ï¼Œå½“é€‰å– \\(k\\) ä¸ªæ•°ä¸ºå­åºåˆ—çš„æ—¶å€™ï¼Œæˆ‘ä»¬è¦æ»¡è¶³è¿™äº›æ•°éƒ½è‡³å°‘åŒ…å«ä¸€ä¸ªç‰¹æ®Šä½ï¼Œå½“æ»¡è¶³ \\(1\\leq k\\leq m-1\\) çš„æ—¶å€™ï¼Œç¡®ä¿ä¸ä¼šæœ‰é‡å¤çš„ç‰¹æ®Šä½å‡ºç°ï¼š $$ \\begin{array}{c|ccccc|c} \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; \\dots \u0026amp; m-1 \u0026amp; m \\\\ \\hline p_1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \u0026amp; 1 \\\\ p_2 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \u0026amp; 1 \\\\ p_3 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; \\dots \u0026amp; 1 \u0026amp; 1 \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots\\\\ p_k \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \\end{array} $$ å½“åˆ é™¤è¿™äº›ç‰¹æ®Šä½çš„æ—¶å€™ï¼Œå°±ä¼šä½¿å¾—æŸä¸€ä½ä¸å«æœ‰ \\(0\\)ï¼Œä¸æ»¡è¶³ AND å’Œä¸º \\(1\\) çš„æ¡ä»¶ï¼Œç¡®ä¿äº†å”¯ä¸€æ€§ã€‚\nå‡å¦‚æ­¤æ—¶é€‰å–äº† \\(k-1\\) ä¸ªæ•°ï¼Œå½“åœ¨ä¸º \\(k\\) ä¸ªæ•°æ·»åŠ ç‰¹æ®Šä½çš„æ—¶å€™ï¼Œæœ‰ä»¥ä¸‹ä¸¤ç§æƒ…å†µï¼š\næ·»åŠ åˆ°æ–°é€‰æ‹©çš„æ•°çš„æŸä¸€ä½ä¸Šã€‚ æ·»åŠ åˆ°å·²é€‰æ‹©çš„ \\(k-1\\) ä¸­æŸä¸€ä¸ªæ•°çš„æŸä¸€ä½ä¸Š æˆ‘ä»¬é‡‡ç”¨åŠ¨æ€è§„åˆ’ï¼Œå‡è®¾é€‰æ‹© \\(k\\) ä¸ªæ•°ï¼Œæœ‰ \\(t\\) (\\(k\\leq t\\leq m-1\\)) ä¸ªç‰¹æ®Šä½çš„æ–¹æ¡ˆæ•°ä¸º \\(dp(k,t)\\)ï¼Œé‚£ä¹ˆçŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºï¼š $$ dp(k,t)=C^1_k\\cdot(dp(k-1,t-1) + dp(k,t-1)) $$ å³ç‰¹æ®Šä½è¦ä¹ˆåŠ åœ¨ \\(k-1\\) ä¸ªæ•°çš„åŸºç¡€ä¸Šæ–°åŠ çš„ä¸€ä¸ªæ•°ä¸Šï¼Œè¦ä¹ˆåŠ åœ¨å·²ç»å­˜åœ¨çš„ä¸€ä¸ªæ•°ä¸Šã€‚ç›´è§‚ä½“ç°ä¸ºå¦‚ä¸‹ä¸¤ç§æƒ…å†µï¼ˆçº¢è‰²ä¸ºå·²æœ‰çš„ç‰¹æ®Šä½ï¼Œè“è‰²ä¸ºæ–°åŠ çš„ç‰¹æ®Šä½ï¼‰ï¼š $$ \\begin{align*} \\begin{array}{c|cccccc|c} \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; \\dots \u0026amp; 6 \\\\ \\hline p_1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \\\\ p_2 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \\\\ p_3 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1\\\\ p_4 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{blue}{\\underline{\\bold{0}}} \u0026amp; \\dots \u0026amp; 1\\\\ \\end{array} \\hspace{1cm} \\begin{array}{c|cccccc|c} \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; \\dots \u0026amp; 5 \\\\ \\hline p_1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \\\\ p_2 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1 \\\\ p_3 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; 1 \u0026amp; 1 \u0026amp; \\dots \u0026amp; 1\\\\ p_4 \u0026amp; 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\color{red}{\\underline{\\bold{0}}} \u0026amp; \\color{blue}{\\underline{\\bold{0}}} \u0026amp; \\dots \u0026amp; 1\\\\ \\end{array} \\end{align*} $$ ç”±äº \\(t\\) çš„èŒƒå›´ä¸º \\(k\\leq t\\leq m-1\\)ï¼Œç›¸å½“äºå°† \\(t\\) ä¸ªç‰¹æ®Šä½åˆ†ç»™ \\(k\\) ä¸ªæ•°ï¼Œæ¯ä¸ªæ•°è‡³å°‘å«æœ‰ä¸€ä¸ªç‰¹æ®Šä½ï¼Œç±»ä¼¼äºç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°ï¼Œæ•…ä¹Ÿå¯ä»¥ç»“åˆæ–¯ç‰¹æ—æ•°çš„æ¨å¯¼è¿‡ç¨‹ç†è§£çŠ¶æ€è½¬ç§»æ–¹ç¨‹ã€‚\néœ€è¦æ³¨æ„çš„æ˜¯ï¼š\nå½“ \\(k=1\\) çš„æ—¶å€™ï¼Œå½“ä¸”ä»…å½“å­åºåˆ—ä¸º \\(1\\) çš„æ—¶å€™ï¼Œè¿™ä¸ªæ•°æ»¡è¶³æ¡ä»¶ï¼Œéœ€è¦å•ç‹¬è®¡ç®—ï¼š\\(C_n^1\\cdot2^{(n-1)\\cdot(m-1)}\\) å½“ \\(k\u0026gt;1\\) çš„æ—¶å€™ï¼Œæˆ‘ä»¬é€‰æ‹©å…¶ä¸­ \\(t\\) ä½ï¼Œå…¶ä»– \\(m-1-t\\) ä½ä¾ç„¶å¯ä»¥ä»»é€‰ï¼Œä½†æ˜¯æ³¨æ„æ¯ä½ä¸èƒ½åªå«æœ‰ä¸€ä¸ª \\(0\\) ï¼ˆé˜²æ­¢æˆä¸ºç‰¹æ®Šä½ï¼Œæœ‰ k ç§åªæœ‰ä¸€ä½æœ‰ \\(0\\) æƒ…å†µï¼‰ï¼Œå†å‡å»å…¨ä¸º \\(1\\) çš„æƒ…å†µï¼š\\((2^k-k-1)^{{m-1-t}}\\) äºæ˜¯æœ€ç»ˆç»“æœä¸ºï¼š $$ \\begin{align*} ans \u0026amp;= \\sum\\limits_{k=1}^n(C_n^k \\cdot(2^k-1)^{m-1}\\cdot2^{(m-1)\\cdot(n-k)})-\\sum\\limits_{k=2}^n(C_n^k\\cdot2^{(m-1)\\cdot(n-k)}\\cdot\\sum\\limits_{t=k}^{m-1}(C_{m-1}^t\\cdot dp(k,t)\\cdot(2^k-k-1)^{m-1-t}))+C_n^1\\cdot2^{(n-1)\\cdot(m-1)}\\\\ \u0026amp;=\\sum\\limits_{k=2}^n(C_n^k\\cdot2^{(m-1)\\cdot(n-k)}\\cdot((2^k-1)^{m-1}-\\sum\\limits_{t=k}^{m-1}(C_{m-1}^t\\cdot dp(k,t)\\cdot(2^k-k-1)^{m-1-t}))) \\end{align*} $$\n3. ä»£ç  #\rC\u0026#43;\u0026#43;\ri64 binpow(i64 a, i64 b, i64 mod) { a %= mod; i64 ans = 1; while (b \u0026gt; 0) { if (b \u0026amp; 1) { ans *= a; ans %= mod; } a *= a; a %= mod; b \u0026gt;\u0026gt;= 1; } return ans; } void solve() { int n, m; i64 q; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; std::vector\u0026lt;i64\u0026gt; a(n + 1), c(n + 1), ct(m); a[0] = c[0] = ct[0] = 1; for (int k = 1; k \u0026lt;= n; k++) { a[k] = a[k - 1] \u0026lt;\u0026lt; 1; a[k] %= q; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = i; j \u0026gt; 0; j--) { c[j] = (c[j] + c[j - 1]) % q; } } for (int i = 1; i \u0026lt;= m - 1; i++) { for (int j = i; j \u0026gt; 0; j--) { ct[j] = (ct[j] + ct[j - 1]) % q; } } std::vector\u0026lt;std::vector\u0026lt;i64\u0026gt;\u0026gt; dp(n + 1, std::vector\u0026lt;i64\u0026gt;(m)); dp[0][0] = 1; for (int k = 1; k \u0026lt;= n; k++) { for (int t = 1; t \u0026lt;= m - 1; t++) { dp[k][t] = ((dp[k][t - 1] + dp[k - 1][t - 1]) % q * k) % q; } } i64 ans = 0; for (int k = 2; k \u0026lt;= n; k++) { i64 tmp1 = binpow(a[k] - 1, m - 1, q); i64 tmp2 = 0, tp = (a[k] + q - k - 1) % q, tmpt = 1; for (int t = m - 1; t \u0026gt;= k; t--) { tmp2 += ((ct[t] * dp[k][t]) % q * tmpt) % q; tmp2 %= q; tmpt *= tp; tmpt %= q; } i64 tmp3 = binpow(a[n - k], m - 1, q); ans += (((tmp1 + q - tmp2) % q * tmp3) % q * c[k]) % q; ans %= q; } std::cout \u0026lt;\u0026lt; ans; } 4. æ€»ç»“ #\ræœ¬é¢˜æ˜¯ \\(A\\) é¢˜çš„åŠ å¼ºç‰ˆï¼Œåœ¨ \\(A\\) çš„åŸºç¡€ä¸Šå¼•å…¥äº†ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°çš„æ€æƒ³å¯¹ã€æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªå­åºåˆ— AND å’Œä¸º 1 ã€‘è¿›è¡Œäº†è§£é‡Šå’Œæ¨å¯¼ï¼Œæ˜¯å¯¹äºè§„å¾‹æ€»ç»“å’Œç»„åˆæ•°å­¦çš„å¾ˆå¥½çš„ç»ƒä¹ ã€‚\nç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°è¯·å‚è€ƒï¼š\n","date":"2024 July 26","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/1/b/","section":"Posts","summary":"1.","title":"ã€2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥1ã€‘B","type":"posts"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E7%AC%AC%E4%BA%8C%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/","section":"Tags","summary":"","title":"ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°","type":"tags"},{"content":"\r1. é¢˜ç›® #\rEnglish\rGiven two integers \\(n\\) and \\(m\\), among all the sequences containing \\(n\\) non-negative integers less than \\(2^m\\), you need to count the number of such sequences \\(A\\) that there exists a non-empty subsequence of \\(A\\) in which the bitwise AND of the integers is \\(1\\).\nNote that a non-empty subsequence of a sequence \\(A\\) is a non-empty sequence that can be obtained by deleting zero or more elements from \\(A\\) and arranging the remaining elements in their original order.\nSince the answer may be very large, output it modulo a positive integer \\(q\\).\nThe bitwise AND of non-negative integers \\(A\\) and \\(B\\), \\(A\\) AND \\(B\\) is defined as follows:\nWhen \\(A\\) AND \\(B\\) is written in base two, the digit in the \\(2^d\\)\u0026rsquo;s place ( \\(d\\geq 0\\) ) is \\(1\\) if those of \\(A\\) and \\(B\\) are both \\(1\\), and \\(0\\) otherwise. For example, we have \\(4\\) AND \\(6\\) = \\(4\\) (in base two: \\(100\\) AND \\(110\\) = \\(100\\)).\nGenerally, the bitwise AND of \\(k\\) non-negative integers \\(p_1,ğ‘_2,\\dots,p_k\\) is defined as (\\(\\dots\\)((\\(p_1\\) AND \\(p_2\\)) AND \\(p_3\\)) AND \\(\\dots\\) AND \\(p_ğ‘˜\\)) and we can prove that this value does not depend on the order of \\(p_1,ğ‘_2,\\dots,p_k\\).\nInput\nThe only line contains three integers \\(n\\) (\\(1 \\le n \\le 5,000\\)), \\(m\\) (\\(1 \\le m \\le 5,000\\)) and \\(q\\) (\\(1 \\le q \\le 10^9\\)).\nOutput\nOutput a line containing an integer, denoting the answer.\nç®€ä½“ä¸­æ–‡ï¼ˆå¤§æ„ï¼‰\rç»™ä¸¤ä¸ªæ•° \\(n\\) å’Œ \\(m\\)ï¼Œè¡¨ç¤º \\(n\\) ä¸ª \\(m\\) ä½ï¼ˆBï¼‰é•¿åº¦çš„æ•°ï¼Œå¯»æ‰¾ã€å­˜åœ¨ AND å’Œä¸º \\(1\\) çš„å­åºåˆ—ã€‘çš„åºåˆ—çš„ä¸ªæ•°ã€‚\r2. æ€è·¯ #\rè¿™æ˜¯ä¸€é“æ‰¾è§„å¾‹çš„é¢˜ã€‚é€šè¿‡è§‚å¯Ÿæ ·ä¾‹2 3 998244353 -\u0026gt; 17å¯ä»¥å‘ç°å¦‚ä¸‹çš„è®¡ç®—è¿‡ç¨‹ï¼š\né€‰æ‹©å«æœ‰ä¸€ä¸ªæ•°çš„å­åºåˆ—ï¼Œåˆ™é€‰æ‹©çš„è¿™ä¸ªå­åºåˆ—å¿…é¡»ä¸º 001ã€‚å¦å¤–ä¸€ä¸ªæ•°çš„å„ä½ä»»é€‰ï¼Œæœ‰ \\(2^3\\) ç§æ–¹æ¡ˆã€‚ç”±äºå­åºåˆ—æŒ‰ç…§ä¸åŒé¡ºåºæ’åˆ—ç®—ä½œä¸åŒçš„å­åºåˆ—ï¼Œé‚£å°†001æ”¾åœ¨å¦ä¸€ä¸ªæ•°çš„ä½ç½®ä¸ºå¦ä¸€ç§æƒ…å†µã€‚æ­¤æ—¶è¿˜éœ€è¦å‡å»[001, 001]çš„æƒ…å†µï¼Œå‡ºç°äº†ä¸¤æ¬¡ã€‚æ•…æ­¤æ—¶çš„ç»“æœä¸º \\(2^3+2^3 - 1=15\\)ã€‚ é€‰æ‹©å«æœ‰ä¸¤ä¸ªæ•°çš„å­åºåˆ—ï¼Œåˆ™é€‰æ‹©çš„ä¸¤ä¸ªå­åºåˆ—çš„æœ«å°¾é‚£ä¸€ä½å¿…é¡»å‡ä¸º \\(1\\)ã€‚ç”±äºåˆšåˆšå·²ç»è®¡ç®—è¿‡äº†å…¶ä¸­ä¸€ä½ä¸º001çš„æƒ…å†µï¼Œå†åŠ ä¸Šä¸¤ä¸ªæœ«å°¾ä¸º \\(1\\) ä½†æ˜¯ä¸ä¸º001çš„æƒ…å†µï¼š[101, 011]å’Œ[011, 101]ã€‚æ•…æ­¤æ—¶çš„ç»“æœä¸º \\(15+2=17\\)ã€‚ å°†ä¸Šé¢çš„è¿‡ç¨‹è¿›è¡Œæ¨å¹¿æˆ‘ä»¬å¯ä»¥å‘ç°æœ‰å¦‚ä¸‹çš„è§„å¾‹ï¼š\né€‰æ‹©å…¶ä¸­çš„ \\(k\\) ä¸ªæ•°ï¼Œä½¿å¾—è¿™ \\(k\\) ä¸ªæ•°çš„æœ«å°¾ä¸€ä½å‡ä¸º \\(1\\)ï¼Œè€Œå…¶ä»–ä½ä¸Šçš„æ•°ï¼Œä¿è¯è‡³å°‘å‡ºç°ä¸€ä¸ª \\(0\\)ã€‚æˆ‘ä»¬å¯ä»¥çŸ¥é“ç¬¬ \\(i\\) ä½çš„æ•°å­—èŒƒå›´ä¸º[000...0~111...1]ï¼Œå½“æˆ‘ä»¬å»é™¤æœ€åä¸€ä¸ªå…¨ä¸º \\(1\\) çš„æ•°ï¼Œå…¶ä»–çš„æ•°å‡æ»¡è¶³å‡ºç°è‡³å°‘ä¸€ä¸ª \\(0\\)ã€‚æ­¤æ—¶çš„èŒƒå›´ä¸º \\(C_n^k \\cdot(2^k-1)^{m-1}\\)ï¼Œå³ä» \\(n\\) ä¸ªæ•°ä¸­ä»»é€‰ \\(k\\) ä¸ªæ•°å¹¶å¯¹é™¤äº†æœ€åä¸€ä½çš„å…¶ä½™ \\(m-1\\) ä½éƒ½è·å–äº† \\(2^k-1\\) ç§ç»“æœã€‚ ç„¶åå¯¹äºå‰©ä¸‹çš„ \\(n-k\\) ä¸ªæ•°ï¼Œä»»æ„é€‰æ‹©æ¯ä¸€ä½ä¸Šçš„ç»“æœï¼Œä¸ºäº†ä¿è¯ä¸ä¼šé‡å¤è®¡ç®—ï¼Œè®©å‰©ä¸‹çš„ \\(n-k\\) ä¸ªæ•°çš„æœ€åä¸€ä½å‡ä¸º \\(0\\)ã€‚æ­¤æ—¶çš„èŒƒå›´ä¸º \\((2^{m-1})^{n-k}=2^{(m-1)\\cdot(n-k)}\\)ï¼Œå³å¯¹æ¯ä¸€ä¸ªæ•°é€‰å®šæœ€åä¸€ä½ä¸º \\(0\\)ï¼Œå…¶ä½™ä½ç½®ä»»é€‰ã€‚ äºæ˜¯æœ€ç»ˆçš„ç»“æœä¸ºï¼š $$ \\sum\\limits_{k=1}^n(C_n^k \\cdot(2^k-1)^{m-1}\\cdot2^{(m-1)\\cdot(n-k)}) $$\n3. ä»£ç  #\rC\u0026#43;\u0026#43;\ri64 binpow(i64 a, i64 b, i64 mod) // å¿«é€Ÿå¹‚ { a %= mod; i64 ans = 1; while (b \u0026gt; 0) { if (b \u0026amp; 1) { ans = (ans * a) % mod; } a = (a * a) % mod; b \u0026gt;\u0026gt;= 1; } return ans; } void solve() { int n, m; i64 q; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; std::vector\u0026lt;i64\u0026gt; a(n + 1), c(n + 1); a[0] = c[0] = 1; for (int k = 1; k \u0026lt;= n; k++) { a[k] = a[k - 1] \u0026lt;\u0026lt; 1; a[k] %= q; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = i; j \u0026gt; 0; j--) { c[j] = (c[j] + c[j - 1]) % q; } } i64 ans = 0; for (int k = 1; k \u0026lt;= n; k++) { i64 tmp1 = binpow(a[k] - 1, m - 1, q); i64 tmp2 = binpow(a[n - k], m - 1, q); ans += ((tmp1 * tmp2) % q * c[k]) % q; ans %= q; } std::cout \u0026lt;\u0026lt; ans; } 4. æ€»ç»“ #\ræœ¬é¢˜ä¸»è¦æ˜¯è€ƒå¯Ÿæ‰¾è§„å¾‹çš„æŠ€å·§ï¼Œé€šè¿‡æ•°å­¦å½’çº³æ³•å¯¹æ ·ä¾‹çš„æ¨å¯¼è¿‡ç¨‹è¿›è¡Œæ€»ç»“ï¼Œç„¶åæ¨å¯¼å‡ºè®¡ç®—å…¬å¼ã€‚\næ­¤å¤–ï¼Œæœ¬é¢˜è¿˜æœ‰å‡ ä¸ªå°çš„çŸ¥è¯†ç‚¹ï¼š\nç»„åˆæ•°çš„è®¡ç®—ï¼Œé€šè¿‡å‹ç¼©åˆ°ä¸€ç»´å‡å°‘ç©ºé—´çš„ä½¿ç”¨ã€‚ å–æ¨¡è¿ç®—çš„æŠ€å·§ã€‚ ç”¨å¿«é€Ÿå¹‚åŠ å¿«å¹‚çš„è¿ç®—ã€‚ æ€»ä¹‹è¿™é“é¢˜è€ƒéªŒé€‰æ‰‹åœ¨èµ›åœºä¸Šæ€»ç»“è§„å¾‹çš„èƒ½åŠ›å’Œç»„åˆæ•°å­¦ä»¥åŠå…¶ä»–çš„åŸºæœ¬åŠŸã€‚\n","date":"2024 July 26","externalUrl":null,"permalink":"/posts/contest/24nowcodersummer/1/a/","section":"Posts","summary":"1.","title":"ã€2024ç‰›å®¢æš‘æœŸå¤šæ ¡è®­ç»ƒè¥1ã€‘A","type":"posts"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/","section":"Tags","summary":"","title":"å¿«é€Ÿå¹‚","type":"tags"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95/","section":"Tags","summary":"","title":"æ•°å­¦å½’çº³æ³•","type":"tags"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/tags/%E7%BB%84%E5%90%88%E6%95%B0/","section":"Tags","summary":"","title":"ç»„åˆæ•°","type":"tags"},{"content":"","date":"2024 July 26","externalUrl":null,"permalink":"/about/","section":"OrangeTree","summary":"","title":"About","type":"page"},{"content":"Hi there! I\u0026rsquo;m building my site in Chinese, wish to meet you one day.\nCialloï½(âˆ ãƒ»Ï‰\u0026lt; )âŒ’â˜†\n","date":"26 July 2024","externalUrl":null,"permalink":"/en/posts/building_my_site/building_my_site/","section":"Posts","summary":"Hi there!","title":"Building My Site","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]